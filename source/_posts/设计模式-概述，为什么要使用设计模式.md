---
title: 设计模式-概述，为什么要使用设计模式
date: 2021-05-13 13:39:46
tags: 设计模式
cover: /img/shejimoshi.jpeg
categories:
  - 设计模式
---
### 设计模式（Design pattern）


> GOF(gong of for)可复用面向对象软件元素
- 对接口编程而不是对实现编程
- 优先使用对象组合而不是继承

### 设计模式的类型（23种）
基本可以分为四大类：
- 创建型模式（Creational Patterns）
  提供一种在创建对象的时候隐藏逻辑方法的形式，而不是直接new一个对象，这使得程序在判断针对某个特定的实例需要创建哪些对象的时候更加灵活。
- 结构型模式 (Structural Patterns)
  关注类和对象组合，集成的概念用来组合接口和定义组合对象 获取新的功能方式
- 行为型模式 (Behavioral Patterns)
  关注对象之间的通信
- j2EE模式
  这些模式主要由java 中的设计模式提供（Sun Java Center）

|      | 模式描述   |                             包括                             |
| :--- | ---------- | :----------------------------------------------------------: |
| 1    | 创建型模式 | 工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern） |
| 2    | 结构型模式 | 适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern） |
| 3    | 行为型模式 | 责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern） |
| 4    | J2ee型模式 | MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） |





### 设计模式 之间关系

![](https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg)

### 设计模式的六大原则

1. 开闭原则（Open Close Principle）:
    **对扩展开放，对修改关闭** ，在程序需要进行扩展的时候，不能去修改原代码，实现一个热拔插的效果。为了的是使程序的扩展性更好，易于维护和升级，我们需要使用接口和抽象类来实现

2. 里氏代换原则（Liskow Substitution Priciple）

    任何基类出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位不受影响的时候，基类才能真正的被附中，而派生类可以在基类中增加新的行为，LSP是对开闭原则的补充。开闭原则关键步骤就是抽象化，基类与子类的继承关系就是抽象化的具体实现，即：对实现抽象化具体步骤的规范

3. 依赖倒转原则（Dependence Inversion Priciple）

    针对接口变成，依赖于抽象而不依赖于具体

4. 接口隔离原则（Interface Segregation Priciple）

    多实用隔离的接口，比使用单个接口更好。降低类之间的耦合度。

5. 迪米特法则（Demeter Priciple）

    最少知道的原则：一个实体应当尽量少跟其他实体之间发生相互的作用，是得系统模块相对

6. 合成复用原则（composite Reuse Priciple）

    尽量使用合成/聚合方式，而不是使用继承