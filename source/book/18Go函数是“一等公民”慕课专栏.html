<html><head><meta charset="utf-8"><title>18 Go 函数是“一等公民”-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        18 Go 函数是“一等公民”
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2020-10-26 09:34:48
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img1.sycdn.imooc.com/5f924b0c0001d8b306400425.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">智慧，不是死的默念，而是生的沉思。——斯宾诺莎<p></p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">函数（function）作为现代编程语言的基本语法元素存在于支持各种范式（paradiam）的主流编程语言当中。无论是命令式语言 C、多范式通用编程语言 C++，还是面向对象编程语言 Java、Ruby，亦或是函数式语言 Haskell、动态脚本语言 Python、PHP、JavaScript，函数这一语法元素都是当仁不让的核心。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Go 语言以“成为新一代系统级语言”为目标而诞生，但在演化过程中，逐渐演化成了面向并发、契合现代硬件发展趋势的通用编程语言。Go 语言中没有那些典型的面向对象语言的语法，比如类、继承、对象等。Go 语言中的方法（method）本质上亦是函数的一个“变种”。因此，在 Go 语言中，函数是唯一一种基于特定输入、实现特定任务并可反馈任务执行结果的代码块。本质上我们可以说 Go 程序就是一组函数的集合。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">和其他编程语言中的函数相比，Go 语言的函数具有如下特点：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">以“func”关键字开头；</li>
<li style="font-size: 20px; line-height: 38px;">支持多返回值；</li>
<li style="font-size: 20px; line-height: 38px;">支持具名返回值；</li>
<li style="font-size: 20px; line-height: 38px;">支持递归调用；</li>
<li style="font-size: 20px; line-height: 38px;">支持同类型的可变参数；</li>
<li style="font-size: 20px; line-height: 38px;">支持 defer，实现函数优雅返回</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">更为关键的是函数在 Go 语言中属于“一等公民(first-class citizen)”。众所周知，并不是在所有编程语言中函数都是“一等公民”，本节中我就和大家一起来看看成为”一等公民“的函数都有哪些特质可以帮助我们写出优雅简洁的代码。</p>
</div><div class="cl-preview-section"><h2 id="什么是“一等公民”" style="font-size: 30px;">1. 什么是“一等公民”</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">关于什么是编程语言的“一等公民”，业界并没有教科书给出精准的定义。这里引用一下 wiki 发明人、C2 站点作者<a href="http://c2.com/">沃德·坎宁安(Ward Cunningham)</a>对“一等公民”的<a href="http://wiki.c2.com//?FirstClass">诠释</a>：</p>
</div><div class="cl-preview-section"><blockquote>
<p style="font-size: 20px; line-height: 38px;">如果一门编程语言对某种语言元素的创建和使用没有限制，我们可以像对待值(value)一样对待这种语法元素，那么我们就称这种语法元素是这门编程语言的“一等公民”。拥有“一等公民”待遇的语法元素可以存储在变量中，可以作为函数传递给函数，可以在函数内部创建并可以作为返回值从函数返回。在动态类型语言中，语言运行时还支持对“一等公民”类型的检查。</p>
</blockquote>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">基于上面关于“一等公民”的诠释，我们来看看 Go 语言的函数是如何满足上述条件而成为“一等公民”的。</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">正常创建</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们可以在源码顶层正常创建一个函数，如下面的函数 newPrinter：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/fmt/print.go</span>
<span class="token keyword">func</span> <span class="token function">newPrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>pp <span class="token punctuation">{</span>
	p <span class="token operator">:=</span> ppFree<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>pp<span class="token punctuation">)</span>
	p<span class="token punctuation">.</span>panicking <span class="token operator">=</span> <span class="token boolean">false</span>
	p<span class="token punctuation">.</span>erroring <span class="token operator">=</span> <span class="token boolean">false</span>
	p<span class="token punctuation">.</span>wrapErrs <span class="token operator">=</span> <span class="token boolean">false</span>
	p<span class="token punctuation">.</span>fmt<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>p<span class="token punctuation">.</span>buf<span class="token punctuation">)</span>
	<span class="token keyword">return</span> p
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">在函数内创建</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在 Go 语言中，我们可以在函数内定义一个新函数，如下面代码中在 hexdumpWords 函数内部定义的匿名函数（被赋值给变量 p1)。在 C/C++中我们无法实现这一点，这也是 C/C++语言中函数不是“一等公民”的原因之一。</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/runtime/print.go</span>
<span class="token keyword">func</span> <span class="token function">hexdumpWords</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> end <span class="token builtin">uintptr</span><span class="token punctuation">,</span> mark <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        p1 <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x <span class="token builtin">uintptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">var</span> buf <span class="token punctuation">[</span><span class="token number">2</span> <span class="token operator">*</span> sys<span class="token punctuation">.</span>PtrSize<span class="token punctuation">]</span><span class="token builtin">byte</span>
                <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>
                        <span class="token keyword">if</span> x<span class="token operator">&amp;</span><span class="token number">0xF</span> <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token punctuation">{</span>
                                buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span><span class="token number">0xF</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'0'</span>
                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                                buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">byte</span><span class="token punctuation">(</span>x<span class="token operator">&amp;</span><span class="token number">0xF</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token string">'a'</span>
                        <span class="token punctuation">}</span>
                        x <span class="token operator">&gt;&gt;=</span> <span class="token number">4</span>
                <span class="token punctuation">}</span>
                <span class="token function">gwrite</span><span class="token punctuation">(</span>buf<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
	<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">作为类型</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们可以使用函数来自定义类型，如下面代码中的 HandlerFunc、visitFunc 和 action：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/net/http/server.go</span>
<span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>

<span class="token comment">// $GOROOT/src/sort/genzfunc.go</span>
<span class="token keyword">type</span> visitFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ast<span class="token punctuation">.</span>Node<span class="token punctuation">)</span> ast<span class="token punctuation">.</span>Visitor

<span class="token comment">// codewalk: https://tip.golang.org/doc/codewalk/functions/</span>
<span class="token keyword">type</span> action <span class="token keyword">func</span><span class="token punctuation">(</span>current score<span class="token punctuation">)</span> <span class="token punctuation">(</span>result score<span class="token punctuation">,</span> turnIsOver <span class="token builtin">bool</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">存储到变量中</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们可以将定义好的函数存储到一个变量中，如下面代码中的 apply：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/runtime/vdso_linux.go</span>
<span class="token keyword">func</span> <span class="token function">vdsoParseSymbols</span><span class="token punctuation">(</span>info <span class="token operator">*</span>vdsoInfo<span class="token punctuation">,</span> version <span class="token builtin">int32</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token operator">!</span>info<span class="token punctuation">.</span>valid <span class="token punctuation">{</span>
                <span class="token keyword">return</span>
        <span class="token punctuation">}</span>

        apply <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>symIndex <span class="token builtin">uint32</span><span class="token punctuation">,</span> k vdsoSymbolKey<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
                sym <span class="token operator">:=</span> <span class="token operator">&amp;</span>info<span class="token punctuation">.</span>symtab<span class="token punctuation">[</span>symIndex<span class="token punctuation">]</span>
                typ <span class="token operator">:=</span> <span class="token function">_ELF_ST_TYPE</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>st_info<span class="token punctuation">)</span>
                bind <span class="token operator">:=</span> <span class="token function">_ELF_ST_BIND</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>st_info<span class="token punctuation">)</span>

		<span class="token operator">...</span> <span class="token operator">...</span>

                <span class="token operator">*</span>k<span class="token punctuation">.</span>ptr <span class="token operator">=</span> info<span class="token punctuation">.</span>loadOffset <span class="token operator">+</span> <span class="token function">uintptr</span><span class="token punctuation">(</span>sym<span class="token punctuation">.</span>st_value<span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
	<span class="token operator">...</span> <span class="token operator">...</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">作为参数传入函数</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们可以将函数作为参数传入函数，比如下面代码中函数 AfterFunc 的参数 f：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go">$GOROOT<span class="token operator">/</span>src<span class="token operator">/</span>time<span class="token operator">/</span>sleep<span class="token punctuation">.</span><span class="token keyword">go</span>

<span class="token keyword">func</span> <span class="token function">AfterFunc</span><span class="token punctuation">(</span>d Duration<span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">*</span>Timer <span class="token punctuation">{</span>
        t <span class="token operator">:=</span> <span class="token operator">&amp;</span>Timer<span class="token punctuation">{</span>
                r<span class="token punctuation">:</span> runtimeTimer<span class="token punctuation">{</span>
                        when<span class="token punctuation">:</span> <span class="token function">when</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span>
                        f<span class="token punctuation">:</span>    goFunc<span class="token punctuation">,</span>
                        arg<span class="token punctuation">:</span>  f<span class="token punctuation">,</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        <span class="token function">startTimer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">.</span>r<span class="token punctuation">)</span>
        <span class="token keyword">return</span> t
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">作为返回值从函数返回</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">函数还可以被作为返回值从函数返回，如下面代码中函数 makeCutsetFunc 的返回值就是一个函数：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/strings/strings.go</span>
<span class="token keyword">func</span> <span class="token function">makeCutsetFunc</span><span class="token punctuation">(</span>cutset <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>cutset<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> cutset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> utf8<span class="token punctuation">.</span>RuneSelf <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
                        <span class="token keyword">return</span> r <span class="token operator">==</span> <span class="token function">rune</span><span class="token punctuation">(</span>cutset<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> as<span class="token punctuation">,</span> isASCII <span class="token operator">:=</span> <span class="token function">makeASCIISet</span><span class="token punctuation">(</span>cutset<span class="token punctuation">)</span><span class="token punctuation">;</span> isASCII <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span>
                        <span class="token keyword">return</span> r <span class="token operator">&lt;</span> utf8<span class="token punctuation">.</span>RuneSelf <span class="token operator">&amp;&amp;</span> as<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token function">byte</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>r <span class="token builtin">rune</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">IndexRune</span><span class="token punctuation">(</span>cutset<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们看到：就像<a href="http://c2.com/">沃德·坎宁安(Ward Cunningham)</a>对“一等公民”的诠释中所说的那样，Go 中的函数可以像普通整型值那样被创建和使用。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">除了上面那些例子，函数还可以被放入数组/切片/map 等结构中、可以像其他类型变量一样被赋值给 interface{}、甚至我们可以建立元素为函数的 channel，如下面例子：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_1.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> binaryCalcFunc <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">binaryCalcFunc</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span>
	c <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>
	fns <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>binaryCalcFunc<span class="token punctuation">{</span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y <span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">-</span> y <span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">*</span> y <span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">/</span> y <span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">%</span> y <span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	c <span class="token operator">&lt;-</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> x <span class="token operator">*</span> y
	<span class="token punctuation">}</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>fns<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	f <span class="token operator">:=</span> <span class="token operator">&lt;-</span>c
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span>binaryCalcFunc<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"type assertion error"</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">v</span><span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">和 C/C++这类语言相比，作为“一等公民”的 Go 函数拥有难得的"灵活性"。接下来我们需要考虑如何使用 Go 函数才能发挥出它作为“一等公民”的最大效用。</p>
</div><div class="cl-preview-section"><h2 id="函数作为“一等公民”的特殊运用" style="font-size: 30px;">2. 函数作为“一等公民”的特殊运用</h2>
</div><div class="cl-preview-section"><h3 id="像整型变量那样对函数进行显式转型">1). 像整型变量那样对函数进行显式转型</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Go 是类型安全的语言，Go 语言不允许隐式类型转换，因此下面的代码是无法通过编译的：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">var</span> b <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">6</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token comment">// 违法操作: a + b (不匹配的类型int和int32)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们必须通过对上面代码进行显式的转型才能通过编译器的检查：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span>
<span class="token keyword">var</span> b <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">6</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">+</span> <span class="token function">int</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// ok。输出11</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">函数是“一等公民”，对整型变量进行的操作也同样可以用在函数上面，即函数也可以被显式转型，并且这样的转型在特定的领域具有奇妙的作用。一个最为典型的示例就是 http.HandlerFunc 这个类型，我们来看一下例子：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_2.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
        <span class="token string">"fmt"</span>
        <span class="token string">"net/http"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">greeting</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token string">"Welcome, Gopher!\n"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>                    

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> http<span class="token punctuation">.</span><span class="token function">HandlerFunc</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上述代码是我们日常最为常见的一个用 Go 构建的 Web Server 的例子。其工作机制很简单，当用户通过浏览器或类似 curl 这样的命令行工具访问 Web server 的 8080 端口时，会收到“Welcome, Gopher!”一行文字版应答。很多 Gopher 可能并未真正深入分析过这段代码，这里用到的恰恰是函数作为“一等公民”的特性，我们来看一下。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们先来看一下 ListenAndServe 的源码：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/net/http/server.go</span>
<span class="token keyword">func</span> <span class="token function">ListenAndServe</span><span class="token punctuation">(</span>addr <span class="token builtin">string</span><span class="token punctuation">,</span> handler Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
        server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{</span>Addr<span class="token punctuation">:</span> addr<span class="token punctuation">,</span> Handler<span class="token punctuation">:</span> handler<span class="token punctuation">}</span>
        <span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">ListenAndServe 会将来自客户端的 http 请求交给其第二个参数 handler 处理，而这里 handler 参数的类型 http.Handler 接口：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/net/http/server.go</span>
<span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">{</span>
        <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">该接口仅有一个方法：ServeHTTP，其原型为：func(http.ResponseWriter, *http.Request)。这与我们自己定义的 http 请求处理函数 greeting 的原型是一致的。但是我们没法直接将 greeting 作为参数值传入，否则会报下面错误：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> does not implement http<span class="token punctuation">.</span><span class="token function">Handler</span> <span class="token punctuation">(</span>missing ServeHTTP method<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">即函数 greeting 并未实现接口 Handler 的方法，无法将其赋值给 Handler 类型的参数。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在代码中我们也并未直接将 greeting 传入 ListenAndServe，而是将 http.HandlerFunc(greeting)作为参数传给了 ListenAndServe。我们来看看 http.HandlerFunc 是什么？</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// $GOROOT/src/net/http/server.go</span>

<span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>Request<span class="token punctuation">)</span>

<span class="token comment">// ServeHTTP calls f(w, r).</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">HandlerFunc 其实就是一个基于函数定义的新类型，它的底层类型为 func(ResponseWriter, *Request)。该类型有一个方法 ServeHTTP，继而实现了 Handler 接口。也就是说 http.HandlerFunc(greeting)这句代码的真正含义是将函数 greeting 显式转换为 HandlerFunc 类型，后者实现了 Handler 接口，满足 ListenAndServe 函数第二个参数的要求。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">另外，之所以 http.HandlerFunc(greeting)这个语句可以通过编译器检查，正是因为 HandlerFunc 的底层类型正是 func(ResponseWriter, *Request)，与 greeting 的原型是一致的。这和下面整型变量的转型原理并无二致：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">type</span> MyInt <span class="token builtin">int</span>
<span class="token keyword">var</span> x <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span>
y <span class="token operator">:=</span> <span class="token function">MyInt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment">// MyInt的底层类型为int，类比 HandlerFunc的底层类型为func(ResponseWriter, *Request)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">为了充分理解这种显式转型的“技巧”，我们再来看一个简化后的例子：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_3.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">type</span> BinaryAdder <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Add</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> MyAdderFunc <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>f MyAdderFunc<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">MyAdd</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> x <span class="token operator">+</span> y
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> i BinaryAdder <span class="token operator">=</span> <span class="token function">MyAdderFunc</span><span class="token punctuation">(</span>MyAdd<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">和 Web server 那个例子一样，我们想将 MyAdd 这个函数赋值给 BinaryAdder 这个接口，直接赋值是不行的，我们需要一个底层函数类型与 MyAdd 一致的自定义类型的显式转换，这个自定义类型就是 MyAdderFunc，该类型实现了 BinaryAdder 接口，这样在经过 MyAdderFunc 的显式转型后，MyAdd 被赋值给了 BinaryAdder 的变量 i。这样通过 i 调用的 Add 方法实质上就是我们的 MyAdd 函数。</p>
</div><div class="cl-preview-section"><h3 id="函数式编程">2) 函数式编程</h3>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Go 语言演进到如今，对多种编程范式或多或少都有支持。比如：对函数式编程的支持就得意于函数是“一等公民”的特质。虽然 Go 不推崇函数式编程，但有些时候应用一些函数式编程风格可以写出更加优雅、更简洁、更易维护的代码。</p>
</div><div class="cl-preview-section"><h4 id="柯里化函数" style="font-size: 26px;">柯里化函数</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们先来看一种函数式编程的典型应用：柯里化函数(currying)。在计算机科学中，柯里化是把接受多个参数的函数变换成接受一个单一参数(原函数的第一个参数)的函数，并且返回接受余下的参数和返回结果的新函数的技术。这个技术以逻辑学家 Haskell Curry 命名。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">定义总是拗口难懂，我们来用 Go 编写一个直观的柯里化函数的例子：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_4.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">times</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> x <span class="token operator">*</span> y
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">partialTimes</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">times</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	timesTwo <span class="token operator">:=</span> <span class="token function">partialTimes</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
	timesThree <span class="token operator">:=</span> <span class="token function">partialTimes</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
	timesFour <span class="token operator">:=</span> <span class="token function">partialTimes</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">timesTwo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">timesThree</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">timesFour</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">运行这个例子：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go">$ <span class="token keyword">go</span> run function_as_first_class_citizen_4<span class="token punctuation">.</span><span class="token keyword">go</span>
<span class="token number">10</span>
<span class="token number">15</span>
<span class="token number">20</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里的柯里化是指将原接受两个参数的函数 times 转换为接受一个参数的 partialTimes 的过程。通过 partialTimes 函数构造的 timesTwo 将输入参数扩大为原先 2 倍、timesThree 将输入参数扩大为原先的 3 倍…。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这个例子利用了函数的几点性质：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">在函数中定义，通过返回值返回</li>
<li style="font-size: 20px; line-height: 38px;">闭包</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">闭包是前面没有提到的 Go 函数支持的一个特性。 闭包是在函数内部定义的匿名函数，并且允许该匿名函数访问定义它的外部函数的作用域。本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">以上述示例来说，partialTimes 内部定义的匿名函数就是一个闭包，该匿名函数访问了其外部函数(partialTimes)的变量 x。这样当调用 partialTimes(2)时，partialTimes 实际上返回一个调用 times(2,y)的函数：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go">timesTwo <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token function">times</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><h4 id="函子functor" style="font-size: 26px;">函子(Functor)</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">函数式编程范式最让人”望而却步“的就是首先要了解一些抽象概念，比如上面的柯里化，再比如这里的函子(Functor)。什么是函子呢？具体来说，成为函子需要两个条件：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">函子本身是一个容器类型，以 Go 语言为例，这个容器可以是切片、map 甚至是 channel；</li>
<li style="font-size: 20px; line-height: 38px;">光是容器还不够，该容器类型还需要实现一个方法，该方法接受一个函数类型参数，并在容器的每个元素上应用那个函数，得到一个新的函子，原函子容器内部的元素值不受到影响</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们还是用一个具体的示例来直观看一下吧：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_5.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> IntSliceFunctor <span class="token keyword">interface</span> <span class="token punctuation">{</span>
	<span class="token function">Fmap</span><span class="token punctuation">(</span>fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">)</span> IntSliceFunctor
<span class="token punctuation">}</span>

<span class="token keyword">type</span> intSliceFunctorImpl <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	ints <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>isf intSliceFunctorImpl<span class="token punctuation">)</span> <span class="token function">Fmap</span><span class="token punctuation">(</span>fn <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">)</span> IntSliceFunctor <span class="token punctuation">{</span>
	newInts <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>isf<span class="token punctuation">.</span>ints<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span> elt <span class="token operator">:=</span> <span class="token keyword">range</span> isf<span class="token punctuation">.</span>ints <span class="token punctuation">{</span>
		retInt <span class="token operator">:=</span> <span class="token function">fn</span><span class="token punctuation">(</span>elt<span class="token punctuation">)</span>
		newInts<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> retInt
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> intSliceFunctorImpl<span class="token punctuation">{</span>ints<span class="token punctuation">:</span> newInts<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">NewIntSliceFunctor</span><span class="token punctuation">(</span>slice <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> IntSliceFunctor <span class="token punctuation">{</span>
	<span class="token keyword">return</span> intSliceFunctorImpl<span class="token punctuation">{</span>ints<span class="token punctuation">:</span> slice<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 原切片</span>
	intSlice <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"init a functor from int slice: %#v\n"</span><span class="token punctuation">,</span> intSlice<span class="token punctuation">)</span>
	f <span class="token operator">:=</span> <span class="token function">NewIntSliceFunctor</span><span class="token punctuation">(</span>intSlice<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"original functor: %+v\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span>

	mapperFunc1 <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> i <span class="token operator">+</span> <span class="token number">10</span>
	<span class="token punctuation">}</span>

	mapped1 <span class="token operator">:=</span> f<span class="token punctuation">.</span><span class="token function">Fmap</span><span class="token punctuation">(</span>mapperFunc1<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"mapped functor1: %+v\n"</span><span class="token punctuation">,</span> mapped1<span class="token punctuation">)</span>

	mapperFunc2 <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">3</span>
	<span class="token punctuation">}</span>
	mapped2 <span class="token operator">:=</span> mapped1<span class="token punctuation">.</span><span class="token function">Fmap</span><span class="token punctuation">(</span>mapperFunc2<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"mapped functor2: %+v\n"</span><span class="token punctuation">,</span> mapped2<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"original functor: %+v\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token comment">// 原functor没有改变</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"composite functor: %+v\n"</span><span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">Fmap</span><span class="token punctuation">(</span>mapperFunc1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Fmap</span><span class="token punctuation">(</span>mapperFunc2<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">运行这段代码：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go">$ <span class="token keyword">go</span> run function_as_first_class_citizen_5<span class="token punctuation">.</span><span class="token keyword">go</span>
init a functor from <span class="token builtin">int</span> slice<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span>
original functor<span class="token punctuation">:</span> <span class="token punctuation">{</span>ints<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
mapped functor1<span class="token punctuation">:</span> <span class="token punctuation">{</span>ints<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">11</span> <span class="token number">12</span> <span class="token number">13</span> <span class="token number">14</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
mapped functor2<span class="token punctuation">:</span> <span class="token punctuation">{</span>ints<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">33</span> <span class="token number">36</span> <span class="token number">39</span> <span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
original functor<span class="token punctuation">:</span> <span class="token punctuation">{</span>ints<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
composite functor<span class="token punctuation">:</span> <span class="token punctuation">{</span>ints<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">33</span> <span class="token number">36</span> <span class="token number">39</span> <span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">}</span>

</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">分析这段代码：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">这里我们定义了一个 intSliceFunctorImpl 类型，用来作为 functor 的载体；</li>
<li style="font-size: 20px; line-height: 38px;">我们把 functor 要实现的方法命名为 Fmap，intSliceFunctorImpl 类型实现了该方法。同时该方法也是 IntSliceFunctor 接口的唯一方法；可以看到在这个代码中真正的 functor 其实是 IntSliceFunctor，这符合 Go 的惯用法；</li>
<li style="font-size: 20px; line-height: 38px;">我们定义了创建 IntSliceFunctor 的函数：NewIntSliceFunctor。通过该函数以及一个初始切片，我们可以实例化一个 functor；</li>
<li style="font-size: 20px; line-height: 38px;">我们在 main 中定义了两个转换函数，并将这两个函数应用到上述 functor 实例；我们看到得到的新 functor 的内部容器元素值是在原容器的元素值经由转换函数转换后得到的；</li>
<li style="font-size: 20px; line-height: 38px;">在最后，我们还可以对最初的 functor 实例连续(组合)应用转换函数，这让我们想到了数学课程中的函数组合；</li>
<li style="font-size: 20px; line-height: 38px;">无论如何应用转换函数，原 functor 中容器内的元素值不受到影响。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">functor 非常适合对容器集合元素做批量同构处理，而且代码也要比每次都对容器中的元素作循环处理要优雅简洁许多。但要想在 Go 中发挥 functor 的最大效能，还需要 Go 对泛型提供支持，否则我们就需要为每一种容器类型都实现一套对应的 Functor 机制。比如上面的示例仅支持元素类型为 int 的切片，如果元素类型换为 string 或元素类型依然为 int，但容器类型换为 map，我们还需要分别为之编写新的配套代码。</p>
</div><div class="cl-preview-section"><h4 id="延续传递式continuation-passing-style" style="font-size: 26px;">延续传递式(Continuation-passing Style)</h4>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">函数式编程离不开递归，以求阶乘函数为例，我们可以轻易用递归方法写出一个实现：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_6.go</span>
<span class="token keyword">func</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这是一个非常常规的求阶乘的实现思路，但是这种思路并未应用到函数作为”一等公民“的任何特质。函数式编程有一种被称为延续传递式(Continuation-passing Style，以下简称为 CPS）的编程风格可以充分运用函数作为”一等公民“的特质。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在 CPS 风格中，函数是不允许有返回值的。一个函数 A 应该将其想返回的值显式传给一个 continuation 函数(一般接受一个参数)，而这个 continuation 函数自身是函数 A 的一个参数。概念太过抽象，我们用一个简单的例子来说明一下：</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面得 Max 函数的功能是返回两个参数值中较大的那个值：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_7.go</span>
<span class="token keyword">package</span> main
  
<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">Max</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> m <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> n <span class="token operator">&gt;</span> m <span class="token punctuation">{</span>
                <span class="token keyword">return</span> n
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> m
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们把 Max 函数看作是上面定义中的 A 函数在未 CPS 化之前的状态。接下来，我们来根据 CPS 的定义将其转换为 CPS 风格：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">首先我们去掉 Max 函数的返回值，并为其添加一个函数类型的参数 f(这个 f 就是定义中的 continuation 函数)</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token function">Max</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> m <span class="token builtin">int</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">将返回结果传给 continuation 函数，即把 return 语句替换为对 f 函数的调用</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token function">Max</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> m <span class="token builtin">int</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> n <span class="token operator">&gt;</span> m <span class="token punctuation">{</span>
                <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token function">f</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">完整的转换后的代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_8.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">Max</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> m <span class="token builtin">int</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token keyword">if</span> n <span class="token operator">&gt;</span> m <span class="token punctuation">{</span> 
                <span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> 
                <span class="token function">f</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> 

<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
        <span class="token function">Max</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">接下来，我们使用同样的方法将上面的阶乘实现转换为 CPS 风格。</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">首先我们去掉 factorial 函数的返回值，并为其添加一个函数类型的参数 f(这个 f 也就是 CPS 定义中的 continuation 函数)</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">接下来，将 factorial 实现中的返回结果传给 continuation 函数，即把 return 语句替换为对 f 函数的调用</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token function">f</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">*</span> y<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于原 else 分支有递归，因此我们需要把未完成的计算过程封装为一个新的函数 f’作为 factorial 递归调用的第二个参数，f’的参数 y 即为原 factorial(n-1)的计算结果，而 n * y 是要传递给 f 的，于是 f’这个函数的定义就为：func(y int) { f(n * y) }。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">转换为 CPS 风格的阶乘函数的完整代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// function_as_first_class_citizen_9.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
		<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">//基本情况</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
		<span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f</span><span class="token punctuation">(</span>n <span class="token operator">*</span> y<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们简单解析一下上述实例代码的执行过程(下面用伪代码阐释)：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go">f1 <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"%v\n"</span><span class="token punctuation">,</span> y<span class="token punctuation">)</span> 
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> f1<span class="token punctuation">)</span>

f2 <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> f2<span class="token punctuation">)</span>

f3 <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> f3<span class="token punctuation">)</span>

f4 <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">f3</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> f4<span class="token punctuation">)</span>

f5 <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">f4</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> y<span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> f5<span class="token punctuation">)</span>

<span class="token function">f5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>

<span class="token operator">=</span><span class="token operator">&gt;</span> 

<span class="token function">f5</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token operator">=</span> <span class="token function">f4</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">=</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">=</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token number">4</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token operator">=</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">)</span> 
<span class="token operator">=</span> <span class="token number">120</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">读到这里很多朋友会提出心中的疑问：这种 CPS 风格虽然利用了函数作为”一等公民“的特质，但是其代码理解起来颇为困难，这种风格真的好吗？朋友们的担心是有道理的。这里对 CPS 风格的讲解其实是一个”反例“，目的就是告诉大家，尽管作为”一等公民“的函数给 Go 带来的强大的表达能力，但是如果选择了不适合的风格或者说为了函数式而进行函数式编程，那么就会出现代码难于理解，且代码执行效率不高的情况（CPS 需要语言支持尾递归优化，但 Go 目前并不支持)。</p>
</div><div class="cl-preview-section"><h2 id="小结" style="font-size: 30px;">3. 小结</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">成为”一等公民“的函数极大增强了 Go 语言的表现力，我们可以像对待值变量那样对待函数，上述函数编程思想的运用就得益于此。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">让自己习惯于函数是”一等公民“，请牢记本节要点：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">Go 函数可以像变量值那样被赋值给变量、作为参数传递、作为返回值返回和在函数内部创建等；</li>
<li style="font-size: 20px; line-height: 38px;">函数可以像变量那样被显式转型；</li>
<li style="font-size: 20px; line-height: 38px;">基于函数特质，了解 Go 中的几种有用的函数式编程风格：柯里化、函子；</li>
<li style="font-size: 20px; line-height: 38px;">不要为了符合特定风格而滥用函数特质。</li>
</ul>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/87/article/2419">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            17 init 函数的妙用
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/87/article/2421">
                                                                    <div class="next r clearfix">
                                        <p>
                                            19 defer 让你的代码更清晰
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img4.sycdn.imooc.com/5f51ecec0001392b05330597.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课前沿技术核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">2010312025386365</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：729941811</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=5WJLMxV" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>