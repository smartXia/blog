<html><head><meta charset="utf-8"><title>20 Go 方法的本质-慕课专栏</title>
			<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
			<meta name="renderer" content="webkit">
			<meta property="qc:admins" content="77103107776157736375">
			<meta property="wb:webmaster" content="c4f857219bfae3cb">
			<meta http-equiv="Access-Control-Allow-Origin" content="*">
			<meta http-equiv="Cache-Control" content="no-transform ">
			<meta http-equiv="Cache-Control" content="no-siteapp">
			<link rel="apple-touch-icon" sizes="76x76" href="https://www.imooc.com/static/img/common/touch-icon-ipad.png">
			<link rel="apple-touch-icon" sizes="120x120" href="https://www.imooc.com/static/img/common/touch-icon-iphone-retina.png">
			<link rel="apple-touch-icon" sizes="152x152" href="https://www.imooc.com/static/img/common/touch-icon-ipad-retina.png">
			<link href="https://moco.imooc.com/captcha/style/captcha.min.css" rel="stylesheet">
			<link rel="stylesheet" href="https://www.imooc.com/static/moco/v1.0/dist/css/moco.min.css?t=201907021539" type="text/css">
			<link rel="stylesheet" href="https://www.imooc.com/static/lib/swiper/swiper-3.4.2.min.css?t=201907021539">
			<link rel="stylesheet" href="https://static.mukewang.com/static/css/??base.css,common/common-less.css?t=2.5,column/zhuanlanChapter-less.css?t=2.5,course/inc/course_tipoff-less.css?t=2.5?v=201907051055" type="text/css">
			<link charset="utf-8" rel="stylesheet" href="https://www.imooc.com/static/lib/ueditor/themes/imooc/css/ueditor.css?v=201907021539"><link rel="stylesheet" href="https://www.imooc.com/static/lib/baiduShare/api/css/share_style0_16.css?v=6aba13f0.css"></head>
			<body><div id="main">


<div class="main-con hide-menu">
    <!-- 左侧菜单 & 索引 -->
    
    <div class="right-content" style="padding-left: 0px;">
        <div class="container clearfix" id="top" style="width: 1134px; display: block;">
            
            
            <div class="center_con js-center_con l" style="width: 1134px;">
                <div class="article-con">
                                            <!-- 买过的阅读 -->
                        

                    
                    <div class="art-title" style="margin-top: 0px;">
                        20 Go 方法的本质
                    </div>
                    <div class="art-info clearfix">
                        
                        <span class="l">
                            更新时间：2020-10-28 09:38:45
                        </span>
                    </div>
                    <div class="art-top">
                                                <img src="https://img3.sycdn.imooc.com/5f924d0c0001b99b06400427.jpg" alt="">
                                                                        <div class="famous-word-box">
                            <img src="https://www.imooc.com/static/img/column/bg-l.png" alt="" class="bg1 bg">
                            <img src="https://www.imooc.com/static/img/column/bg-r.png" alt="" class="bg2 bg">
                            <div class="famous-word">我好像是一只牛，吃的是草，挤出的是牛奶。——鲁迅<p></p></div>
                        </div>
                                            </div>
                    <div class="art-content js-lookimg">
                        <div id="article_content">
                            <div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Go 语言不支持经典的面向对象语法元素，比如：类、对象、继承等。但 Go 语言也有方法（method）。和函数相比，Go 语言中的方法在声明形式上仅仅多了一个参数，Go 称之为 receiver 参数。而 receiver 参数正是方法与类型之间的纽带。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Go 方法的一般声明形式如下：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>receiver T<span class="token comment">/*T) MethodName(参数列表) (返回值列表) {
	// 方法体
}
</span></code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">上面方法声明中的 T 称为 receiver 的基类型。通过 receiver，上述方法被绑定到类型 T 上。换句话说：上述方法是类型 T 的一个方法，我们可以通过类型 T 或*T 的实例调用该方法。</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">var</span> t T
t<span class="token punctuation">.</span><span class="token function">MethodName</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span>

<span class="token keyword">var</span> pt <span class="token operator">*</span>T <span class="token operator">=</span> <span class="token operator">&amp;</span>t
pt<span class="token punctuation">.</span><span class="token function">MethodName</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Go 方法具有如下特点：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">方法名的首字母是否大写决定了该方法是否是导出方法 ；</li>
<li style="font-size: 20px; line-height: 38px;">方法定义要与类型定义放在同一个包内。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">由于方法定义与类型定义必须放在同一个包下面，因此我们可以推论得到：我们不能为原生类型（诸如：int、float64、map 等）添加方法, 只能为自定义类型定义方法。</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go">错误的作法：
<span class="token keyword">func</span> <span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span> <span class="token comment">// cannot define new methods on non-local type int</span>
        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> 
<span class="token punctuation">}</span>

vs<span class="token punctuation">.</span>

正确的作法：
<span class="token keyword">type</span> MyInt <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i MyInt<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">int</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">同理，我们也可以推论得出：我们也不能横跨 Go 包为其他包内的自定义类型定义方法。</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">每个方法只能有一个 receiver 参数，不支持多 receiver 参数列表或变长 receiver 参数。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">一个方法只能绑定一个基类型，Go 语言不支持同时绑定多个类型的方法。</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">receiver 参数的基类型本身不能是指针类型或接口类型。</li>
</ul>
</div><div class="cl-preview-section"><pre class="  language-plain"><code class="prism  language-plain">type MyInt *int
func (r MyInt) String() string { // invalid receiver type MyInt (MyInt is a pointer type)
	return fmt.Sprintf("%d", *(*int)(r))
}

type MyReader io.Reader
func (r MyReader) Read(p []byte) (int, error) { // invalid receiver type MyReader (MyReader is an interface type)
	return r.Read(p)
}
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">和其他主流编程语言相比，Go 语言从函数到方法仅仅多出了一个 receiver，这大大降低了 Gopher 们学习方法的门槛。但即便如此，Gopher 们在把握方法本质以及如何选择 receiver 的类型时仍存在困惑，本节我就针对这些困惑做重点的说明。</p>
</div><div class="cl-preview-section"><h2 id="方法的本质" style="font-size: 30px;">1. 方法的本质</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">前面提到过：Go 语言没有类，方法与类型通过 receiver 联系在一起，我们可以为任何非内置原生类型定义方法，比如下面的类型 T：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">{</span> 
        a <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t T<span class="token punctuation">)</span> <span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> t<span class="token punctuation">.</span>a 
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">Set</span><span class="token punctuation">(</span>a <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> 
        t<span class="token punctuation">.</span>a <span class="token operator">=</span> a 
        <span class="token keyword">return</span> t<span class="token punctuation">.</span>a 
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">C++的对象在调用方法时，编译器会自动传入指向对象自身的 this 指针作为方法的第一个参数。而对于 Go 来说，receiver 其实也是同样道理，我们将 receiver 作为第一个参数传入方法的参数列表，上面示例中的类型 T 的方法就可以等价转换为下面的普通函数：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token function">Get</span><span class="token punctuation">(</span>t T<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>  
        <span class="token keyword">return</span> t<span class="token punctuation">.</span>a 
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">Set</span><span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">,</span> a <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span> 
        t<span class="token punctuation">.</span>a <span class="token operator">=</span> a 
        <span class="token keyword">return</span> t<span class="token punctuation">.</span>a 
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这种转换后的函数就是方法的原型。只不过在 Go 语言中，这种等价转换是由 Go 编译器在编译和生成代码时自动完成的。Go 语言规范中提供了<strong>方法表达式(method expression)</strong> 的概念，可以让我们更充分地理解上面的等价转换。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Go 方法的一般使用方式如下：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">var</span> t T
t<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
t<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们可以将上面方法调用用下面的方式做等价替换：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">var</span> t T
T<span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这种直接以类型名 T 调用方法 M 的表达方式被称为<strong>Method Expression</strong>。类型 T 只能调用 T 的方法集合(Method Set)中的方法；同理*T 只能调用*T 的方法集合中的方法（关于方法集合，我们会在下一节中详细讲解）。我们看到：<strong>Method Expression</strong>有些类似于 C++中的 static 方法，static 方法在使用时以该 C++类的某个对象实例作为第一个参数，而 Go 语言的 Method Expression 在使用时，同样以 receiver 参数所代表的实例作为第一个参数。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这种通过 Method Expression 对方法进行调用的方式与我们之前所做的方法到函数的等价转换是如出一辙的。这就是<strong>Go 方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数</strong>。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">Method Expression 体现了 Go 方法的本质：其自身的类型就是一个普通函数。我们甚至可以将其作为右值赋值给一个函数类型的变量：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">var</span> t T
f1 <span class="token operator">:=</span> <span class="token punctuation">(</span><span class="token operator">*</span>T<span class="token punctuation">)</span><span class="token punctuation">.</span>Set <span class="token comment">// f1的类型，也是T类型Set方法的原型：func (t *T, int)int</span>
f2 <span class="token operator">:=</span> T<span class="token punctuation">.</span>Get <span class="token comment">// f2的类型，也是T类型Get方法的原型：func(t T)int</span>
<span class="token function">f1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>t<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f2</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><h2 id="正确选择-receiver-类型" style="font-size: 30px;">2. 正确选择 receiver 类型</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">有了上面对 Go 方法本质的分析，我们再来理解 receiver 并在定义方法时选择正确的 receiver 类型就简单多了。我们再来看一下方法和函数的”等价变换公式“：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>t T<span class="token punctuation">)</span> <span class="token function">M1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span><span class="token operator">&gt;</span> <span class="token function">M1</span><span class="token punctuation">(</span>t T<span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">M2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span><span class="token operator">&gt;</span> <span class="token function">M2</span><span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们看到：M1 方法的 receiver 参数类型为 T，而 M2 方法的 receiver 参数类型为*T。</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">当 receiver 参数的类型为 T 时，即选择值类型的 receiver。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们选择以 T 作为 receiver 参数类型时，T 的 M1 方法等价为 M1(t T)。我们知道 Go 函数的参数采用的是值拷贝传递，也就是说 M1 函数体中的 t 是 T 类型实例的一个副本，这样 M1 函数的实现中无论对参数 t 做任何修改都只会影响副本，而不会影响到原 T 类型实例。</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">当 receiver 参数的类型为 *T 时，即选择指针类型的 receiver。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们选择以*T 作为 receiver 参数类型时，T 的 M2 方法等价为 M2(t *T)。我们传递给 M2 函数的 t 是 T 类型实例的地址，这样 M2 函数体中对参数 t 做的任何修改都会反映到原 T 类型实例。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">我们以下面的例子演示一下选择不同的 receiver 类型对原类型实例的影响：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// method_nature_1.go </span>
<span class="token keyword">package</span> main

<span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	a <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t T<span class="token punctuation">)</span> <span class="token function">M1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	t<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">M2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	t<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">11</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> t T <span class="token comment">// t.a = 0</span>
	<span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">)</span>

	t<span class="token punctuation">.</span><span class="token function">M1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">)</span>

	t<span class="token punctuation">.</span><span class="token function">M2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">运行该程序：</p>
</div><div class="cl-preview-section"><pre class="  language-plain"><code class="prism  language-plain">$ go run method_nature_1.go 
0
0
11
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在该示例中，M1 和 M2 方法体内都对字段 a 做了修改，但 M1（采用值类型 receiver）修改的只是实例的副本，对原实例并没有影响，因此 M1 调用后，输出 t.a 的值仍为 0；M2（采用指针类型 receiver）修改的是实例本身，因此 M2 调用后，t.a 的值变为了 11。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">很多 Go 初学者还有这样的疑惑：是不是 T 类型实例只能调用 receiver 为 T 类型的方法，不能调用 receiver 为*T 类型的方法呢？答案是否定的。无论是 T 类型实例，还是*T 类型实例，都既可以调用 receiver 为 T 类型的方法，也可以调用 receiver 为*T 类型的方法。下面例子证明了这一点：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// method_nature_2.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">type</span> T <span class="token keyword">struct</span> <span class="token punctuation">{</span>
	a <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t T<span class="token punctuation">)</span> <span class="token function">M1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>T<span class="token punctuation">)</span> <span class="token function">M2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	t<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">11</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">var</span> t T
	t<span class="token punctuation">.</span><span class="token function">M1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>
	t<span class="token punctuation">.</span><span class="token function">M2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;=&gt; (&amp;t).M2()</span>

	<span class="token keyword">var</span> pt <span class="token operator">=</span> <span class="token operator">&amp;</span>T<span class="token punctuation">{</span><span class="token punctuation">}</span>
	pt<span class="token punctuation">.</span><span class="token function">M1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// &lt;=&gt; (*pt).M1()</span>
	pt<span class="token punctuation">.</span><span class="token function">M2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// ok</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">通过例子我们看到 T 类型实例 t 调用 receiver 类型为*T 的 M2 方法是没问题的，同样*T 类型实例 pt 调用 receiver 类型为 T 的 M1 方法也是可以的。实际上这都是 <strong>Go 语法甜头(syntactic sugar)</strong>，即 Go 编译器在编译和生成代码时为我们自动做的转换。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">到这里，我们可以得出 receiver 类型选用的初步结论：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">如果要对类型实例进行修改，那么为 receiver 选择*T 类型；</li>
<li style="font-size: 20px; line-height: 38px;">如果没有对类型实例修改的需求，那么为 receiver 选择 T 类型或*T 类型均可；但考虑到 Go 方法调用时，receiver 是以值拷贝的形式传入方法中的。如果类型 size 较大，以值形式传入会导致较大损耗，这时选择*T 作为 receiver 类型可能更好些。</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">对于 receiver 的类型的选择其实还有一个重要因素，那就是类型是否要实现某个 interface，这个考量因素在下一节中将有详细说明。</p>
</div><div class="cl-preview-section"><h2 id="利用对-go-方法本质的理解巧解难题" style="font-size: 30px;">3. 利用对 Go 方法本质的理解巧解难题</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">下面的这个例子来自于<a href="https://tonybai.com">笔者博客</a>的一次真实的读者咨询，他的问题代码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// method_nature_3.go</span>
<span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
    <span class="token string">"fmt"</span>
    <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> field <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>field<span class="token punctuation">)</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    data1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>field<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"two"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"three"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> data1 <span class="token punctuation">{</span>
        <span class="token keyword">go</span> v<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    data2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>field<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"four"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"five"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"six"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> data2 <span class="token punctuation">{</span>
        <span class="token keyword">go</span> v<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">该示例在我的多核 MacOS 上运行结果如下（由于 goroutine 调度顺序不同，结果可能与下面的有差异）：</p>
</div><div class="cl-preview-section"><pre class="  language-plain"><code class="prism  language-plain">$ go run method_nature_3.go
one
two
three
six
six
six
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这位读者的问题显然是：<strong>为什么对 data2 迭代输出的结果是三个"six"，而不是 four、five、six？</strong></p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">好了，我们来分析一下。首先，我们根据<strong>Go 方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数</strong>，对这个程序做个<strong>等价变换</strong>(这里我们利用 Method Expression)，变换后的源码如下：</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// method_nature_4.go</span>
<span class="token keyword">package</span> main
  
<span class="token keyword">import</span> <span class="token punctuation">(</span>
        <span class="token string">"fmt"</span>
        <span class="token string">"time"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> field <span class="token keyword">struct</span> <span class="token punctuation">{</span>
        name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p <span class="token operator">*</span>field<span class="token punctuation">)</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        data1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>field<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"one"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"two"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"three"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> data1 <span class="token punctuation">{</span>
                <span class="token keyword">go</span> <span class="token punctuation">(</span><span class="token operator">*</span>field<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        data2 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>field<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token string">"four"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"five"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"six"</span><span class="token punctuation">}</span><span class="token punctuation">}</span>
        <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> data2 <span class="token punctuation">{</span>
                <span class="token keyword">go</span> <span class="token punctuation">(</span><span class="token operator">*</span>field<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>v<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>

        time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这里我们把对 field 的方法 print 的调用替换为 Method Expression 形式，替换前后的程序输出结果是一致的。但变换后，问题是不是豁然开朗了，我们可以很清楚地看到使用 go 关键字启动一个新 goroutine 时是如何绑定参数的：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">迭代 data1 时，由于 data1 中的元素类型是 field 指针(*field)，因此赋值后 v 就是元素地址，每次调用 print 时传入的参数(v)实际上也是各个 field 元素的地址；</li>
<li style="font-size: 20px; line-height: 38px;">迭代 data2 时，由于 data2 中的元素类型是 field（非指针），需要将其取地址后再传入。这样每次传入的&amp;v 实际上是变量 v 的地址，而不是切片 data2 中各元素的地址；</li>
</ul>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">在第 20 节 ”了解 Go 语言控制语句惯用法及使用注意事项"一节中，我们了解过 for range 使用时应注意的几个问题，其中循环变量复用是关键的一个。这里的 v 在整个 for range 过程中只有一个，因此 data2 迭代完成之后，<strong>v 是元素"six"的拷贝</strong>。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">这样，一旦启动的各个子 goroutine 在 main goroutine 执行到 Sleep 时才被调度执行，那么最后的三个 goroutine 在打印&amp;v 时，打印的也就都 v 中存放的值"six"了。而前三个子 goroutine 各自传入的是元素"one"、“two"和"three"的地址，打印的就是"one”、"two"和"three"了。</p>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">那么原程序如何修改一下才能让其按期望输出（“one”、“two”、“three”, “four”, “five”, “six”）呢？其实只需将 field 类型 print 方法的 receiver 类型由*field 改为 field 即可。</p>
</div><div class="cl-preview-section"><pre class="  language-go"><code class="prism  language-go"><span class="token comment">// method_nature_5.go</span>

<span class="token operator">...</span> <span class="token operator">...</span>

<span class="token keyword">type</span> field <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    name <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p field<span class="token punctuation">)</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token operator">...</span> <span class="token operator">...</span>
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">修改后的程序的输出结果为（因 goroutine 调度顺序不同，在你的机器上的结果输出顺序与这里可能会有不同）：</p>
</div><div class="cl-preview-section"><pre class="  language-plain"><code class="prism  language-plain">one
two
three
four
five
six
</code></pre>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">至于其中的原因，大家可以参考我的分析思路自行分析一下(可参考本节文章配套源码：method_nature_6.go。</p>
</div><div class="cl-preview-section"><h2 id="小结" style="font-size: 30px;">4. 小结</h2>
</div><div class="cl-preview-section"><p style="font-size: 20px; line-height: 38px;">本节要点：</p>
</div><div class="cl-preview-section"><ul>
<li style="font-size: 20px; line-height: 38px;">Go 方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数；</li>
<li style="font-size: 20px; line-height: 38px;">Go 语法甜头使得我们通过类型实例调用类型方法时无需考虑实例类型与 receiver 参数类型是否一致，编译器会为我们做自动转换；</li>
<li style="font-size: 20px; line-height: 38px;">receiver 参数类型选择时要看是否要对类型实例进行修改；如有修改需求，则选择*T；如无修改需求，T 类型 receiver 传值的性能损耗也是考量因素之一。</li>
</ul>
</div>}
                        </div>
                    </div>
                                            <!-- 买过的阅读 -->
                        <div class="art-next-prev clearfix">
                                                                                                <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/87/article/2421">
                                                                    <div class="prev l clearfix">
                                        <div class="icon l">
                                            <i class="imv2-arrow3_l"></i>
                                        </div>
                                        <p>
                                            19 defer 让你的代码更清晰
                                        </p>
                                    </div>
                                </a>
                                                                                                                            <!-- 已买且开放 或者可以试读 -->
                                    <a href="/read/87/article/2423">
                                                                    <div class="next r clearfix">
                                        <p>
                                            21 方法集合决定接口实现
                                        </p>
                                        <div class="icon r">
                                            <i class="imv2-arrow3_r"></i>
                                        </div>

                                    </div>
                                </a>
                                                    </div>
                                    </div>
                <div class="comments-con js-comments-con" id="coments_con">
                </div>

                
            </div>
            
            
            

        </div>
    </div>
</div>

<div class="modal modal-jiaQun-new hide" id="modal-jiaQun">
    <div class="inner" style="">
        <div class="modal-close js-close-jiaQun">
            <i class="imv2-close"></i>
        </div>
        <div class="content">
            <img src="https://img2.sycdn.imooc.com/5f51ecec0001392b05330597.jpg">
            <div class="right-info">
                <div class="title">
                    扫码加入慕课前沿技术核心用户群
                </div>
                <div class="desc">
                                            <p class="mb6">验证信息：<span id="joincode">2010312025386365</span><span class="copy js-copy-joincode">复制</span></p>
                                        <p class="mb6">QQ讨论群号：729941811</p>
                                            <p>QQ群URL：<a href="https://jq.qq.com/?_wv=1027&amp;k=5WJLMxV" target="_blank">点击访问</a></p>
                                    </div>
            </div>
            <p class="tip">若遇到搜索不到QQ群或加群失败，请联系客服邮箱:kf@imooc.com</p>
        </div>
    </div>
</div>
 
<!-- 专栏介绍页专栏评价 -->

<!-- 专栏介绍页底部三条评价 -->

<!-- 专栏阅读页弹层目录和介绍页页面目录 -->

<!-- 专栏阅读页发布回复 -->

<!-- 专栏阅读页发布评论 -->

<!-- 专栏阅读页底部评论 -->

<!-- 专栏阅读 单个 评论 -->

<!-- 新增回复和展开三条以外回复 -->

<!-- 立即订阅的弹窗 -->












</div></body></html>