<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Go并发编程总结 | Some</title><meta name="keywords" content="log,dayliy"><meta name="author" content="夏夏天,xiapeifu@gmail.com"><meta name="copyright" content="夏夏天"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Golang :不要通过共享内存来通信，而应该\通过通信来共享内存**。这句风靡在Go社区的话,说的就是 goroutine中的 channel。他在go并发编程中充当着类型安全的管道作用。 1、通过golang中的 goroutine 与sync.Mutex进行 并发同步1234567891011121314151617181920212223242526272829303132333435pa">
<meta property="og:type" content="article">
<meta property="og:title" content="Go并发编程总结">
<meta property="og:url" content="https://smartxia.github.io/blog/2020/06/09/GOLANG/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Some">
<meta property="og:description" content="Golang :不要通过共享内存来通信，而应该\通过通信来共享内存**。这句风靡在Go社区的话,说的就是 goroutine中的 channel。他在go并发编程中充当着类型安全的管道作用。 1、通过golang中的 goroutine 与sync.Mutex进行 并发同步1234567891011121314151617181920212223242526272829303132333435pa">
<meta property="og:locale">
<meta property="og:image" content="https://smartxia.github.io/blog/img/golang.jpeg">
<meta property="article:published_time" content="2020-06-09T09:36:01.000Z">
<meta property="article:modified_time" content="2021-11-16T10:01:25.929Z">
<meta property="article:author" content="夏夏天">
<meta property="article:tag" content="log,dayliy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://smartxia.github.io/blog/img/golang.jpeg"><link rel="shortcut icon" href="/blog/img/favicon.png"><link rel="canonical" href="https://smartxia.github.io/blog/2020/06/09/GOLANG/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/blog/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/blog/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: 夏夏天","link":"Link: ","source":"Source: Some","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go并发编程总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-16 18:01:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/blog/atom.xml" title="Some" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://s2-cdn.oneitfarm.com/e12ece12233b4059860acf48637d830a.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/blog/archives/"><div class="headline">Articles</div><div class="length-num">69</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/tags/"><div class="headline">Tags</div><div class="length-num">48</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/blog/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="//tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li><li><a class="site-page child" href="/blog/photos/"><i class="fa-fw fas fa-picture"></i><span> Photo</span></a></li><li><a class="site-page child" href="/blog/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li><li><a class="site-page child" href="/blog/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/blog/messageboard/"><i class="fa-fw fas fa-coffee"></i><span> Messageboard</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/blog/img/golang.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/blog/">Some</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/blog/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="//tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/blog/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/blog/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/blog/movies/"><i class="fa-fw fas fa-film"></i><span> Movie</span></a></li><li><a class="site-page child" href="/blog/photos/"><i class="fa-fw fas fa-picture"></i><span> Photo</span></a></li><li><a class="site-page child" href="/blog/games/"><i class="fa-fw fas fa-gamepad"></i><span> Game</span></a></li><li><a class="site-page child" href="/blog/books/"><i class="fa-fw fas fa-book"></i><span> Book</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/blog/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page" href="/blog/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/blog/messageboard/"><i class="fa-fw fas fa-coffee"></i><span> Messageboard</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go并发编程总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2020-06-09T09:36:01.000Z" title="Created 2020-06-09 17:36:01">2020-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2021-11-16T10:01:25.929Z" title="Updated 2021-11-16 18:01:25">2021-11-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/blog/categories/GOLANG/">GOLANG</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go并发编程总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>Golang :不要通过共享内存来通信，而应该<strong><em>\</em>通过通信来共享内存**</strong>。这句风靡在Go社区的话,说的就是 goroutine中的 channel。他在go并发编程中充当着类型安全的管道作用。</p>
<h1><span id="1-通过golang中的-goroutine-与syncmutex进行-并发同步">1、通过golang中的 goroutine 与sync.Mutex进行 并发同步</span></h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> count <span class="built_in">int</span> = <span class="number">0</span>   <span class="comment">//全局共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">counter</span>(<span class="params"><span class="keyword">lock</span> * sync.Mutex</span>)</span>&#123;  <span class="comment">//goroutinue执行函数</span></span><br><span class="line">	<span class="keyword">lock</span>.Lock()</span><br><span class="line">	count++</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">	<span class="keyword">lock</span>.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">lock</span> := &amp;sync.Mutex&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="comment">//传递指针是为了防止 函数内的锁和 调用锁不一致    创建10个协程对count++</span></span><br><span class="line">		<span class="function">go <span class="title">counter</span>(<span class="params"><span class="keyword">lock</span></span>)</span></span><br><span class="line"><span class="function">	&#125;</span></span><br><span class="line"><span class="function">	<span class="keyword">for</span></span> &#123;</span><br><span class="line">		<span class="keyword">lock</span>.Lock()</span><br><span class="line">		c := count</span><br><span class="line">		<span class="keyword">lock</span>.Unlock()</span><br><span class="line">		<span class="comment"><span class="doctag">///</span>把时间片给别的goroutine  未来某个时刻运行该routine</span></span><br><span class="line">		runtime.Gosched()</span><br><span class="line">		<span class="keyword">if</span> c &gt;=<span class="number">10</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;goroutine end&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;  <span class="comment">//输出结果：1 2 3 4 5 6 7 8 9 10    &quot;goroutine end&quot;</span></span><br></pre></td></tr></table></figure>

<h1><span id="2-goroutine之间通过-channel进行通信channel是和类型相关的-可以理解为-是一种类型安全的管道">2、goroutine之间通过 channel进行通信,channel是和类型相关的 可以理解为  是一种类型安全的管道。</span></h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">Count</span>(<span class="params">ch chan <span class="built_in">int</span></span>)</span> &#123;</span><br><span class="line">	ch &lt;- <span class="number">1</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Counting&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">func <span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">	chs := make([]&lt;strong&gt;chan <span class="built_in">int</span>&lt;/strong&gt;, <span class="number">10</span>)   <span class="comment">//[]chan int 表示是chan int类型的切片 和   chan []int区别  标识通道类型是[]int</span></span><br><span class="line">	<span class="comment">//c := make(chan []int)</span></span><br><span class="line">	<span class="comment">//t := []int&#123;1,2,3&#125;</span></span><br><span class="line">	<span class="comment">//c &lt;- t</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		chs[i] = make(chan <span class="built_in">int</span>)</span><br><span class="line">		<span class="function">go <span class="title">Count</span>(<span class="params">chs[i]</span>)         <span class="comment">//创建10个协程</span></span></span><br><span class="line"><span class="function">		fmt.<span class="title">Println</span>(<span class="params"><span class="string">&quot;Count&quot;</span>,i</span>)</span></span><br><span class="line"><span class="function">	&#125;</span></span><br><span class="line"><span class="function">	<span class="keyword">for</span> i, ch :</span>= range chs &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">		fmt.Println(<span class="string">&quot;Counting&quot;</span>,i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;       <span class="comment">//调度的顺序不同，可能goroutinue执行的顺序不一样</span></span><br></pre></td></tr></table></figure>

<h1><span id="3-go语言中的select是语言级内置-非堵塞">3、Go语言中的select是语言级内置  非堵塞</span></h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1: <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句  </span></span><br><span class="line"><span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>: <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句  </span></span><br><span class="line"><span class="literal">default</span>: <span class="comment">// 如果上面都没有成功，则进入default处理流程  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，select不像switch，后面并不带判断条件，而是直接去查看case语句。每个case语句都必须是一个面向channel的操作。比如上面的例子中，第一个case试图从chan1读取一个数据并直接忽略读到的数据，而第二个case则是试图向chan2中写入一个整型数1，如果这两者都没有成功，则到达default语句。</p>
<h1><span id="4-channel-的带缓冲读取写入">4、channel 的带缓冲读取写入</span></h1><p>要创建一个带缓冲的channel，其实也非常容易：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>

<p>在调用make()时将缓冲区大小作为第二个参数传入即可，比如上面这个例子就创建了一个大小为1024的int类型channel，即使没有读取方，写入方也可以一直往channel里写入，在缓冲区被填完之前都不会阻塞。</p>
<p>从带缓冲的channel中读取数据可以使用与常规非缓冲channel完全一致的方法，但我们也可以使用range关键来实现更为简便的循环读取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Received:&quot;</span>, i)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h1><span id="5-用goroutine模拟生产消费者">5、用goroutine模拟生产消费者</span></h1><p>因为程序会<strong><em>\</em>优先执行主线程，主线程执行完成后，程序会立即退出**</strong>，没有多余的时间去执行子线程。如果在程序的最后让主线程休眠1秒钟，那程序就会有足够的时间去执行子线程。 通道又叫channel，顾名思义，channel的作用就是在多线程之间传递数据的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">chreadandwrite :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">chonlyread := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//创建只读channel    var read &lt;-chan int = chreadandwrite </span></span><br><span class="line">chonlywrite := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="keyword">int</span>) <span class="comment">//创建只写channel   var write chan&lt;- int = chreadandwrite </span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(p <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		p &lt;- i</span><br><span class="line">		fmt.Println(<span class="string">&quot;send:&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		v := &lt;-c</span><br><span class="line">		fmt.Println(<span class="string">&quot;receive:&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="comment">/*ch :=make(chan int)</span></span><br><span class="line"><span class="comment">	ch &lt;- 1</span></span><br><span class="line"><span class="comment">	这个错误的意思是说线程陷入了死锁，程序无法继续往下执行。那么造成这种错误的原因是什么呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;	&lt;/span&gt;我们创建了一个无缓冲的channel，然后给这个channel赋值了，程序就是在赋值完成后陷入了死锁。</span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;	&lt;/span&gt;因为我们的channel是无缓冲的，即同步的，赋值完成后来不及读取channel，程序就已经阻塞了。  =====    顺序执行满阻塞</span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;	&lt;/span&gt;queue &lt;- 1</span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;	&lt;/span&gt;queue &lt;- 2   //满阻塞</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> Producer(queue)     <span class="comment">//开启协程执行函数单独去执行，主程序直接往下执行</span></span><br><span class="line">	                       <span class="comment">//i = 0 的时候，写入阻塞      生产者和消费者是异步执行，消费者会去读取channel值。</span></span><br><span class="line">	<span class="keyword">go</span> Consumer(queue)</span><br><span class="line">	time.Sleep(<span class="number">1e9</span>)        <span class="comment">//让Producer与Consumer完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为channel是没有缓冲的，所以当生产者给channel赋值后，生产者这个线程会阻塞，<strong><em>\</em>直到消费者线程将channel中的数据取出**</strong>。消费者第一次将数据取出后，进行下一次循环时，消费者的线程也会阻塞，因为生产者还没有将数据存入，这时程序会去执行生产者的线程。程序就这样在消费者和生产者两个线程间不断切换，直到循环结束。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">(p <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		p &lt;- i</span><br><span class="line">		fmt.Println(<span class="string">&quot;send:&quot;</span>, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		v := &lt;-c</span><br><span class="line">		fmt.Println(<span class="string">&quot;receive:&quot;</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)  <span class="comment">//带缓冲的例子</span></span><br><span class="line">	<span class="keyword">go</span> produce(ch)</span><br><span class="line">	<span class="keyword">go</span> consumer(ch)</span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个程序中，缓冲区可以存储10个int类型的整数，在执行生产者线程的时候，线程就不会阻塞，一次性将10个整数存入channel，在读取的时候，也是一次性读取。读取的话，没有数据就阻塞，有的话依次进行读取操作。</p>
<h1><span id="6-通过make-创建通道">6、通过make 创建通道</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(c1 <span class="keyword">chan</span> <span class="keyword">int</span>)       创建的是 同步channel ...读写完全对应    先写满的话就会阻塞  顺序程序不会执行</span><br><span class="line"><span class="built_in">make</span>(c1 <span class="keyword">chan</span> <span class="keyword">int</span> ,<span class="number">10</span>)   创建带缓冲的通道 上来可以写<span class="number">10</span>次        </span><br></pre></td></tr></table></figure>

<h1><span id="7-随机向通道中写入0或者1">7、随机向通道中写入0或者1</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="comment">///不停向channel中随机写入 0 或者1</span></span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> ch &lt;- <span class="number">0</span>:</span><br><span class="line">		<span class="keyword">case</span> ch &lt;- <span class="number">1</span>:</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//从通道中取出数据</span></span><br><span class="line">		i := &lt;-ch</span><br><span class="line">		fmt.Println(<span class="string">&quot;Value received:&quot;</span>,i)</span><br><span class="line">		time.Sleep(<span class="number">1e8</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="8-带缓冲的channel">8、带缓冲的channel</span></h1><p>之前创建的都是不带缓冲的channel，这种做法对于传递单个数据的场景可以接受，但对于需要持续传输大量数据的场景就有些不合适了。接下来我们介绍如何给channel带上缓冲，从而达到消息队列的效果。</p>
<p>要创建一个带缓冲的channel，其实也非常容易：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure>

<p>在调用make()时将缓冲区大小作为第二个参数传入即可，比如上面这个例子就创建了一个大小为1024的int类型channel，即使没有读取方，写入方也可以一直往channel里写入，在缓冲区被填完之前都不会阻塞。</p>
<p>从带缓冲的channel中读取数据可以使用与常规非缓冲channel完全一致的方法，但我们也可以使用range关键来实现更为简便的循环读取：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Received:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">		c&lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> val:=<span class="keyword">range</span> c &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Value:&quot;</span>,val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	chs:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">	<span class="comment">//只要有通道操作一定要放到goroutine中否则会堵塞当前的主线程 并且导致程序退出</span></span><br><span class="line">	<span class="comment">//对于同步通道 或者带缓冲的通道 一定要封装成函数 使用 goroutine 包装</span></span><br><span class="line">	<span class="keyword">go</span> A(chs)</span><br><span class="line">	<span class="keyword">go</span> B(chs)</span><br><span class="line">	time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="9-关于创建多个goroutine具体到go语言会创建多少个线程">9、关于创建多个goroutine具体到go语言会创建多少个线程</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="comment">//&quot;fmt&quot;</span></span><br><span class="line">	<span class="comment">//&quot;time&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				b:=<span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">10</span>)</span><br><span class="line">				os.Stdin.Read(b) <span class="comment">// will block</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会产生21个线程：<br>runtime scheduler(src/pkg/runtime/proc.c)会<strong><em>\</em>维护一个线程池，当某个goroutine被block后，scheduler会创建一个新线程给其他ready的goroutine。**</strong><br>GOMAXPROCS控制的是未被阻塞的所有goroutine被multiplex到多少个线程上运行</p>
<h1><span id="10-在channel中也是可以传递channel的go语言的channel和map-slice等一样都是原生类型">10、在channel中也是可以传递channel的,Go语言的channel和map  slice等一样都是原生类型</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">chan</span> <span class="keyword">int</span>   <span class="keyword">chan</span> <span class="keyword">int</span>切片    <span class="keyword">chan</span> []<span class="keyword">int</span> 表示的是<span class="keyword">chan</span>里面存的数据时[]<span class="keyword">int</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在Go语言中channel本身也是一个原生类型，与map之类的类型地位一样，因此channel本身在定义后也可以通过channel来传递。</p>
<p>我们可以使用这个特性来实现*nix上非常常见的管道（pipe）特性。管道也是使用非常广泛的一种设计模式，比如在处理数据时，我们可以采用管道设计，这样可以比较容易以插件的方式增加数据的处理流程。</p>
<p>下面我们<strong><em>\</em>利用channel可被传递的特性来实现我们的管道**</strong>。 为了简化表达， 我们假设在管道中传递的数据只是一个整型数，在实际的应用场景中这通常会是一个数据块。</p>
<p>首先限定基本的数据结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PipeData <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="keyword">int</span></span><br><span class="line">    handler <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line">    next <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们写一个常规的处理函数。我们只要定义一系列PipeData的数据结构并一起传递给 这个函数，就可以达到流式处理数据的目的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *PipeData)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        data.next &lt;- data.handler(data.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="11-我们默认创建的是双向通道单向通道没有意义但是我们却可以通过强制转换-将双向通道-转换成为单向通道">11、我们默认创建的是双向通道,单向通道没有意义,但是我们却可以通过强制转换 将双向通道 转换成为单向通道</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">// ch1是一个正常的channel，不是单向的  </span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span>&lt;- <span class="keyword">float64</span><span class="comment">// ch2是单向channel，只用于写float64数据</span></span><br><span class="line"><span class="keyword">var</span> ch3 &lt;-<span class="keyword">chan</span> <span class="keyword">int</span> <span class="comment">// ch3是单向channel，只用于读取int数据 </span></span><br></pre></td></tr></table></figure>

<p>channel是一个原生类型，因此不仅支持被传递，还支持类型转换。只有在介绍了单向channel的概念后，读者才会明白类型转换对于channel的意义：就是在单向channel和双向channel之间进行转换。</p>
<p>示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">ch5 := &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>(ch4) <span class="comment">// ch5就是一个单向的读取channel</span></span><br><span class="line">ch6 := <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>(ch4) <span class="comment">// ch6 是一个单向的写入channel</span></span><br></pre></td></tr></table></figure>

<p>基于ch4，我们通过类型转换初始化了两个单向channel：单向读的ch5和单向写的ch6。 </p>
<p>从设计的角度考虑，所有的代码应该都遵循”最小权限原则” ，从而避免没必要地使用泛滥问题， 进而导致程序失控。 写过C++程序的读者肯定就会联想起const 指针的用法。非const指针具备const指针的所有功能，将一个指针设定为const就是明确告诉 </p>
<p><strong><em>\</em>函数实现者不要试图对该指针进行修改。单向channel也是起到这样的一种契约作用**</strong>。下面我们来看一下单向channel的用法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Parsing value&quot;</span>, value)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除非这个函数的实现者无耻地使用了类型转换，否则这个函数就不会因为各种原因而对ch 进行写，避免在ch中出现非期望的数据，从而很好地实践最小权限原则。</p>
<h1><span id="12-只读只写-单向-channel-代码例子-遵循权限最小化的原则">12、只读只写 单向 channel 代码例子   遵循权限最小化的原则</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//接受一个参数 是只允许读取通道  除非直接强制转换 要么你只能从channel中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sCh</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> val:= <span class="keyword">range</span> ch &#123;</span><br><span class="line">		fmt.Println(val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建一个带100缓冲的通道 可以直接写入 而不会导致 主线程堵塞</span></span><br><span class="line">	dch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">100</span>)</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">		dch&lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//传递进去 只读通道</span></span><br><span class="line">	<span class="keyword">go</span> sCh(dch)</span><br><span class="line">	time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1><span id="13-channel的关闭以及判断channel的关闭">13、channel的关闭,以及判断channel的关闭</span></h1><p>关闭channel非常简单，直接使用Go语言内置的close()函数即可：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">close</span>(ch)</span><br></pre></td></tr></table></figure>

<p>在介绍了如何关闭channel之后，我们就多了一个问题：如何判断一个channel是否已经被关闭？我们可以在读取的时候使用多重返回值的方式：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x</span>, ok := &lt;-ch</span><br></pre></td></tr></table></figure>

<p>这个用法与map中的按键获取value的过程比较类似，只需要看第二个bool返回值即可，如果返回值是false则表示ch已经被关闭。</p>
<h1><span id="14-go的多核并行化编程-高性能并发编程-必须设置gomaxprocs-为最大核数目-这个值由runtimenumcpu获取">14、Go的多核并行化编程   高性能并发编程 必须设置GOMAXPROCS 为最大核数目 这个值由runtime.NumCPU()获取</span></h1><p>在执行一些昂贵的计算任务时， 我们希望能够尽量<strong><em>\</em>利用现代服务器普遍具备的多核特性来尽量将任务并行化**</strong>，从而达到降低总计算时间的目的。此时我们需要了解<strong><em>\</em>CPU核心的数量**</strong>，并针对性地分解计算任务到多个goroutine中去并行运行。</p>
<p>下面我们来模拟一个完全可以并行的计算任务：计算N个整型数的总和。我们可以将<strong><em>\</em>所有整型数分成M份，M即CPU的个数**</strong>。让每个CPU开始计算分给它的那份计算任务，最后将每个CPU的计算结果再做一次累加，这样就可以得到所有N个整型数的总和：</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Vector</span> []float64</span></span><br><span class="line">// 分配给每个<span class="type">CPU</span>的计算任务</span><br><span class="line"><span class="title">func</span> (v <span class="type">Vector</span>) <span class="type">DoSome</span>(i, n int, u <span class="type">Vector</span>, c chan int) &#123;</span><br><span class="line"><span class="title">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">         v[i] += u.<span class="type">Op</span>(v[i])</span><br><span class="line">     &#125;</span><br><span class="line">     c &lt;- <span class="number">1</span>       </span><br><span class="line">// 发信号告诉任务管理者我已经计算完成了</span><br><span class="line">&#125;</span><br><span class="line"><span class="title">const</span> <span class="type">NCPU</span> = <span class="number">16</span>     </span><br><span class="line">// 假设总共有<span class="number">16</span>核   </span><br><span class="line"><span class="title">func</span> (v <span class="type">Vector</span>) <span class="type">DoAll</span>(u <span class="type">Vector</span>) &#123;   </span><br><span class="line">    c := make(chan int, <span class="type">NCPU</span>)  // 用于接收每个<span class="type">CPU</span>的任务完成信号   </span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="type">NCPU</span>; i++ &#123;   </span><br><span class="line">            go v.<span class="type">DoSome</span>(i*len(v)/<span class="type">NCPU</span>, (i+<span class="number">1</span>)*len(v)/<span class="type">NCPU</span>, u, c)</span><br><span class="line">    &#125; </span><br><span class="line">    // 等待所有<span class="type">CPU</span>的任务完成</span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="type">NCPU</span>; i++ &#123;   </span><br><span class="line">         &lt;-c    // 获取到一个数据，表示一个<span class="type">CPU</span>计算完成了</span><br><span class="line">    &#125;</span><br><span class="line">// 到这里表示所有计算已经结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个函数看起来设计非常合理。<strong><em>\</em>DoAll()会根据CPU核心的数目对任务进行分割**</strong>，然后开辟多个goroutine来并行执行这些计算任务。是否可以将总的计算时间降到接近原来的1/N呢？答案是不一定。如果掐秒表（正常点的话，应该用7.8节中介绍的Benchmark方法） ，会发现总的执行时间没有明显缩短。再去观察CPU运行状态， 你会发现<strong><em>\</em>尽管我们有16个CPU核心， 但在计算过程中其实只有一个CPU核心处于繁忙状态**</strong>，这是会让很多Go语言初学者迷惑的问题。</p>
<p>官方的答案是，这是当前版本的Go编译器还不能很智能地去发现和利用多核的优势。虽然我们确实创建了多个goroutine，并且从运行状态看这些goroutine也都在并行运行，但实际上<strong><em>\</em>所有这些goroutine都运行在同一个CPU核心上， 在一个goroutine得到时间片执行的时候， 其他goroutine都会处于等待状态**</strong>。从这一点可以看出，虽然goroutine简化了我们写并行代码的过程，但实际上整体运行效率并不真正高于单线程程序。</p>
<p>在Go语言升级到默认支持多CPU的某个版本之前，我们可以先通过设置环境变量</p>
<p>GOMAXPROCS的值来控制使用多少个CPU核心。具体操作方法是通过直接设置环境变量GOMAXPROCS的值，或者在代码中启动goroutine之前先调用以下这个语句以设置使用16个CPU核心：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(16)</span><br></pre></td></tr></table></figure>

<p>到底应该设置多少个CPU核心呢，其实runtime包中还提供了另外一个<strong><em>\</em>函数NumCPU()来获取核心数**</strong>。可以看到，Go语言其实已经感知到所有的环境信息，下一版本中完全可以利用这些信息将goroutine调度到所有CPU核心上，从而最大化地利用服务器的多核计算能力。抛弃GOMAXPROCS只是个时间问题。</p>
<h1><span id="15-主动出让时间片给其他-goroutine-在未来的某一时刻再来执行当前goroutine">15、主动出让时间片给其他 goroutine 在未来的某一时刻再来执行当前goroutine</span></h1><p>我们可以在每个goroutine中控制何时主动出让时间片给其他goroutine，这可以使用<strong><em>\</em>runtime包中的Gosched()函数**</strong>实现。<br>实际上，如果要比较精细地控制goroutine的行为，就必须比较深入地了解Go语言开发包中runtime包所提供的具体功能。</p>
<h1><span id="16-go中的同步及同步锁">16、Go中的同步及同步锁</span></h1><p>倡导用通信来共享数据，而不是通过共享数据来进行通信，但考虑到即使成功地用channel来作为通信手段，还是<strong><em>\</em>避免不了多个goroutine之间共享数据的问题**</strong>，Go语言的设计者虽然对channel有极高的期望，但也提供了妥善的<strong><em>\</em>资源锁方案**</strong>。</p>
<p>对于这两种锁类型， 任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()调用与之对应，<strong><em>\</em>否则可能导致等待该锁的*****</strong>*所有goroutine处于饥饿状态，甚至可能导致死锁****。锁的典型使用模式如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.<span class="type">Mutex</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span>()</span> &#123;</span><br><span class="line">l.<span class="type">Lock</span>()  </span><br><span class="line"><span class="comment">//延&lt;strong&gt;迟调用 在函数退出 并且局部资源被释放的时候 调用&lt;/strong&gt;</span></span><br><span class="line"><span class="keyword">defer</span> l.<span class="type">Unlock</span>()  </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>这里我们再一次见证了Go语言defer关键字带来的优雅。</p>
<h1><span id="17-全局唯一操作-synconcedo-syncatomic原子操作子包">17、全局唯一操作 sync.Once.Do() sync.atomic原子操作子包</span></h1><p>对于从全局的角度只需要运行一次的代码，比如全局初始化操作，Go语言提供了一个<strong><em>\</em>Once类型来保证全局的唯一性操作**</strong>，具体代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(setup)</span><br><span class="line">    <span class="built_in">print</span>(a)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> doprint()</span><br><span class="line">    <span class="keyword">go</span> doprint()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这段代码没有引入Once， setup()将会被每一个goroutine先调用一次， 这至少对于这个例子是多余的。在现实中，我们也经常会遇到这样的情况。Go语言标准库为我们引入了Once类型以解决这个问题。<strong><em>\</em>once的Do()方法可以保证在全局范围内只调用指定的函数一次**</strong>（这里指setup()函数），而且所有其他goroutine在调用到此语句时，将会先被阻塞，直至全局唯一的once.Do()调用结束后才继续。</p>
<p>这个机制比较轻巧地解决了使用其他语言时开发者不得不自行设计和实现这种Once效果的难题，也是Go语言为并发性编程做了尽量多考虑的一种体现。</p>
<p>如果没有once.Do()，我们很可能只能添加一个全局的bool变量，在函数setup()的最后一行将该bool变量设置为true。在对setup()的所有调用之前，需要先判断该bool变量是否已经被设置为true，如果该值仍然是false，则调用一次setup()，否则应跳过该语句。实现代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done <span class="keyword">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello, world&quot;</span> </span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">if</span> !done &#123;</span><br><span class="line">        setup()</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">print</span>(a)  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>这段代码初看起来比较合理， 但是细看还是会有问题， 因为<strong><em>\</em>setup()并不是一个原子性操作**</strong>，这种写法可能导致setup()函数被多次调用，从而无法达到全局只执行一次的目标。这个问题的复杂性也更加体现了Once类型的价值。 //还没有执行到done=true的时候  另外调用doprint已经执行起来。</p>
<p>为了更好地控制并行中的原子性操作，sync包中还包含一个atomic子包，它提供了对于一些基础数据类型的原子操作函数，比如下面这个函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(val *<span class="keyword">uint64</span>, old, <span class="built_in">new</span> <span class="keyword">uint64</span>)</span> <span class="params">(swapped <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>就提供了比较和交换两个uint64类型数据的操作。这让开发者无需再为这样的操作专门添加Lock操作。</p>
<p>转载链接：<a target="_blank" rel="noopener" href="http://lib.csdn.net/article/53/36140?knId=1441">http://lib.csdn.net/article/53/36140?knId=1441</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:xiapeifu@gmail.com">夏夏天</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://smartxia.github.io/blog/2020/06/09/GOLANG/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/">https://smartxia.github.io/blog/2020/06/09/GOLANG/Go并发编程总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/blog/img/golang.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="http://s2-cdn.oneitfarm.com/ec13d36268ae41d7aaf87d5505324b6a.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://s2-cdn.oneitfarm.com/ec13d36268ae41d7aaf87d5505324b6a.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="http://s2-cdn.oneitfarm.com/2eef3a681187495aa43ff8bbe1173c09.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://s2-cdn.oneitfarm.com/2eef3a681187495aa43ff8bbe1173c09.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/blog/2020/06/09/GOLANG/GOLANG-%E7%AC%94%E8%AE%B01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/img/golang.jpeg" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">GOLANG笔记1-基础数据类型</div></div></a></div><div class="next-post pull-right"><a href="/blog/2020/06/09/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://d33wubrfki0l68.cloudfront.net/5997a40576f3beca7bbbd86fe79a795e9d520d8e/87f88/themes/screenshots/landscape.png" onerror="onerror=null;src='/blog/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">HEXO快捷方式</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="http://s2-cdn.oneitfarm.com/e12ece12233b4059860acf48637d830a.jpg" onerror="this.onerror=null;this.src='/blog/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">夏夏天</div><div class="author-info__description">以地事秦 犹抱薪救火 薪不尽 火不灭</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/blog/archives/"><div class="headline">Articles</div><div class="length-num">69</div></a></div><div class="card-info-data-item is-center"><a href="/blog/tags/"><div class="headline">Tags</div><div class="length-num">48</div></a></div><div class="card-info-data-item is-center"><a href="/blog/categories/"><div class="headline">Categories</div><div class="length-num">19</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="/blog/atom.xml" target="_blank" title=""><i class="fa fa-rss"></i></a><a class="social-icon" href="https://github.com/smartXia" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:xiapeifu@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://gitee.com/xiapeifu" target="_blank" title="Gitee"><i class="iconfont gitee"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">1、通过golang中的 goroutine 与sync.Mutex进行 并发同步</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">2、goroutine之间通过 channel进行通信,channel是和类型相关的 可以理解为  是一种类型安全的管道。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">3、Go语言中的select是语言级内置  非堵塞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">4、channel 的带缓冲读取写入</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">5、用goroutine模拟生产消费者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">6、通过make 创建通道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">7、随机向通道中写入0或者1</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">8、带缓冲的channel</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">9、关于创建多个goroutine具体到go语言会创建多少个线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">10、在channel中也是可以传递channel的,Go语言的channel和map  slice等一样都是原生类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">11、我们默认创建的是双向通道,单向通道没有意义,但是我们却可以通过强制转换 将双向通道 转换成为单向通道</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">12、只读只写 单向 channel 代码例子   遵循权限最小化的原则</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">13、channel的关闭,以及判断channel的关闭</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">14、Go的多核并行化编程   高性能并发编程 必须设置GOMAXPROCS 为最大核数目 这个值由runtime.NumCPU()获取</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">15、主动出让时间片给其他 goroutine 在未来的某一时刻再来执行当前goroutine</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">16、Go中的同步及同步锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">17、全局唯一操作 sync.Once.Do() sync.atomic原子操作子包</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/11/18/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/" title="GOLANG-GPM的深入理解"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/img/golang.jpeg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="GOLANG-GPM的深入理解"/></a><div class="content"><a class="title" href="/blog/2021/11/18/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/" title="GOLANG-GPM的深入理解">GOLANG-GPM的深入理解</a><time datetime="2021-11-18T02:08:03.000Z" title="Created 2021-11-18 10:08:03">2021-11-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/" title="GOLANG-纯纯的语法仔的没落"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/img/golang.jpeg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="GOLANG-纯纯的语法仔的没落"/></a><div class="content"><a class="title" href="/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/" title="GOLANG-纯纯的语法仔的没落">GOLANG-纯纯的语法仔的没落</a><time datetime="2021-11-17T03:57:39.000Z" title="Created 2021-11-17 11:57:39">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/11/17/GOLANG/GOLANG-grpc/" title="GOLANG-grpc"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/img/golang.jpeg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="GOLANG-grpc"/></a><div class="content"><a class="title" href="/blog/2021/11/17/GOLANG/GOLANG-grpc/" title="GOLANG-grpc">GOLANG-grpc</a><time datetime="2021-11-17T02:28:40.000Z" title="Created 2021-11-17 10:28:40">2021-11-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/11/16/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/" title="PHP-析构函数-destruct"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/img/php.jpeg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="PHP-析构函数-destruct"/></a><div class="content"><a class="title" href="/blog/2021/11/16/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/" title="PHP-析构函数-destruct">PHP-析构函数-destruct</a><time datetime="2021-11-16T03:33:44.698Z" title="Created 2021-11-16 11:33:44">2021-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/blog/2021/11/16/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/" title="GOLANG-笔记-ArrayMapSlice"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/blog/img/golang.jpeg" onerror="this.onerror=null;this.src='/blog/img/404.jpg'" alt="GOLANG-笔记-ArrayMapSlice"/></a><div class="content"><a class="title" href="/blog/2021/11/16/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/" title="GOLANG-笔记-ArrayMapSlice">GOLANG-笔记-ArrayMapSlice</a><time datetime="2021-11-16T03:33:44.686Z" title="Created 2021-11-16 11:33:44">2021-11-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By 夏夏天</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional Chinese And Simplified Chinese">简</button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/blog/js/utils.js"></script><script src="/blog/js/main.js"></script><script src="/blog/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/blog/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'b5KjzAk69Lg3yBaVPeEiuljv-gzGzoHsz',
      appKey: 'Yb0PJ1jscpDdBIvDLO6MEYUy',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: true,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>