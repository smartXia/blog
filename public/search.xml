<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络协议</title>
      <link href="/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>[TOC]</p><h3 id="1-0-网络协议（TCP-Trancemission-Control-Protocol）"><a href="#1-0-网络协议（TCP-Trancemission-Control-Protocol）" class="headerlink" title="1.0 网络协议（TCP Trancemission Control Protocol）"></a>1.0 网络协议（TCP Trancemission Control Protocol）</h3><ul><li><p>TCP 七层网络模型<br>主机层：<br>媒介层：</p><p><img src= "/blog/img/loading.gif" data-lazy-src="http://s2-cdn.oneitfarm.com/767fb54c00ef41d1b15f28a8c33f3d16.png" alt=""></p></li></ul><h4 id="1-1-请求头"><a href="#1-1-请求头" class="headerlink" title="1.1 请求头"></a>1.1 请求头</h4><h4 id="1-2-三次握手四次挥手"><a href="#1-2-三次握手四次挥手" class="headerlink" title="1.2 三次握手四次挥手"></a>1.2 三次握手四次挥手</h4><h4 id="1-3-报文抓取工具"><a href="#1-3-报文抓取工具" class="headerlink" title="1.3 报文抓取工具"></a>1.3 报文抓取工具</h4><h3 id="2-0-HTTP-HyperText-Transfer-protocol"><a href="#2-0-HTTP-HyperText-Transfer-protocol" class="headerlink" title="2.0 HTTP (HyperText Transfer protocol)"></a>2.0 HTTP (HyperText Transfer protocol)</h3><h4 id="2-1-请求报文"><a href="#2-1-请求报文" class="headerlink" title="2.1 请求报文"></a>2.1 请求报文</h4><h4 id="2-2-响应报文"><a href="#2-2-响应报文" class="headerlink" title="2.2 响应报文"></a>2.2 响应报文</h4><h4 id="2-3-HTTP-抓取工具"><a href="#2-3-HTTP-抓取工具" class="headerlink" title="2.3 HTTP 抓取工具"></a>2.3 HTTP 抓取工具</h4><h4 id="2-4-Session-Cookie"><a href="#2-4-Session-Cookie" class="headerlink" title="2.4 Session Cookie"></a>2.4 Session Cookie</h4>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The MIT License</title>
      <link href="/blog/2021/05/27/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
      <url>/blog/2021/05/27/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>MIT许可证（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件授权条款（如GPL、LGPL、BSD）相比，MIT是相对宽松的软件授权条款。</p></blockquote><h3 id="1-条款内容"><a href="#1-条款内容" class="headerlink" title="1.条款内容"></a>1.条款内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span><br><span class="line">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br></pre></td></tr></table></figure><h3 id="2-MIT与其他开源许可证的区别"><a href="#2-MIT与其他开源许可证的区别" class="headerlink" title="2.MIT与其他开源许可证的区别"></a>2.MIT与其他开源许可证的区别</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="//s2-cdn.oneitfarm.com/2bec9f7690a945a499ebc95fd84a0cb5.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>孔乙己和阿Q</title>
      <link href="/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/"/>
      <url>/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>孔乙己原为鲁迅笔下的一个旧时代的人物，我们可以简单理解为一个臭读书的<br>阿Q我们听到的最多的是阿Q精神：自恋不自知的小人物<br>这些都是鲁迅笔下的小人物，之前不大明白鲁迅为何喜欢写这些我们现在看起来抨击小人物的短片小说，<br>包括对闰土 阿Q 孔乙己 祥林嫂 范爱农等等这些现在看起来很离谱的事情，这要是放到现在不得不说是一股奇葩的力量<br>在微博贡献，因为本人也是个冲浪的键盘侠。<br>但了解过鲁迅大大说过一句很经典的话：学医救不了中国人<br>当时是民国 想想这句话到底有几个味道大家便知道了<br>现在提起来中国人，你走到哪里都是自豪的，除了蜜汁自信呢的美帝，最起码在国外是没问题的，对于一个长时间被中央人民广播电台熏陶的年青人是这样的</p><p>当时中国是被侵略，被十几个人打，想想那画面，不敢还手，对于国家至此，何况老百姓。<br>其实鲁迅笔下任务用的最多为小小的底层任务对社会，谈不上社会，而是对自己的生活圈子里造成的影响，可有可无的那种。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从正则表达式的iUs说说模式修正符</title>
      <link href="/blog/2021/05/25/PHP/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/"/>
      <url>/blog/2021/05/25/PHP/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>本想做个简单的采集程序，发现被抓页面代码的规律后发现抓下来的内容没有放到一个数组中，而是放在一个元素中，无奈找遍资料发现在正则表达式后加上”/iUs”后竟然可以了。<br>hexo<br>网上关于iUs的说明多数都是抄袭的，没有做过多的解释，对于一个小学毕业证是买来的人来说是在是不好理解。不过幸亏Google让我找到答案。</p><p>“iUs” 在这里叫“模式修正符”。模式修正符其实就是几个字母，可以一次使用一个也可以一次使用多个，每一个都具有一定的意义，模式修正符是对正则表达式的扩展；“/模式修正符”，其中正斜线“/”为边界符。下表列出来有那些模式修正符：</p><p>模式修正符    说明<br>i    表示在和模式进行匹配进不区分大小写<br>m    将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束<br>s    如果没有使用这个模式修正符号，元字符中的”.”默认不能表示换行符号,将字符串视为单行<br>x    表示模式中的空白忽略不计<br>e    正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说)<br>A    以模式字符串开头，相当于元字符^<br>Z    以模式字符串结尾，相当于元字符$<br>U    正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式</p><h3 id="1，模式修正符m。"><a href="#1，模式修正符m。" class="headerlink" title="1，模式修正符m。"></a>1，模式修正符m。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;^abc&#x2F;m’;</span><br><span class="line">$string &#x3D; ‘bcd</span><br><span class="line">abc</span><br><span class="line">cba’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>匹配结果是成功的。注意：我们在使用模式修正符m的时候，将匹配字符串看成是多行而不是默认的单行，所以任何一行只要是以abc开头，就匹配成功。但是，如果能匹配的行前面有空格的话，就不能匹配了!除非修改正则表达式的匹配模式。</p><h3 id="2，模式修正符s。"><a href="#2，模式修正符s。" class="headerlink" title="2，模式修正符s。"></a>2，模式修正符s。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;a.*c&#x2F;s’;</span><br><span class="line">$string &#x3D; ‘adsadsa</span><br><span class="line">c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配记过也是成功的。如果你将上例中的模式修正符s去掉的话，匹配就会失败。因为模式修正符s将匹配字符串看作是单行的，所以这个时候，元字符中的”.”就可以表示换行符号了。</p><h3 id="3，模式修正符x。"><a href="#3，模式修正符x。" class="headerlink" title="3，模式修正符x。"></a>3，模式修正符x。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;a c&#x2F;x’;</span><br><span class="line">$string &#x3D; ‘a c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配结果是失败的。因为我们使用模式修正符x取消了模式中的空格。注意：我们无法使用模式修正符取消\s表示的空白。</p><h3 id="4，模式修正符A。"><a href="#4，模式修正符A。" class="headerlink" title="4，模式修正符A。"></a>4，模式修正符A。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;ac&#x2F;A’;</span><br><span class="line">$string &#x3D; ‘acahgyghvbm’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正则表达式表示的含义是匹配以ac开头的字符串，结果成功。</p><p>模式修正符Z表示的是以字符串结尾的匹配，和A的用法是一样的，我们不再进行演示。</p><h3 id="5，模式修正符U。"><a href="#5，模式修正符U。" class="headerlink" title="5，模式修正符U。"></a>5，模式修正符U。</h3><p>这个模式修正符是十分重要的!在正则表达式中，其本身是“贪婪”的。那什么是贪婪模式呢?贪婪模式的意思就是说，正则表达式默认会在查找到第一个匹配后，继续尝试后面的匹配，如果能找到匹配，则匹配最大的范围字符串。但有的时候这并不是我们想要的结果，所以我们需要取消贪婪模式。</p><p>我们还是先看一个贪婪模式的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*&lt;\&#x2F;b&gt;&#x2F;’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个实例的本意是匹配welcome，但是结果却匹配了welcome to phpfuns整个字符串(注意我们的字符串’welcome to phpfuns’，其开头和结尾正好构成了正则表达式的模式匹配，所以匹配成功)，这就是正则表达式的贪婪模式。当然，这不是我们要的结果。</p><p>取消贪婪模式<br>我们可以使用模式修正符U和元字符?两种方式取消正则表达式的贪婪模式。</p><p>模式修正符U取消贪婪模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*&lt;\&#x2F;b&gt;&#x2F;U’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>元字符?取消贪婪模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*?&lt;\&#x2F;b&gt;&#x2F;’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;dsadsadas’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意元字符的位置，我们必须在“”之前结束贪婪模式，才能达到我们的目的</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 URL 中协议的省略</title>
      <link href="/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/"/>
      <url>/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>前天看了 Google HTML/CSS 代码风格指南，里面有很多值得借鉴的地方，也学到了一些新东西，其中第一条说道，HTML 和 CSS 代码中引用的图片、媒体、CSS 和 JS 文件中的 URL 都可以去掉协议部分（http: 和 https:），比如</p><script src="http://www.google-analytics.com/ga.js" type="text/javascript"></script><script src="https://www.google-analytics.com/ga.js" type="text/javascript"></script><p>都可以换成：</p><script src="//www.google-analytics.com/ga.js" type="text/javascript"></script><p>只要是使用 http、https 这两种协议都可以省略。原因是可以节省一点文件体积（当然只是那么一点点），另外一个原因 Google 说是可以解决混合内容的问题。起初我对这个第二点不是很了解，所以特意搜索了下。最后从 Paul Irish 的一篇文章找到答案，链接在文后。文章是两三年前写的，老外研究问题总是比我们要早啊。</p><p>以 // 开头的叫做相对URL（protocol-relative URL），相关的标准可以看 RFC 3986 Section 4.2，内容不是一般的长估计大家也没耐心去看吧。总之浏览器遇到相对 URL，则会根据当前的网页协议，自动在 // 前面加上相同的协议。如当前网页是 http 访问，那么所有的相对引用 // 都会变成http://。https 同理。如果你在本地查看，协议就会变成 file://。</p><p>所以，如果省略协议，就需要保证引用的外部资源也采用和网页相同的协议，或者保证资源可以同时通过 http 和 https 访问。经过 StackOverflow 网友测试，这种用法几乎所有的浏览器都能支持，只有在 IE7/8 下会有一点小问题，就是通过相对 URL 引用的 CSS 文件（无论 <link> 或 @import）会被下载两遍。所以对性能有一点影响。</p><p>至于 Google 提到的混合内容问题，其实是指IE有时会弹出的一个警告框：</p><p>这个框想必大家也都见过。通常是在浏览 https 网页的时候出现，原因是网页里引用了 http 协议的外部资源，由于 http 被认为是不安全的，IE 才会给出提示。如果引用的时候写成相对 URL，浏览器就会自动采用 https 协议下载，这样就解决了问题。</p><p>所以，我们平时写代码还是可以放心使用相对 URL 的，写博客的大概很少开 https，当然做项目的就例外了。如果你引用的资源里有 https 协议的就特别处理一下，或者只要 http 也能访问到资源就可以。我看了下国内的站点这么用的还不多，有一次看到百度音乐这么用过。不过 Google 很多站点都已经是这样的写法了。</p><hr>> 参考资料：<p><a href="http://paulirish.com/2010/the-protocol-relative-url/">http://paulirish.com/2010/the-protocol-relative-url/</a><br><a href="http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just">http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just</a><br><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><blockquote><p>转载 自：<a href="http://pandacafe.net/post/231?huvqlc=r5eup1">http://pandacafe.net/post/231?huvqlc=r5eup1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http:// </tag>
            
            <tag> https:// </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天气晴-2021-5-20</title>
      <link href="/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/"/>
      <url>/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="今天是2021年5月20日，是个好日子"><a href="#今天是2021年5月20日，是个好日子" class="headerlink" title="今天是2021年5月20日，是个好日子"></a>今天是2021年5月20日，是个好日子</h3><p> 早上打开电脑 撇了下右下角的电脑，是2021/5/20 嗯是个吉利的数字</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百年孤独</title>
      <link href="/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/"/>
      <url>/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><h3 id="家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉"><a href="#家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉" class="headerlink" title="家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉"></a>家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉</h3></blockquote><ul><li>这本书到底讲了什么？作者想表达什么？自己有了什么样的感触<hr></li></ul><h3 id="经典语句"><a href="#经典语句" class="headerlink" title="经典语句"></a>经典语句</h3><p>1、多年以后，奥雷连诺上校站在行刑队面前，准会想起父亲带他去参观冰块的那个遥远的下午。</p><p>2、 过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂热最坚贞的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。</p><p>3、买下一张永久车票，登上一列永无终点的火车。</p><p>4、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>5、生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p><p>6、我确实一度死去，但难以忍受孤独又重返人世。</p><p>7、他渴望孤独，对整个世界的怨恨咬噬着他的内心。</p><p>8、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>9、所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。</p><p>10、这手稿上所写的事情过去不曾，将来也永远不会重复，因为命中注定要一百年处于孤独的世家决不会有出现在世上的第二次机会。</p><h3 id="百年孤独讲述了什么"><a href="#百年孤独讲述了什么" class="headerlink" title="百年孤独讲述了什么"></a>百年孤独讲述了什么</h3><p>《百年孤独》讲的是一个叫布恩迪亚家族百年的兴衰以及小镇马孔多的发展变迁史。</p><p>布恩迪亚家族的每一代人都在努力地摆脱孤独落后的生活状态，但是却一次又一次的失败，最终，家族的最后一个人被蚂蚁吃掉，整个屋子也被风卷走，从此消失在地球上，再未出现。</p><p>孤独会让人丧失对生活的希望。没有人喜欢孤独，布恩迪亚家族的人付出了一辈又一辈的努力，却依然是一场空，书也表现了人类的抗争，对命运的无可奈何以及天性的顽固。</p><h3 id="百年孤独反思"><a href="#百年孤独反思" class="headerlink" title="百年孤独反思"></a>百年孤独反思</h3><p>《百年孤独》是哥伦比亚作家加西亚·马尔克斯的一部长篇小说</p><p>百年孤独比较适合25岁以上，经历过社会的人看。这样才能读出韵味的。</p><p>说到底《百年孤独》好在它的新颖，不仅让人们看到一个不一样的故事，也让人看到了小说不一样的表现手，而且这种不一样的表现手法，被国内许多的作家所借鉴引用。这也就是《百年孤独》的好处。</p><p>可以不客气地说，《百年孤独》影响了中国当代文学的走向，国内许多的作家，正是由于看了这本小说之后，才开始写出了自己最为重要的作品，例如莫言、陈忠实、余华、阎连科等等，这些国内一线作家，那都是受到了《百年孤独》的影响，他们的作品里，都有着《百年孤独》的影子。也正是这一份影响，使得它在国人心目中，有着崇高的地位。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 使用 connot stat</title>
      <link href="/blog/2021/05/17/GIT/cannot%20stat/"/>
      <url>/blog/2021/05/17/GIT/cannot%20stat/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>1.记一次使用bug<br><img src= "/blog/img/loading.gif" data-lazy-src="http://s2-cdn.oneitfarm.com/c71c1444ef7b472fbad9c71ba803fa95.png" alt=""><br>git error: cannot stat<br>原因是因为，在某个编辑器打开了master分支的一个文件，然后切换到feat分支，文件并不消失，拉取时候出现问题，</p><p>解决办法：关掉编辑器</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-析构函数-destruct</title>
      <link href="/blog/2021/05/17/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
      <url>/blog/2021/05/17/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3 id="析构函数destruct"><a href="#析构函数destruct" class="headerlink" title="析构函数destruct"></a>析构函数destruct</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：<strong>construct()在初始化对象的时候默认执行的<br>析构函数：</strong>destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data &#x3D; [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#39;appkey&#39;] &#x3D; getAppkey();</span><br><span class="line">        $data[&#39;channel&#39;] &#x3D; getChannel();</span><br><span class="line">        $this-&gt;data[] &#x3D; $data;</span><br><span class="line">        &#x2F;&#x2F;这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id &#x3D; $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#39;id &lt;&#39; &#x3D;&gt; $id - 50000</span><br><span class="line">            ], &#39;&#39;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend&#x3D;new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-笔记-ArrayMapSlice</title>
      <link href="/blog/2021/05/17/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
      <url>/blog/2021/05/17/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. :&#x3D; &#x3D; &#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">:&#x3D; 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">&#x3D; 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 :&#x3D; make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val :&#x3D; make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">ch :&#x3D; make(chan int, 100) &#x2F;&#x2F; make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据</span><br><span class="line">&#x2F;&#x2F; 并把值赋给 v</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-改善golang50个有效实践</title>
      <link href="/blog/2021/05/14/GOLANG/GOLANG-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
      <url>/blog/2021/05/14/GOLANG/GOLANG-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>闲逛好久go论坛，找到一本适合看的教程，花了点时间将这个文章搬运过来，自己慢慢研读</p></blockquote><h4 id="1-语言的前生今世"><a href="#1-语言的前生今世" class="headerlink" title="1 语言的前生今世"></a>1 <a href="https://smartxia.github.io/blog/book/01Go语言的前生今世慕课专栏.html">语言的前生今世</a></h4><h4 id="2-语言的设计哲学之一简单"><a href="#2-语言的设计哲学之一简单" class="headerlink" title="2 语言的设计哲学之一简单"></a>2 <a href="https://smartxia.github.io/blog/book/02Go语言的设计哲学之一简单慕课专栏.html">语言的设计哲学之一简单</a></h4><h4 id="3-语言的设计哲学之二组合"><a href="#3-语言的设计哲学之二组合" class="headerlink" title="3  语言的设计哲学之二组合"></a>3  <a href="https://smartxia.github.io/blog/book/03Go语言的设计哲学之二组合慕课专栏.html">语言的设计哲学之二组合</a></h4><h4 id="4-Go语言的设计哲学之三并发"><a href="#4-Go语言的设计哲学之三并发" class="headerlink" title="4  Go语言的设计哲学之三并发"></a>4  <a href="https://smartxia.github.io/blog/book/04Go语言的设计哲学之三并发慕课专栏.html">Go语言的设计哲学之三并发</a></h4><h4 id="5-Go-语言的设计哲学之四面向工程"><a href="#5-Go-语言的设计哲学之四面向工程" class="headerlink" title="5  Go 语言的设计哲学之四面向工程"></a>5  <a href="https://smartxia.github.io/blog/book/05Go语言的设计哲学之四面向工程慕课专栏.html">Go 语言的设计哲学之四面向工程</a></h4><h4 id="6-参考-Go-项目布局设计你的项目结构"><a href="#6-参考-Go-项目布局设计你的项目结构" class="headerlink" title="6  参考 Go 项目布局设计你的项目结构"></a>6  <a href="https://smartxia.github.io/blog/book/06参考Go项目布局设计你的项目结构慕课专栏.html">参考 Go 项目布局设计你的项目结构</a></h4><h4 id="7-gofmtGo代码风格的唯一标准"><a href="#7-gofmtGo代码风格的唯一标准" class="headerlink" title="7  gofmtGo代码风格的唯一标准"></a>7  <a href="https://smartxia.github.io/blog/book/07gofmtGo代码风格的唯一标准慕课专栏.html">gofmtGo代码风格的唯一标准</a></h4><h4 id="8-Go-标识符的命名惯例"><a href="#8-Go-标识符的命名惯例" class="headerlink" title="8  Go 标识符的命名惯例"></a>8  <a href="https://smartxia.github.io/blog/book/08Go标识符的命名惯例慕课专栏.html">Go 标识符的命名惯例</a></h4><h4 id="9-变量声明形式尽量保持一致"><a href="#9-变量声明形式尽量保持一致" class="headerlink" title="9  变量声明形式尽量保持一致"></a>9  <a href="https://smartxia.github.io/blog/book/09变量声明形式尽量保持一致慕课专栏.html">变量声明形式尽量保持一致</a></h4><h4 id="10-无类型常量让代码更简化"><a href="#10-无类型常量让代码更简化" class="headerlink" title="10  无类型常量让代码更简化"></a>10  <a href="https://smartxia.github.io/blog/book/10无类型常量让代码更简化慕课专栏.html">无类型常量让代码更简化</a></h4><h4 id="11-Go“枚举常量”的惯用实现方法"><a href="#11-Go“枚举常量”的惯用实现方法" class="headerlink" title="11  Go“枚举常量”的惯用实现方法"></a>11  <a href="https://smartxia.github.io/blog/book/11Go“枚举常量”的惯用实现方法慕课专栏.html">Go“枚举常量”的惯用实现方法</a></h4><h4 id="12-定义“零值可用”的类型"><a href="#12-定义“零值可用”的类型" class="headerlink" title="12  定义“零值可用”的类型"></a>12  <a href="https://smartxia.github.io/blog/book/12定义"零值可用"的类型慕课专栏.html">定义“零值可用”的类型</a></h4><h4 id="13-用复合字面值作初值构造器"><a href="#13-用复合字面值作初值构造器" class="headerlink" title="13  用复合字面值作初值构造器"></a>13  <a href="https://smartxia.github.io/blog/book/13用复合字面值作初值构造器慕课专栏.html">用复合字面值作初值构造器</a></h4><h4 id="14-深入理解和高效运用切片-slice"><a href="#14-深入理解和高效运用切片-slice" class="headerlink" title="14  深入理解和高效运用切片(slice)"></a>14  <a href="https://smartxia.github.io/blog/book/14深入理解和高效运用切片(slice)慕课专栏.html">深入理解和高效运用切片(slice)</a></h4><h4 id="15-注意Go-字符串是原生类型"><a href="#15-注意Go-字符串是原生类型" class="headerlink" title="15  注意Go 字符串是原生类型"></a>15  <a href="https://smartxia.github.io/blog/book/15注意Go字符串是原生类型慕课专栏.html">注意Go 字符串是原生类型</a></h4><h4 id="16-理解包导入路径的含义"><a href="#16-理解包导入路径的含义" class="headerlink" title="16  理解包导入路径的含义"></a>16  <a href="https://smartxia.github.io/blog/book/16理解包导入路径的含义慕课专栏.html">理解包导入路径的含义</a></h4><h4 id="17-init-函数的妙用"><a href="#17-init-函数的妙用" class="headerlink" title="17  init 函数的妙用"></a>17  <a href="https://smartxia.github.io/blog/book/17init函数的妙用慕课专栏.html">init 函数的妙用</a></h4><h4 id="18-Go-函数是“一等公民”"><a href="#18-Go-函数是“一等公民”" class="headerlink" title="18  Go 函数是“一等公民”"></a>18  <a href="https://smartxia.github.io/blog/book/18Go函数是“一等公民”慕课专栏.html">Go 函数是“一等公民”</a></h4><h4 id="19-defer-让你的代码更清"><a href="#19-defer-让你的代码更清" class="headerlink" title="19  defer 让你的代码更清"></a>19  <a href="https://smartxia.github.io/blog/book/19defer让你的代码更清晰慕课专栏.html">defer 让你的代码更清</a></h4><h4 id="20-方法的本质"><a href="#20-方法的本质" class="headerlink" title="20  方法的本质"></a>20  <a href="https://smartxia.github.io/blog/book/20Go方法的本质慕课专栏.html">方法的本质</a></h4><h4 id="21-方法集合决定接口实现"><a href="#21-方法集合决定接口实现" class="headerlink" title="21  方法集合决定接口实现"></a>21  <a href="https://smartxia.github.io/blog/book/21方法集合决定接口实现慕课专栏.html">方法集合决定接口实现</a></h4><h4 id="22-变长参数函数的妙用"><a href="#22-变长参数函数的妙用" class="headerlink" title="22  变长参数函数的妙用"></a>22  <a href="https://smartxia.github.io/blog/book/22变长参数函数的妙用慕课专栏.html">变长参数函数的妙用</a></h4><hr>转载自慕课资源，仅供学习使用，如有侵权联系自行删除]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 书籍 </tag>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他-软件行业高频单词</title>
      <link href="/blog/2021/05/14/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/"/>
      <url>/blog/2021/05/14/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="1-golang高频英语"><a href="#1-golang高频英语" class="headerlink" title="1.golang高频英语"></a>1.golang高频英语</h3><p><strong>并发</strong>：(Concurrency) [kənˈkʌrənsɪ] </p><p><strong>并行</strong>：(Parallelism) [ˈpærəlelɪzəm]  </p><p><strong>摩尔定律</strong>：(Moore’s Law):集成电路上可以容纳的晶体管数目在大约每经过18个月便会增加一倍。换言之，处理器的性能每隔两年翻一倍</p><p><strong>cup主频</strong>：（CPU Clock Speed）:主频即CPU的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了CPU速度的快慢</p><p><strong>时钟频率</strong>：(clock rate):是指同步电路中时钟的基础频率，它以“若干次周期每秒”来度量，量度单位采用SI单位赫兹（Hz）。它是评定CPU性能的重要指标。一般来说主频数字值越大越好。外频，是CPU外部的工作频率，是由主板提供的基准时钟频率。FSB频率，是连接CPU和主板芯片组中的北桥芯片的前端总线（Front Side Bus）上的数据传输频率。CPU的主频和外频间存在这样的关系：主频=外频×倍频。</p><p><strong>pthread</strong>： (线程)<br><strong>kernel</strong> ：（核心）</p><p>好的命名就像一个好笑话。如果你必须解释它，那就不好笑了</p><p><strong>在 Go 语言中 interface 名字仍然以单个词为优先。对于拥有唯一方法 (method) 或通过多个拥有唯一方法的接口组合而成的接口，Go 语言的惯例是一般用 “方法名 + er” 的方式为 interface 命名</strong><br><strong>coined</strong>：创造<br><strong>Syntax</strong>: 语法<br><strong>Semantics</strong>: 语意</p><p>Go 设计者认为隐式转换带来的便利性不足以抵消其带来的诸多问题 1，因此要解决上面的编译错误，我们必须进行显式地转型：</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-概述，为什么要使用设计模式</title>
      <link href="/blog/2021/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2021/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="设计模式（Design-pattern）"><a href="#设计模式（Design-pattern）" class="headerlink" title="设计模式（Design pattern）"></a>设计模式（Design pattern）</h3><blockquote><p>GOF(gong of for)可复用面向对象软件元素</p></blockquote><ul><li>对接口编程而不是对实现编程</li><li>优先使用对象组合而不是继承</li></ul><h3 id="设计模式的类型（23种）"><a href="#设计模式的类型（23种）" class="headerlink" title="设计模式的类型（23种）"></a>设计模式的类型（23种）</h3><p>基本可以分为四大类：</p><ul><li>创建型模式（Creational Patterns）<br>提供一种在创建对象的时候隐藏逻辑方法的形式，而不是直接new一个对象，这使得程序在判断针对某个特定的实例需要创建哪些对象的时候更加灵活。</li><li>结构型模式 (Structural Patterns)<br>关注类和对象组合，集成的概念用来组合接口和定义组合对象 获取新的功能方式</li><li>行为型模式 (Behavioral Patterns)<br>关注对象之间的通信</li><li>j2EE模式<br>这些模式主要由java 中的设计模式提供（Sun Java Center）</li></ul><table><thead><tr><th align="left"></th><th>模式描述</th><th align="center">包括</th></tr></thead><tbody><tr><td align="left">1</td><td>创建型模式</td><td align="center">工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern）</td></tr><tr><td align="left">2</td><td>结构型模式</td><td align="center">适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern）</td></tr><tr><td align="left">3</td><td>行为型模式</td><td align="center">责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern）</td></tr><tr><td align="left">4</td><td>J2ee型模式</td><td align="center">MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h3 id="设计模式-之间关系"><a href="#设计模式-之间关系" class="headerlink" title="设计模式 之间关系"></a>设计模式 之间关系</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg" alt=""></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ol><li><p>开闭原则（Open Close Principle）:<br> <strong>对扩展开放，对修改关闭</strong> ，在程序需要进行扩展的时候，不能去修改原代码，实现一个热拔插的效果。为了的是使程序的扩展性更好，易于维护和升级，我们需要使用接口和抽象类来实现</p></li><li><p>里氏代换原则（Liskow Substitution Priciple）</p><p> 任何基类出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位不受影响的时候，基类才能真正的被附中，而派生类可以在基类中增加新的行为，LSP是对开闭原则的补充。开闭原则关键步骤就是抽象化，基类与子类的继承关系就是抽象化的具体实现，即：对实现抽象化具体步骤的规范</p></li><li><p>依赖倒转原则（Dependence Inversion Priciple）</p><p> 针对接口变成，依赖于抽象而不依赖于具体</p></li><li><p>接口隔离原则（Interface Segregation Priciple）</p><p> 多实用隔离的接口，比使用单个接口更好。降低类之间的耦合度。</p></li><li><p>迪米特法则（Demeter Priciple）</p><p> 最少知道的原则：一个实体应当尽量少跟其他实体之间发生相互的作用，是得系统模块相对</p></li><li><p>合成复用原则（composite Reuse Priciple）</p><p> 尽量使用合成/聚合方式，而不是使用继承</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-Phpfpm进程管理的三种模式</title>
      <link href="/blog/2021/05/10/PHP/PHP-Phpfpm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2021/05/10/PHP/PHP-Phpfpm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-Phpfmp-如何分配任务到子进程的</title>
      <link href="/blog/2021/05/10/PHP/PHP-Phpfmp-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84/"/>
      <url>/blog/2021/05/10/PHP/PHP-Phpfmp-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://blog.csdn.net/liuqun0319/article/details/92573976?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest">https://blog.csdn.net/liuqun0319/article/details/92573976?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-笔记5-gin开发规范</title>
      <link href="/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B05-gin%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B05-gin%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2 id="Go语言Web框架基线版本"><a href="#Go语言Web框架基线版本" class="headerlink" title="Go语言Web框架基线版本"></a>Go语言Web框架基线版本</h2><h3 id="一-框架简介"><a href="#一-框架简介" class="headerlink" title="一.框架简介"></a>一.框架简介</h3><p>此web框架已gin为核心，包含了mysq、redis、rabbitmq、log、es等基础组件。<br>此框架内dockerfile和makefile已适配中台的打镜像流程，一般情况下不需要对这两个文件进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── controller &#x2F;&#x2F;控制器</span><br><span class="line">│   └── v1</span><br><span class="line">├── dao &#x2F;&#x2F;dao层</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   └── redis</span><br><span class="line">├── db &#x2F;&#x2F;mysql文件初始化</span><br><span class="line">├── docs &#x2F;&#x2F;swagger 接口文档</span><br><span class="line">├── middleware &#x2F;&#x2F;中间件</span><br><span class="line">├── model &#x2F;&#x2F;model层</span><br><span class="line">│   ├── mapi</span><br><span class="line">│   ├── mdb</span><br><span class="line">│   ├── mmysql</span><br><span class="line">│   └── mparam</span><br><span class="line">├── pconst &#x2F;&#x2F;常量定义</span><br><span class="line">├── route &#x2F;&#x2F;路由层</span><br><span class="line">│   └── v1</span><br><span class="line">├── script &#x2F;&#x2F;脚本层</span><br><span class="line">│   └── logic</span><br><span class="line">├── server &#x2F;&#x2F;服务启动</span><br><span class="line">├── service &#x2F;&#x2F;业务层</span><br><span class="line">├── tgo &#x2F;&#x2F;基础组件</span><br><span class="line">└── util &#x2F;&#x2F;工具包</span><br><span class="line">    ├── curl</span><br><span class="line">    └── ip</span><br></pre></td></tr></table></figure><h3 id="二-框架分层"><a href="#二-框架分层" class="headerlink" title="二.框架分层"></a>二.框架分层</h3><h4 id="2-1-路由层"><a href="#2-1-路由层" class="headerlink" title="2.1.路由层"></a>2.1.路由层</h4><p>框架采用强路由模式，支持路由群组、中间件模式，自带跨域组件并默认开启，路由文件存放在 route 目录下</p><h4 id="2-2-控制器层"><a href="#2-2-控制器层" class="headerlink" title="2.2.控制器层"></a>2.2.控制器层</h4><p>控制器存放在controller目录下，并区分版本，此层仅针对参数进行过滤处理，不处理相关业务。已集成swagger自动生成接口文档</p><h4 id="2-3-业务层"><a href="#2-3-业务层" class="headerlink" title="2.3.业务层"></a>2.3.业务层</h4><p>业务层存放在service目录下，用来处理业务相关的逻辑</p><h4 id="2-4-数据处理层"><a href="#2-4-数据处理层" class="headerlink" title="2.4.数据处理层"></a>2.4.数据处理层</h4><p>业务层存放在dao目录下，并根据下游不同服务放入不同目录下，此层仅处理数据，不处理业务相关逻辑</p><h4 id="2-5-对象层"><a href="#2-5-对象层" class="headerlink" title="2.5.对象层"></a>2.5.对象层</h4><p>对象层存放在mode目录下，并根据对象的不同类型存放下级不同目录</p><h4 id="2-6-中间件层"><a href="#2-6-中间件层" class="headerlink" title="2.6.中间件层"></a>2.6.中间件层</h4><p>中间件层存放在middleware目录下，用以对同一分组或具有相同特征的路由进行全局业务处理</p><h4 id="2-7-脚本层"><a href="#2-7-脚本层" class="headerlink" title="2.7.脚本层"></a>2.7.脚本层</h4><p>脚本层存放在script目录下，用以处理非http类型的业务类型</p><h4 id="2-8-常量层"><a href="#2-8-常量层" class="headerlink" title="2.8.常量层"></a>2.8.常量层</h4><p>常量定义存放在pconst目录下</p><h3 id="三-整体流程"><a href="#三-整体流程" class="headerlink" title="三.整体流程"></a>三.整体流程</h3><p>框架整体请求请求流程为route - middleware - controller - service - dao，控制器、业务、数据处理禁止逆向调用</p><h3 id="四-请求示例"><a href="#四-请求示例" class="headerlink" title="四.请求示例"></a>四.请求示例</h3><p>参考控制器下 log_platform.go 文件</p><h3 id="五-中台服务间调用"><a href="#五-中台服务间调用" class="headerlink" title="五.中台服务间调用"></a>五.中台服务间调用</h3><blockquote><p>gosdk使用和服务间调用有问题和建议可以联系联系基础架构部：张超</p></blockquote><p>中台服务间调用通过<a href="https://gitlab.oneitfarm.com/bifrost/gosdk">gosdk</a>进行调用，gosdk如何使用可以参考服务内的readme文档。 </p><p>为了降低使用成本，我们对gosdk进行了一次封装<a href="https://gitlab.oneitfarm.com/ci123sdk/requester">requester</a>包，并提供了一个案例<a href="https://gitlab.oneitfarm.com/ci123sdk/account">account</a>服务的接口封装。</p><p>【强烈建议】：对子服务（比如A）的调用封装成单独的包，并在gitlab.oneitfarm.com/ci123sdk group下创建项目A，将服务A的接口调用封装。这样其他项目（人）在接入A项目时，不需要再重复封装此部分内容。<br>简单来说就是每个服务在ci123sdk的group下创建项目，后续所有对此服务调用的封装都在此项目中，所有引用此服务的服务或应用，只需要引用此包进行开发，如果支持接口不全就在此项目中完善并打新的tag增加版本。</p><h3 id="六-关于PR"><a href="#六-关于PR" class="headerlink" title="六.关于PR"></a>六.关于PR</h3><p>有任何疑问或者建议，欢迎随时联系基础架构部：陶圣，也欢迎各位提交有价值的PR，也将纳入年终绩效考核一部分</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> farmworker </tag>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能库zap gox</title>
      <link href="/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B04-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%93zap/"/>
      <url>/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B04-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%93zap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2 id="zap"><a href="#zap" class="headerlink" title="zap"></a>zap</h2><p>高性能日志库分析</p><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>##GOX<br>交叉编译工具可以编译各种的环境<br>go get github.com/mitchellh/gox<br>gox -build-toolchain</p><p>直接运行gox。程序会一口气生成17个文件<br>横跨windows,linux,mac,freebsd,netbsd五大操作系统<br>#####固定平台<br>gox -osarch “windows/amd64 linux/amd64” 或<br>        gox -os “windows linux” -arch amd64</p><h4 id="go-mod-init-命令"><a href="#go-mod-init-命令" class="headerlink" title="go mod init 命令"></a>go mod init 命令</h4><p>go.sum是一个模块版本内容的校验值，用来验证当前缓存的模块。go.sum包含了直接依赖和间接依赖的包的信息，比go.mod要多一些。</p><h4 id="查看依赖包"><a href="#查看依赖包" class="headerlink" title="查看依赖包"></a>查看依赖包</h4><p>go list -m all</p><h4 id="模块配置文本格式化"><a href="#模块配置文本格式化" class="headerlink" title="模块配置文本格式化"></a>模块配置文本格式化</h4><p>go mod edit -fmt</p><h4 id="Windows-下开启-GO111MODULE-的命令为："><a href="#Windows-下开启-GO111MODULE-的命令为：" class="headerlink" title="Windows 下开启 GO111MODULE 的命令为："></a>Windows 下开启 GO111MODULE 的命令为：</h4><p>set GO111MODULE=on 或者 set GO111MODULE=auto</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>GOPROXY=<a href="https://goproxy.cn,direct">https://goproxy.cn,direct</a></p><h4 id="以索引整个-GOPATH"><a href="#以索引整个-GOPATH" class="headerlink" title="以索引整个 GOPATH"></a>以索引整个 GOPATH</h4><p>.Preferences -&gt; Go -&gt; GOPATH，勾选上 Index entire GOPATH</p><hr><h4 id="基础命令关于module的"><a href="#基础命令关于module的" class="headerlink" title="基础命令关于module的"></a>基础命令关于module的</h4><p>go mod download<br>go mod download -json 参数会以JSON的格式打印下载的模块对象<br /><br>go mod tidy<br>go mod tidy -v  可以将执行的信息<br>可以使用go mod tidy命令来清除它<br /><br>go mod vendor<br>go mod vendor -v会将添加到vendor中的模块打印到标准输出。<br>go mod graph<br /><br>打印模块依赖图</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> zap </tag>
            
            <tag> gox </tag>
            
            <tag> module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近太懒了</title>
      <link href="/blog/2021/04/29/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/"/>
      <url>/blog/2021/04/29/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p> 自定义支持markdown只会让我的VsCode越来越卡</p><p>#<br>技术性不强但是打字还慢无语了，这个打字的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br></pre></td></tr></table></figure> <hr><p><br>强行换行</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-解决循环内存占用溢出-缓冲查询</title>
      <link href="/blog/2020/09/02/PHP/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/"/>
      <url>/blog/2020/09/02/PHP/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-深拷贝浅拷贝-_clone</title>
      <link href="/blog/2020/09/02/PHP/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/blog/2020/09/02/PHP/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ul><li>深拷贝//变量复制了一份传递给另一个变量就是深拷贝,一个值改变了,另一个值不会变（直接复制）</li></ul><ul><li>浅拷贝//变量之间的值是地址*|&amp;传递,这就是浅拷贝.值如果改变了两个变量的值都会改变 （引用复制，可变）</li></ul><blockquote><p>关键次 _clone</p></blockquote><ul><li>对象赋值：浅拷贝</li><li>普通类型的变量是深拷贝</li></ul><h4 id="php默认浅拷贝即普通赋值"><a href="#php默认浅拷贝即普通赋值" class="headerlink" title="php默认浅拷贝即普通赋值"></a>php默认浅拷贝即普通赋值</h4><blockquote><p>例1：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Persion</span><br><span class="line">&#123;</span><br><span class="line">public $age &#x3D; 0;</span><br><span class="line">public $name &#x3D; &#39;xiapeifus&#39;;</span><br><span class="line">public $obj &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">$persion &#x3D; new Persion();</span><br><span class="line">$xiaoming &#x3D; clone $persion; &#x2F;&#x2F;使用clone关键字复制一份$a的值,进行深拷贝.拷贝之后不会改变$a之前的值</span><br><span class="line">$xiaoming-&gt;age &#x3D; 1;</span><br><span class="line">var_dump($persion-&gt;age);&#x2F;&#x2F; 0</span><br><span class="line">var_dump($xiaoming-&gt;age);&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><blockquote><p>//例2：增加__clone对象的赋值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class doclone&#123;</span><br><span class="line">    private $id,$name,$address;</span><br><span class="line">    public function __construct($id&#x3D;0,$name&#x3D;&#39;&#39;,$address&#x3D;&#39;&#39;)&#123;</span><br><span class="line">        $this-&gt;name&#x3D;$name;</span><br><span class="line">        $this-&gt;id&#x3D;$id;</span><br><span class="line">        $this-&gt;address&#x3D;$address;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_id()&#123;</span><br><span class="line">        return $this-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_name()&#123;</span><br><span class="line">        return $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_address()&#123;</span><br><span class="line">        return $this-&gt;address;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __clone()&#123;</span><br><span class="line">        $this-&gt;id&#x3D;$this-&gt;id+1;</span><br><span class="line">        $this-&gt;name&#x3D;&#39;wqw&#39;;</span><br><span class="line">        $this-&gt;address&#x3D;&#39;USA&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$A &#x3D; new doclone(1,&#39;xiapeifu&#39;,&#39;UK&#39;);</span><br><span class="line">echo &#39;克隆之前的对象:&#39;;</span><br><span class="line">echo &#39;id&#x3D;&#39;.$A-&gt;get_id();</span><br><span class="line">echo &#39;name&#x3D;&#39;.$A-&gt;get_name();</span><br><span class="line">echo &#39;address&#x3D;&#39;.$A-&gt;get_address();</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$B &#x3D; clone $A;</span><br><span class="line">echo &#39;克隆过后的对象：&#39;;</span><br><span class="line">echo &#39;id&#x3D;&#39;.$A-&gt;get_id();</span><br><span class="line">echo &#39;name&#x3D;&#39;.$A-&gt;get_name();</span><br><span class="line">echo &#39;address&#x3D;&#39;.$A-&gt;get_address();</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">echo &#39;克隆过后的对象属性:&#39;;</span><br><span class="line">echo &#39;id&#x3D;&#39;.$B-&gt;get_id();</span><br><span class="line">echo &#39;name&#x3D;&#39;.$B-&gt;get_name();</span><br><span class="line">echo &#39;address&#x3D;&#39;.$B-&gt;get_address();</span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">&#x2F;&#x2F;克隆之前的对象:id&#x3D;1name&#x3D;xiapeifuaddress&#x3D;UK</span><br><span class="line">&#x2F;&#x2F;克隆过后的对象：id&#x3D;1name&#x3D;xiapeifuaddress&#x3D;UK</span><br><span class="line">&#x2F;&#x2F;克隆过后的对象属性:id&#x3D;2name&#x3D;wqwaddress&#x3D;USA</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>思考：colne 关键词 当对象没<strong>colne 方法时候类似于new 一个对象出来没区别<br>        当对象有</strong>clone时候会在clone里面的重新赋值新的属性，类似于重新new 一个对象 ，只不过把重新new的对象进行一些默认操作，其实重新new一个对象重新赋值也一样，clone可能就是单纯炫技吧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git-代码提交规范</title>
      <link href="/blog/2020/09/02/GIT/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
      <url>/blog/2020/09/02/GIT/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Git commit message 是Git提交的必要信息，message的信息完整度也反映了工程师对于代码提交的重视程度，不清晰的git message信息甚至会让工程师完全回忆不起自己当初做了什么调整，导致后续代码维护成本特别大。因此为了提高线上代码库的管理程度，特此制定GIT commit message规范。</p><p>一、commit message格式<br>1、Type(必须)<br>用于说明 git commit 的类别，只允许使用下面的标识。<br>feat：新功能（feature）。<br>fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。<br>fix：产⽣diff并自动修复此问题。适合于一次提交直接修复问题<br>to：只产⽣diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix<br>docs：文档（documentation）。<br>style：格式（不影响代码运行的变动）。<br>refactor：重构（即不是新增功能，也不是修改bug的代码变动）。<br>perf：优化相关，比如提升性能、体验。<br>test：增加测试。<br>chore：构建过程或辅助工具的变动。<br>revert：回滚到上一个版本。<br>merge：代码合并。<br>sync：同步主线或分⽀的Bug</p><p>2、scope(可选)<br>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。<br>例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。<br>如果你的修改影响了不止一个scope，你可以使用*代替。</p><p>3、subject(必须)<br>subject是commit目的的简短描述，不超过50个字符。<br>1.建议使用中文。<br>2.结尾不加句号或其他标点符号。<br>根据以上规范 git commit message 将是如下的格式：<br>fix(DAO): 用户查询缺少username属性<br>feat(Controller): 用户查询接口开发</p><p>二、规范的好处<br>我们这样规范git commit到底有哪些好处呢？<br>1.便于程序员对提交历史进行追溯，了解发⽣了什么情况。<br>2.一旦约束了commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个git commit里面，这样一来整个代码改动的历史也将更加清晰。<br>3.格式化的commit message才可以用于自动化输出Change log。</p><p>三、标准执行监管<br>为了更好的执行标准，公司针对git提交会进行相关监管功能的研发，当工程师提了不合规的commit，会收到相关的邮件警告。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端-npm私有源加载平台</title>
      <link href="/blog/2020/09/01/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
      <url>/blog/2020/09/01/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="调研平台：sinopia，Verdaccio"><a href="#调研平台：sinopia，Verdaccio" class="headerlink" title="调研平台：sinopia，Verdaccio"></a>调研平台：sinopia，Verdaccio</h3><h4 id="Verdaccio"><a href="#Verdaccio" class="headerlink" title="Verdaccio"></a>Verdaccio</h4><h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><p><a href="https://verdaccio.org/docs/en/configuration">https://verdaccio.org/docs/en/configuration</a></p><p>搭建：</p><h5 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h5><p>身份验证与您正在使用的auth <a href="https://verdaccio.org/docs/en/plugins">插件相关</a>。软件包限制也由<a href="https://verdaccio.org/docs/en/packages">Package Access</a>处理。</p><p>客户端：基于npm客户端登录后会生成一个配置令牌，在.npmrc中</p><p><a href="https://docs.npmjs.com/files/npmrc">https://docs.npmjs.com/files/npmrc</a></p><p>且允许匿名发布包</p><p>包发布的时候允许阻止访问和下载</p><p>服务端关于组的验证:</p><p>​    access: $all-&gt;<br>​    publish: $all<br>​    proxy: npmjs</p><p><img src= "/blog/img/loading.gif" data-lazy-src="//s2-cdn.oneitfarm.com/186bdf368bd54a57b12eb71ba2e10636.png" alt="image-20200901175328057"></p><p> 不同的包读取权限限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">packages:</span><br><span class="line">  <span class="string">&#x27;jquery&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $all</span><br><span class="line">  <span class="string">&#x27;my-company-*&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">  <span class="string">&#x27;@my-local-scope/*&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">    proxy: npmjs</span><br></pre></td></tr></table></figure><p>组 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;company-*&#39;:</span><br><span class="line">  access: admin internal</span><br><span class="line">  publish: admin</span><br><span class="line">  proxy: server1</span><br><span class="line">&#39;supersecret-*&#39;:</span><br><span class="line">  access: secret super-secret-area ultra-secret-area</span><br><span class="line">  publish: secret ultra-secret-area</span><br><span class="line">  proxy: server1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>其他-CRLF、CR、LF详解</title>
      <link href="/blog/2020/09/01/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2020/09/01/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>很长一段时间里，对于CRLF、CR、LF的理解仅限于不同操作系统下对换行符的定义。所谓知其然需知其所以然，从学习中找到乐趣，对知识的记忆才会更加深刻。</p><p>名词解释<br>CR：Carriage Return，对应ASCII中转义字符\r，表示回车<br>LF：Linefeed，对应ASCII中转义字符\n，表示换行<br>CRLF：Carriage Return &amp; Linefeed，\r\n，表示回车并换行<br>众所周知，Windows操作系统采用两个字符来进行换行，即CRLF；Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行；另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。</p><p>野史<br>老式机械打字机（来源：视觉中国）<br>据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。</p><p>当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。</p><p>随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。</p><p>结论<br>许多现代的文本编辑器和命令行工具都提供了可选择的换行符配置，方便用户按照自己的意愿来改变换行符的表现形式，所以我们只需要知道CRLF、CR、LF的作用即可。</p><p>参考文献<br><a href="http://en.wikipedia.org/wiki/Newline">http://en.wikipedia.org/wiki/Newline</a><br><a href="https://en.wikipedia.org/wiki/Control_character">https://en.wikipedia.org/wiki/Control_character</a><br><a href="https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types">https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types</a></p><p>作者：JSoon<br>链接：<a href="https://www.jianshu.com/p/b03ad01acd69">https://www.jianshu.com/p/b03ad01acd69</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于blog更新周期</title>
      <link href="/blog/2020/08/31/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/"/>
      <url>/blog/2020/08/31/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>每周 三篇基础知识文档编写</p><p>每两周一次总结工作情况</p><p>每月一次的软件使用教程记录</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-辅助函数</title>
      <link href="/blog/2020/08/28/PHP/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2020/08/28/PHP/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-匿名类匿名函数（闭包）</title>
      <link href="/blog/2020/08/28/PHP/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/"/>
      <url>/blog/2020/08/28/PHP/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4 id="1-写一个匿名函数"><a href="#1-写一个匿名函数" class="headerlink" title="1.写一个匿名函数"></a>1.写一个匿名函数</h4><blockquote><p>类中 的写法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = array_reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$result</span>, <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array_merge(<span class="variable">$result</span>, array_values(<span class="variable">$value</span>));</span><br><span class="line">        &#125;, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将匿名函数交个一个变量</span></span><br><span class="line">        <span class="variable">$a</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$result</span>, <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array_merge(<span class="variable">$result</span>, array_values(<span class="variable">$value</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable">$result</span> = array_reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], <span class="variable">$a</span>, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-理解一个闭包（匿名函数）"><a href="#2-理解一个闭包（匿名函数）" class="headerlink" title="2.理解一个闭包（匿名函数）"></a>2.理解一个闭包（匿名函数）</h4><p>目前php用到闭包的数组函数包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">array_map — 为数组的每个元素应用回调函数</span><br><span class="line">array_walk — 使用用户自定义函数对数组中的每个元素做回调处理</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">array_filter — 用回调函数过滤数组中的单元</span><br><span class="line">该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回结果数组中。数组键名保持不变。</span><br><span class="line">array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引</span><br><span class="line">array_intersect_ukey — 用回调函数比较键名来计算数组的交集</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">拼接成类似 (1,2,3,4,5) </span><br><span class="line"></span><br><span class="line">array_walk_recursive — 对数组中的每个成员递归地应用用户函数</span><br><span class="line">----等等</span><br><span class="line">常用的就是: array_map array_walk</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-临时总结"><a href="#3-临时总结" class="headerlink" title="3.临时总结"></a>3.临时总结</h4><p><strong>异同点</strong><br> array_filter() 重点在于过滤（而不是新增）某个元素，当你处理到一个元素时，返回过滤后的数组<br> array_map() 重点在于遍历一个数组或多个数组的元素，返回一个新的数组<br> array_walk() 重点在于遍历数组进行某种操作</p><p> array_filter() 和 array_walk()对一个数组进行操作，数组参数在前，函数参数在后<br> array_map() 可以处理多个数组，因此函数参数在前，数组参数在后，可以根据实际情况放入多个数组参数</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Closure </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 匿名类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-运行模式cli fastcgi</title>
      <link href="/blog/2020/08/28/PHP/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/08/28/PHP/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>　　<strong>1.cgi全称“通用网关接口”(Common Gateway Interface)， 它可以让一个客户端，从浏览器向Web服务器上的程序请求数据，是客户端和程序之间传输数据的一种标准，另外CGI独立于任何语言，所以可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。CGI针对每个用户请求都要开单独的子进程去维护，执行结束处理掉这个进程。典型的fork-and-execute方式</strong></p><p>　　<strong>2.fastcgi，根据1中cgi的特性，可以知道消耗很大，如果很多用户请求，则会申请很多个子进程。。这时候出现了FastCGI。FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。这个是当下用的最多的了。。linux+nginx+php+mysql</strong></p><p>　FastCGI的工作原理是：</p><p><em>(1)、Web Server启动时载入FastCGI进程管理器【PHP的FastCGI进程管理器是PHP-FPM(php-FastCGI Process Manager)】（nginx);</em><br><em>(2)、FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自WebServer的连接。</em><br><em>(3)、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</em><br><em>(4)、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。在正常的CGI模式中，php-cgi或 .exe在此便退出了。</em><br><em>在CGI模式中，你可以想象 CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</em><br>　　<em>3.module形式一般用于apache，模块模式是以mod_php5模块的形式集成，此时mod_php5模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求，然后将处理后的结果返回给Apache。</em><br>　　<em>4.cli模式。命令行执行php，一般不用。我们在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式；也可以直接命令行执行php xxx.php</em></p><h4 id="1-php一共分为五大运行模式：包括ducgi-、fast-cgi、cli、isapi、apache-模块的-DLLCGI"><a href="#1-php一共分为五大运行模式：包括ducgi-、fast-cgi、cli、isapi、apache-模块的-DLLCGI" class="headerlink" title="1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI"></a>1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI</h4><p>  关于PHP目前比较常见的五大运行模式：</p><p>1）CGI（通用网关接口/ Common Gateway Interface）<br>2）FastCGI（常驻型CGI / Long-Live CGI）<br>3）CLI（命令行运行 / Command Line Interface）<br>4）LoadModule（Apache独有）：<br>在Apache配置文件httpd.conf里，通常加的LoadModule php7_module “D:/…/php71/php7apache2_4.dll”起到的作用就是这个<br>5）ISAPI（Internet Server Application Program Interface）<br>IIS独有：<br>备注：在PHP5.3以后，PHP不再有ISAPI模式，安装后也不再有php5isapi.dll这个文件。要在IIS6上使用高版本PHP，必须安装FastCGI 扩展，然后使IIS6支持FastCGI。  </p><h3 id="2、php-cli-与php-fpm（fastcgi-process-manager）"><a href="#2、php-cli-与php-fpm（fastcgi-process-manager）" class="headerlink" title="2、php-cli 与php-fpm（fastcgi process manager）"></a>2、php-cli 与php-fpm（fastcgi process manager）</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190420173441325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbnFpYW45OTk=,size_16,color_FFFFFF,t_70" alt="[**CGI、FastCGI和PHP-FPM关系图解**](https://www.awaimai.com/371.html)"></p><p>cli 模式就是常见的命令使用的php命令，其实他也可以提供http请求服务，内置了http服务器<br>fpm 是一个多进程架构的FastCgi 服务，内置PHP解释器进程常驻后台，自带进程管理支持进程池配置和配置Nginx使用</p><p>cli 和fpm 是两个运行方式 </p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cgi </tag>
            
            <tag> fastcgi </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-理解php的Generator,yield,Iterator接口</title>
      <link href="/blog/2020/08/28/PHP/PHP-%E7%90%86%E8%A7%A3php%E7%9A%84Generator,yield,Iterator%E6%8E%A5%E5%8F%A3/"/>
      <url>/blog/2020/08/28/PHP/PHP-%E7%90%86%E8%A7%A3php%E7%9A%84Generator,yield,Iterator%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新<br>yield<br>解决读取大文</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Generator </tag>
            
            <tag> yield </tag>
            
            <tag> Iterator - 等待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他-server酱打卡网易云</title>
      <link href="/blog/2020/08/26/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-Server%E9%85%B1%E6%89%93%E5%8D%A1%E7%BD%91%E6%98%93%E4%BA%91%20%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/blog/2020/08/26/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-Server%E9%85%B1%E6%89%93%E5%8D%A1%E7%BD%91%E6%98%93%E4%BA%91%20%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易云 server酱 py 云函数  待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-info</title>
      <link href="/blog/2020/08/20/DOCKER/Docker-%E5%88%B6%E4%BD%9C-1/"/>
      <url>/blog/2020/08/20/DOCKER/Docker-%E5%88%B6%E4%BD%9C-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4 id="注册登录"><a href="#注册登录" class="headerlink" title="注册登录"></a>注册登录</h4><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h4 id="Docker快捷键"><a href="#Docker快捷键" class="headerlink" title="Docker快捷键"></a>Docker快捷键</h4><blockquote><p>常用： start restart stop  images ps-a</p></blockquote><h5 id="带有参数的使用"><a href="#带有参数的使用" class="headerlink" title="带有参数的使用"></a>带有参数的使用</h5><p>docker ps -a ：查看最近使用的容器id</p><p>docker rm 容器id:删除某个容器</p><p>docker images</p><p>docker rmi 镜像id:删除某个镜像</p><p>docker run :</p><p>docker run -d -p 9200:9200 -p 5601:5601 nshou/elasticsearch-kibana</p><blockquote><p>-d 后台运行，-p 内部端口/宿主机端口 容器id</p></blockquote><p>docker exec -it /bash :进入容器</p><p>docker login -u xx -p xxx：登录</p><h4 id="配置加速源"><a href="#配置加速源" class="headerlink" title="配置加速源"></a>配置加速源</h4><p>1.阿里云：百度如何通过阿里云加速docker拉取和推送速度</p><p>2.DaoCloud ：大公司，国内的。网站：<a href="https://www.daocloud.io/mirror">https://www.daocloud.io/mirror</a></p><blockquote><p>加速url</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux:curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><p>原理：编辑   /etc/docker/daemon.json  这个文件夹</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;f1361db2.m.daocloud.io&quot;,&quot;https:&#x2F;&#x2F;vbw6t0eb.mirror.aliyuncs.com&quot;]&#125;</span><br></pre></td></tr></table></figure><h4 id="查看当前docker配置文件"><a href="#查看当前docker配置文件" class="headerlink" title="查看当前docker配置文件"></a>查看当前docker配置文件</h4><p>docker info :可以查看是否配置成功加速 版本信息等各种信息</p><h4 id="打包镜像源和推送到docker-io"><a href="#打包镜像源和推送到docker-io" class="headerlink" title="打包镜像源和推送到docker.io"></a>打包镜像源和推送到docker.io</h4><p>1.docker pull xxx镜像:tag</p><p>2.docker images 查看镜像</p><p>3.docker run -d -p 8080:8081 xxx镜像:version</p><p>4.docker ps -a 查看是不是启动了，然后stop start restart 找找感觉</p><p>5.docker exec -it 镜像id bash :进入镜像进行修改：拉代码，查bug ,增加mysql实例等</p><p>6.docker commit -m “php71-daemon:xhprof-graphviz” -a “some” f69187b4375e “18260356308/php71-daemon:xhprof”</p><p>​    docker commit -m “提交log” -a “作者”  容器id “docker账户名/自定义镜像名：tag” 就会制作成一个新的image了</p><p>7.执行docker push xxx镜像的id：</p><blockquote><p>tips:</p><p>前提是得登录，还有  注意一个问题,给自己镜像命名的时候格式应该是: docker注册用户名/镜像名,比如我的docker用户名为 test123,那么我的镜像tag就为 test123/whalesay,不然是push不上去的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DOCKER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docekr images </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-xhprof-性能优化</title>
      <link href="/blog/2020/08/20/PHP/PHP-xhprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2020/08/20/PHP/PHP-xhprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><hr><h3 id="嵌入代码"><a href="#嵌入代码" class="headerlink" title="嵌入代码"></a>嵌入代码</h3><hr><h3 id="查看分析报告"><a href="#查看分析报告" class="headerlink" title="查看分析报告"></a>查看分析报告</h3><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>Function Name：方法名称。</p><p>Calls：方法被调用的次数。</p><p>Calls%：方法调用次数在同级方法总数调用次数中所占的百分比。</p><p>Incl.Wall Time(microsec)：方法执行花费的时间，包括子方法的执行时间。（单位：微秒）</p><p>IWall%：方法执行花费的时间百分比。</p><p>Excl. Wall Time(microsec)：方法本身执行花费的时间，不包括子方法的执行时间。（单位：微秒）</p><p>EWall%：方法本身执行花费的时间百分比。</p><p>Incl. CPU(microsecs)：方法执行花费的CPU时间，包括子方法的执行时间。（单位：微秒）</p><p>ICpu%：方法执行花费的CPU时间百分比。</p><p>Excl. CPU(microsec)：方法本身执行花费的CPU时间，不包括子方法的执行时间。（单位：微秒）</p><p>ECPU%：方法本身执行花费的CPU时间百分比。</p><p>Incl.MemUse(bytes)：方法执行占用的内存，包括子方法执行占用的内存。（单位：字节）</p><p>IMemUse%：方法执行占用的内存百分比。</p><p>Excl.MemUse(bytes)：方法本身执行占用的内存，不包括子方法执行占用的内存。（单位：字节）</p><p>EMemUse%：方法本身执行占用的内存百分比。</p><p>Incl.PeakMemUse(bytes)：Incl.MemUse峰值。（单位：字节）</p><p>IPeakMemUse%：Incl.MemUse峰值百分比。</p><p>Excl.PeakMemUse(bytes)：Excl.MemUse峰值。单位：（字节）</p><p>EPeakMemUse%：Excl.MemUse峰值百分比。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xhprof docker push </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-笔记-ArrayMapSlice</title>
      <link href="/blog/2020/06/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B02-ArrayMapSlice/"/>
      <url>/blog/2020/06/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B02-ArrayMapSlice/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4 id="1-golang-数据类型"><a href="#1-golang-数据类型" class="headerlink" title="1.golang 数据类型"></a>1.golang 数据类型</h4><p>1、基本数据类型：整形、浮点、布尔、字符串、字符<br>2、复合数据类型：函数与指针、数组、切片、map、list、结构体、通道</p><h4 id="1-1-函数与指针"><a href="#1-1-函数与指针" class="headerlink" title="1.1 函数与指针"></a>1.1 函数与指针</h4><p>函数：func（）<br>指针：* 代表指针 &amp; 去地址符 （引用传值）</p><p>*可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 , 也就是这个地址所存储的值 .<br>打印 *类型数据获取的一堆2进制数据</p><p>&amp;对变量取地址 即取得某个变量的地址 , 如 ; &amp;a</p><h4 id="1-2数组"><a href="#1-2数组" class="headerlink" title="1.2数组"></a>1.2数组</h4><p>Array(数组)<br>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p><ul><li>数组所有 的key 都是int 默认从0 开始，string类型的是map和list其他，不建议使用数组，一般直接上切片</li><li>var 变量名 [数组长度]数据类型<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a [4]int</span><br><span class="line">println(a)</span><br><span class="line">d :&#x3D; [3]int&#123;1, 2, 4&#125;</span><br><span class="line">println(d)</span><br><span class="line">f :&#x3D; [...]int&#123;1, 2, 4, 5, 6&#125; &#x2F;&#x2F;... 省略数组长度 自动计算</span><br><span class="line">println(f)</span><br><span class="line"></span><br><span class="line">a2 :&#x3D; [...]int&#123;1, 2, 4: 5, 6&#125;</span><br><span class="line">println(a2)</span><br><span class="line">for key, val :&#x3D; range a2 &#123;</span><br><span class="line">println(key,val)</span><br><span class="line">&#125;</span><br><span class="line"> &#x2F;&#x2F; 二维数组赋值 </span><br><span class="line">var arrayarr &#x3D; [3][4]int&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;&#125;</span><br><span class="line">dd :&#x3D; [...][...]string&#123;</span><br><span class="line">&#123;&quot;3&quot;, &quot;4&quot;&#125;,</span><br><span class="line">&#123;&quot;c&quot;, &quot;2&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">println(dd)</span><br><span class="line">println(arrayarr)</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li>补充一个很恶心的代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;补充一种确定下标的数组声明及定义方式：</span><br><span class="line">func testArray04()&#123;</span><br><span class="line">&#x2F;&#x2F;a1数组下标0的没有定义，默认为0，下标1的是2，下标2的是3，</span><br><span class="line">a1 :&#x3D; [...]int&#123;2:3,1:2&#125; &#x2F;&#x2F;这边的2 是key 打印按照key来打印</span><br><span class="line">fmt.Println(a1)      &#x2F;&#x2F;[0 2 3]</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;a2数组下标4定义为5，之前下标2和3未定义，默认为0</span><br><span class="line">a2 :&#x3D; [...]int&#123;1,2,4:5,6&#125;</span><br><span class="line">fmt.Println(a2)      &#x2F;&#x2F;[1 2 0 0 5 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-Map-集合"><a href="#1-3-Map-集合" class="headerlink" title="1.3 Map(集合)"></a>1.3 Map(集合)</h4>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。<br>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</li></ul><p>声明： m := make(map[string]string)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ff :&#x3D; map[string]string&#123;</span><br><span class="line">&quot;a&quot;: &quot;c&quot;,</span><br><span class="line">&#125;</span><br><span class="line"> var keys []string</span><br><span class="line">  for k :&#x3D; range m &#123;</span><br><span class="line">    keys &#x3D; append(keys, k) &#x2F;&#x2F;append  直接在切片级别进行描述</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">for s, s2 :&#x3D; range ff &#123;</span><br><span class="line">println(s,s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ff :&#x3D; map[string]string&#123;</span><br><span class="line">&quot;a&quot;: &quot;c&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fff:&#x3D;make(map[string]int) &#x2F;&#x2F;直接声明不加参数</span><br><span class="line">ff[&quot;cc&quot;]&#x3D;&quot;cccc&quot;;&#x2F;&#x2F;赋值</span><br><span class="line">delete(ff,&quot;cc&quot;)</span><br></pre></td></tr></table></figure><h4 id="1-4切片"><a href="#1-4切片" class="headerlink" title="1.4切片"></a>1.4切片</h4><h4 id="1-5-结构体"><a href="#1-5-结构体" class="headerlink" title="1.5 结构体"></a>1.5 结构体</h4><p>定义切片:<br>你可以声明一个未指定大小的数组来定义切片：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier []type&#x2F;&#x2F;未定义大小的数组即切片</span><br></pre></td></tr></table></figure><p>或使用 make() 函数来创建切片:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice1 :&#x3D; make([]type, len)  &#x2F;&#x2F;make([]T, length, capacity)</span><br></pre></td></tr></table></figure><p>append  和copy 浅拷贝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers []int</span><br><span class="line">numbers &#x3D; append(numbers, 0)&#x2F;&#x2F;append追加</span><br><span class="line">  &#x2F;* 同时添加多个元素 *&#x2F;</span><br><span class="line">numbers &#x3D; append(numbers, 2,3,4)</span><br><span class="line"> &#x2F;* 拷贝 numbers 的内容到 numbers1 *&#x2F;</span><br><span class="line">copy(numbers1,numbers)</span><br></pre></td></tr></table></figure><h4 id="1-6-List（链表）"><a href="#1-6-List（链表）" class="headerlink" title="1.6 List（链表）"></a>1.6 List（链表）</h4><p>遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 声明链表</span><br><span class="line">l :&#x3D; list.New()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据添加到尾部</span><br><span class="line">l.PushBack(4)</span><br><span class="line">l.PushBack(5)</span><br><span class="line">l.PushBack(6)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 遍历</span><br><span class="line">for e :&#x3D; l.Front(); e !&#x3D; nil; e &#x3D; e.Next() &#123;</span><br><span class="line">     fmt.Printf(&quot;%v\n&quot;, e.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> l :&#x3D; list.New()</span><br><span class="line"> l.PushBack(4)</span><br><span class="line"> six :&#x3D; l.PushBack(6)</span><br><span class="line"> l.Remove(six) &#x2F;&#x2F; 删除6这个节点</span><br></pre></td></tr></table></figure><h4 id="1-6-通道"><a href="#1-6-通道" class="headerlink" title="1.6 通道"></a>1.6 通道</h4><p> 其他文章会有详细讲述</p><h4 id="2总结"><a href="#2总结" class="headerlink" title="2总结"></a>2总结</h4><p>数组是 slice 和 map 的底层结构。<br>slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。<br>内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。<br>slice 有容量的约束，不过可以通过内建函数 append 来增加元素。<br>map 没有容量一说，所以也没有任何增长限制。<br>内建函数 len 可以用来获得 slice 和 map 的长度。<br>内建函数 cap 只能作用在 slice 上。<br>可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。<br>在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。</p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-SPL(数据结构)</title>
      <link href="/blog/2020/06/23/PHP/PHP-SPL(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/"/>
      <url>/blog/2020/06/23/PHP/PHP-SPL(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>php SPL四种常用的数据结构<br>1.栈【先进后出】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$stack &#x3D; new SplStack();</span><br><span class="line">$stack-&gt;push(&#39;data1&#39;);</span><br><span class="line">$stack-&gt;push(&#39;data2&#39;);</span><br><span class="line">$stack-&gt;push(&#39;data3&#39;);</span><br><span class="line">echo $stack-&gt;pop();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data3&lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;font-size:24px;font-weight: bold;&quot;&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>2.队列【先进先出 后进后出】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$queue &#x3D; new SplQueue();</span><br><span class="line">$queue-&gt;enqueue(&quot;data1&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data2&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data3&quot;);</span><br><span class="line">echo $queue-&gt;dequeue();</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data1&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>3.堆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$heap &#x3D; new SplMinHeap();</span><br><span class="line">$heap-&gt;insert(&quot;data1&quot;);</span><br><span class="line">$heap-&gt;insert(&quot;data2&quot;);</span><br><span class="line">echo $heap-&gt;extract();</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data1&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>4.固定尺寸数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$array &#x3D; new SplFixedArray(5);</span><br><span class="line">$array[0]&#x3D;1;</span><br><span class="line">$array[3]&#x3D;3;</span><br><span class="line">$array[2]&#x3D;2;</span><br><span class="line">var_dump($array);</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F; object(SplFixedArray)[1]</span><br><span class="line">&#x2F;&#x2F; public 0 &#x3D;&gt; int 1</span><br><span class="line">&#x2F;&#x2F; public 1 &#x3D;&gt; null</span><br><span class="line">&#x2F;&#x2F; public 2 &#x3D;&gt; int 2</span><br><span class="line">&#x2F;&#x2F; public 3 &#x3D;&gt; int 3</span><br></pre></td></tr></table></figure><p>————————————————<br>推荐学习：<a href="http://www.imooc.com/video/4849">http://www.imooc.com/video/4849</a><br>原文链接：<a href="https://blog.csdn.net/zhengwish/article/details/51742264">https://blog.csdn.net/zhengwish/article/details/51742264</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-use</title>
      <link href="/blog/2020/06/23/PHP/PHP-Use-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/blog/2020/06/23/PHP/PHP-Use-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>php use用法</p><h4 id="1、user-namespace"><a href="#1、user-namespace" class="headerlink" title="1、user namespace"></a>1、user namespace</h4><h4 id="2、use-一个trait"><a href="#2、use-一个trait" class="headerlink" title="2、use 一个trait"></a>2、use 一个trait</h4><p>针对于trait的即多继承</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span></span>&#123; eat()&#125; <span class="class"><span class="keyword">trait</span> <span class="title">B</span></span>&#123; drink()&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="keyword">use</span> <span class="title">A</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">B</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">Class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">d=new Class C()</span><br><span class="line">d-&gt;eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 当不同的trait中，却有着同名的方法或属性，会产生冲突，可以使用insteadof或 as进行解决，insteadof 是进行替代，而as是给它取别名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use trait1,trait2&#123;</span><br><span class="line">        trait1::eat insteadof trait2;</span><br><span class="line">        trait1::drive insteadof trait2;</span><br><span class="line">        trait2::eat as eaten;</span><br><span class="line">        trait2::drive as driven;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-闭包-gt-匿名函数"><a href="#3-闭包-gt-匿名函数" class="headerlink" title="3.闭包-&gt;匿名函数"></a>3.闭包-&gt;匿名函数</h4><p>好处：节省内存  适合做回调函数</p><p>匿名函数：定义时未定义函数的名称<br>闭包： 创建时封装周围状态的函数，及时周围的环境不存在了，闭包中的状态还会存在</p><p>使用法则：</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> USE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-strlen与mb_strlen</title>
      <link href="/blog/2020/06/22/PHP/PHP-strlen%E4%B8%8Emb-strlen/"/>
      <url>/blog/2020/06/22/PHP/PHP-strlen%E4%B8%8Emb-strlen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>在PHP中，strlen与mb_strlen是求字符串长度的函数<br>PHP内置的字符串长度函数strlen无法正确处理中文字符串，它得到的只是字符串所占的字节数。对于GB2312的中文编码，strlen得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍（在 UTF-8编码下，一个汉字占3个字节）。</p><p>采用mb_strlen函数可以较好地解决这个问题。mb_strlen的用法和strlen类似，只不过它有第二个可选参数用于指定字符编码。例如得到UTF-8的字符串str长度，可以用mbstrlen(str长度，可以用mbstrlen(str,‘UTF-8’)。如果省略第二个参数，则会使用PHP的内部编码。内部编码可以通过 mb_internal_encoding()函数得到。</p><p>需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即确保“extension=php_mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。</p><hr><p>在strlen计算中，对待一个UTF8的中文字符，处理为3个字节长度，所以为3+1+2+1+9=16个</p><p>当mb_strlen的内码选择为UTF-8的时候，则会将中文字符当成一个字符,所以为3+1+2+1+3=10;</p><p>当mb_strlen的内码选择为gbk的时候，一个中文字符当成1.5个字符来处理来处理,最后就是:3+1+2+1+4.5=11.5</p><p>函数：mb_internal_encoding()会得到当前PHP使用的内部编码</p><p>strlen,得到的是字符串所占的字节数，所以在查看一个字符串的长度的时候，strlen并不能得到我们需要的真实值</p><p>mb_strlen 函数可以很好的处理这一点</p><p>注意：mb_strlen函数并不是php的核心函数，只是PHP的一个扩展函数，使用之前要判断是否加在的mbstring扩展模块，在Php.ini文件中可以查看相关配置</p><blockquote><p>strlen结果为什么是4<br>strlen在遇到第一个\0时结束，后面的字符无视。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> strlen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他-科学上网</title>
      <link href="/blog/2020/06/22/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <url>/blog/2020/06/22/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="解决System-Reflection-TargetInvocationException-调用的目标发生了异常。"><a href="#解决System-Reflection-TargetInvocationException-调用的目标发生了异常。" class="headerlink" title="解决System.Reflection.TargetInvocationException: 调用的目标发生了异常。"></a>解决System.Reflection.TargetInvocationException: 调用的目标发生了异常。</h1><blockquote><p>windows7系统运行没有问题，但是放到Windows10 上面就出现连接不上的问题，试了很多种方法还是这种解决了。</p></blockquote><p>问题：</p><p>System.Reflection.TargetInvocationException: 调用的目标发生了异常。</p><p>—&gt; System.Reflection.TargetInvocationException: 调用的目标发生了异常。</p><p>—&gt; System.InvalidOperationException: 此实现不是 Windows 平台 FIPS 验证的加密算法的一部分</p><p>解决办法：需要修改注册表,cmd命令，输入regedit打开注册表然后找到以下路径</p><p>KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy</p><p>修改此路径下的Enable值为1，然后重新打开shadowsocks，大功告成！记得重启ssr</p><p>（如果1不行那就切换成0）</p><p>————————————————<br>原文链接：<a href="https://blog.csdn.net/qq_27536941/article/details/103300646">https://blog.csdn.net/qq_27536941/article/details/103300646</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-异常类</title>
      <link href="/blog/2020/06/22/PHP/PHP-%E5%BC%82%E5%B8%B8%E7%B1%BB/"/>
      <url>/blog/2020/06/22/PHP/PHP-%E5%BC%82%E5%B8%B8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>PHP 异常与错误 —— Throwable<br>Throwable</p><p>官方文档地址： <a href="http://php.net/manual/en/class.throwable.php">http://php.net/manual/en/class.throwable.php</a></p><p>PHP 支持版本： 7</p><blockquote><p>PHP7 异常与错误处理机制 Exception, Error, Throwable<br>Throwable 是 PHP 7 中可以用作任何对象抛出声明的基本接口，包括 Expection （异常）和 Error （错误）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Throwable &#123;</span><br><span class="line">    </span><br><span class="line">  &#x2F;* 抽象方法 *&#x2F;</span><br><span class="line">  abstract public string getMessage ( void ) &#x2F;&#x2F; 获取抛出的消息内容</span><br><span class="line"></span><br><span class="line">  abstract public int getCode ( void ) &#x2F;&#x2F; 获取抛出的错误代码</span><br><span class="line"></span><br><span class="line">  abstract public string getFile ( void ) &#x2F;&#x2F; 获取产生异常的文件名</span><br><span class="line"></span><br><span class="line">  abstract public int getLine ( void ) &#x2F;&#x2F; 获取相关行号</span><br><span class="line"></span><br><span class="line">  abstract public array getTrace ( void ) &#x2F;&#x2F; 获取追踪信息，返回数组形式</span><br><span class="line"></span><br><span class="line">  abstract public string getTraceAsString ( void ) &#x2F;&#x2F; 获取追踪信息，返回字符串形式</span><br><span class="line"></span><br><span class="line">  abstract public Throwable getPrevious ( void ) &#x2F;&#x2F; 返回上一个 Throwable</span><br><span class="line"></span><br><span class="line">  abstract public string __toString ( void ) &#x2F;&#x2F; 抛出的对象以字符串形式返回，可以用 echo 打印相应结果</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请一定要注意，没有特殊说明：本例 PHP Version &lt; 7<br>　　说起 PHP 异常处理，大家首先会想到 try-catch，那好，我们先看一段程序吧：有一个 test.php 文件，有一段简单的 PHP 程序，内容如下，然后命令行执行：php test.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 $num &#x3D; 0;</span><br><span class="line">3     try &#123;</span><br><span class="line">4         echo 1&#x2F;$num;</span><br><span class="line">5</span><br><span class="line">6 &#125; catch (Exception $e)&#123;</span><br><span class="line">7         echo $e-&gt;getMessage();</span><br><span class="line">8 &#125;</span><br><span class="line">9 ?&gt;</span><br></pre></td></tr></table></figure><p>　　我的问题是：这段程序能正确的捕捉到除 0 的错误信息吗？<br>　　如果你回答能，那你就把这篇文章看完吧！应该能学点东西。</p><p>本文章分 5 个部分介绍我的异常处理的理解：</p><p>一、异常与错误的概述</p><p>二、ERROR 的级别</p><p>三、PHP 异常处理中的黑科技</p><p>四、巧妙的捕获错误和异常</p><p>五、自定义异常处理和异常嵌套</p><p>六、PHP7 中的异常处理</p><p>一、异常与错误的概述<br>　　 PHP 中什么是异常：<br>　　程序在运行中出现不符合预期的情况，允许发生（你也不想让他出现不正常的情况）但他是一种不正常的情况，按照我们的正常逻辑本不该出的错误，但仍然会出现的错误，属于逻辑和业务流程的错误，而不是编译或者语法上的错误。</p><p>PHP 中什么是错误：<br>　　属于 php 脚本自身的问题，大部分情况是由错误的语法，服务器环境导致，使得编译器无法通过检查，甚至无法运行的情况。warning、notice 都是错误，只是他们的级别不同而已，并且错误是不能被 try-catch 捕获的。</p><p>上面的说法是有前提条件的：<br>　　在 PHP 中，因为在其他语言中就不能这样下结论了，也就是说异常和错误的说法在不同的语言有不同的说法。在 PHP 中任何自身的错误或者是非正常的代码都会当做错误对待，并不会以异常的形式抛出，但是也有一些情况会当做异常和错误同时抛出(据说是，我没有找到合适的例子)。也就是说，你想在数据库连接失败的时候自动捕获异常是行不通的，因为这就不是异常，是错误。但是在 java 中就不一样了，他会把很多和预期不一致的行为当做异常来进行捕获。</p><p>PHP 异常处理很鸡肋？<br>　　在上面的分析中我们可以看出，PHP 并不能主动的抛出异常，但是你可以手动抛出异常，这就很无语了，如果你知道哪里会出问题，你添加 if else 解决不就行了吗，为啥还要手动抛出异常，既然能手动抛出就证明这个不是异常，而是意料之中。以我的理解，这就是 PHP 异常处理鸡肋的地方（不一定对啊）。所以 PHP 的异常机制不是那么的完美，但是使用过框架的同学都知道有这个情况：你在框架中直接写开头那段 php“自动”捕获异常的代码是可以的，这是为什么？看过源码的同学都知道框架中都会涉及三个函数：register_shutdown_function，set_error_handler，set_exception_handler 后面我会重点讲解着三个黑科技，通过这几个函数我们可以实现 PHP 假自动捕获异常和错误。</p><p>二、ERROR 的级别<br>　　只有熟悉错误级别才能对错误捕捉有更好的认识。 ERROR 有不同的错误级别，我之前的一篇文章中有写到：<a href="http://www.cnblogs.com/zyf-zhaoyafei/p/3649434.html">http://www.cnblogs.com/zyf-zhaoyafei/p/3649434.html</a><br>　　下面我再总结性的给出这几类错误级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 Fatal Error:致命错误（脚本终止运行）</span><br><span class="line">2 E_ERROR &#x2F;&#x2F; 致命的运行错误，错误无法恢复，暂停执行脚本</span><br><span class="line">3 E_CORE_ERROR &#x2F;&#x2F; PHP 启动时初始化过程中的致命错误</span><br><span class="line">4 E_COMPILE_ERROR &#x2F;&#x2F; 编译时致命性错，就像由 Zend 脚本引擎生成了一个 E_ERROR</span><br><span class="line">5 E_USER_ERROR &#x2F;&#x2F; 自定义错误消息。像用 PHP 函数 trigger_error（错误类型设置为：E_USER_ERROR）</span><br><span class="line">6</span><br><span class="line">7 Parse Error：编译时解析错误，语法错误（脚本终止运行）</span><br><span class="line">8 E_PARSE &#x2F;&#x2F;编译时的语法解析错误</span><br><span class="line">9</span><br><span class="line">10 Warning Error：警告错误（仅给出提示信息，脚本不终止运行）</span><br><span class="line">11 E_WARNING &#x2F;&#x2F; 运行时警告 (非致命错误)。</span><br><span class="line">12 E_CORE_WARNING &#x2F;&#x2F; PHP 初始化启动过程中发生的警告 (非致命错误) 。</span><br><span class="line">13 E_COMPILE_WARNING &#x2F;&#x2F; 编译警告</span><br><span class="line">14 E_USER_WARNING &#x2F;&#x2F; 用户产生的警告信息</span><br><span class="line">15</span><br><span class="line">16 Notice Error：通知错误（仅给出通知信息，脚本不终止运行）</span><br><span class="line">17 E_NOTICE &#x2F;&#x2F; 运行时通知。表示脚本遇到可能会表现为错误的情况.</span><br><span class="line">18 E_USER_NOTICE &#x2F;&#x2F; 用户产生的通知信息。</span><br></pre></td></tr></table></figure><p>　　由此可知有 5 类是产生 ERROR 级别的错误，这种错误直接导致 PHP 程序退出。<br>　　可以定义成：</p><p>1 ERROR = E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_PARSE<br>三、PHP 异常处理中的黑科技<br>　　前面提到框架中是可以捕获所有的错误和异常的，之所以能实现应该是使用了黑科技，哈哈！其实也不是什么黑科技，主要是三个重要的函数：</p><p>1：set_error_handler()<br>　　看到这个名字估计就知道什么意思了，这个函数用于捕获错误，设置一个用户自定义的错误处理函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 set_error_handler(&#39;zyferror&#39;);</span><br><span class="line">3 function zyferror($type, $message, $file, $line)</span><br><span class="line">4 &#123;</span><br><span class="line">5 　　 var_dump(&#39;&lt;b&gt;set_error_handler: &#39; . $type . &#39;:&#39; . $message . &#39; in &#39; . $file . &#39; on &#39; . $line . &#39; line .&lt;&#x2F;b&gt;&lt;br &#x2F;&gt;&#39;);</span><br><span class="line">6 &#125;</span><br><span class="line">7 ?&gt;</span><br></pre></td></tr></table></figure><p>　　当程序出现错误的时候自动调用此方法，不过需要注意一下两点：第一，如果存在该方法，相应的 error_reporting()就不能在使用了。所有的错误都会交给自定义的函数处理。第二，此方法不能处理以下级别的错误：E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，set_error_handler() 函数所在文件中产生的 E_STRICT，该函数只能捕获系统产生的一些 Warning、Notice 级别的错误。<br>　　并且他有多种调用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 &#x2F;&#x2F; 直接传函数名 NonClassFunction</span><br><span class="line">3 set_error_handler(&#39;function_name&#39;);</span><br><span class="line">4</span><br><span class="line">5 &#x2F;&#x2F; 传 class_name &amp;&amp; function_name</span><br><span class="line">6 set_error_handler(array(&#39;class_name&#39;, &#39;function_name&#39;));</span><br><span class="line">7 ?&gt;</span><br></pre></td></tr></table></figure><p>　　 2：register_shutdown_function()<br>　　捕获 PHP 的错误：Fatal Error、Parse Error 等，这个方法是 PHP 脚本执行结束前最后一个调用的函数，比如脚本错误、die()、exit、异常、正常结束都会调用，多么牛逼的一个函数啊！通过这个函数就可以在脚本结束前判断这次执行是否有错误产生，这时就要借助于一个函数：error_get_last()；这个函数可以拿到本次执行产生的所有错误。error_get_last();返回的信息：<br>　　[type] - 错误类型<br>　　[message] - 错误消息<br>　　[file] - 发生错误所在的文件<br>　　[line] - 发生错误所在的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 register_shutdown_function(&#39;zyfshutdownfunc&#39;);</span><br><span class="line">3 function zyfshutdownfunc()</span><br><span class="line">4 &#123;</span><br><span class="line">5 if ($error &#x3D; error_get_last()) &#123;</span><br><span class="line">6             var_dump(&#39;&lt;b&gt;register_shutdown_function: Type:&#39; . $error[&#39;type&#39;] . &#39; Msg: &#39; . $error[&#39;message&#39;] . &#39; in &#39; . $error[&#39;file&#39;] . &#39; on line &#39; . \$error[&#39;line&#39;] . &#39;&lt;&#x2F;b&gt;&#39;);</span><br><span class="line">7 &#125;</span><br><span class="line">8 &#125;</span><br><span class="line">9 ?&gt;</span><br></pre></td></tr></table></figure><p>　　通过这种方法就可以巧妙的打印出程序结束前所有的错误信息。但是我在测试的时候我发现并不是所有的错误终止后都会调用这个函数，可以看下面的一个测试文件，内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 register_shutdown_function(&#39;zyfshutdownfunc&#39;);</span><br><span class="line">3 function zyfshutdownfunc()</span><br><span class="line">4 &#123;</span><br><span class="line">5 if ($error &#x3D; error_get_last()) &#123;</span><br><span class="line"> 6             var_dump(&#39;&lt;b&gt;register_shutdown_function: Type:&#39; . $error[&#39;type&#39;] . &#39; Msg: &#39; . $error[&#39;message&#39;] . &#39; in &#39; . $error[&#39;file&#39;] . &#39; on line &#39; . \$error[&#39;line&#39;] . &#39;&lt;&#x2F;b&gt;&#39;);</span><br><span class="line">7 &#125;</span><br><span class="line">8 &#125;</span><br><span class="line">9 var_dump(23+-+); &#x2F;&#x2F;此处语法错误</span><br><span class="line">10 ?&gt;</span><br><span class="line"></span><br><span class="line">　　自己可以试一下，你可以看到根本就不会触发 zyfshutdownfunc()函数，其实这是一个语法错误，直接报了一个：</span><br><span class="line"></span><br><span class="line">1 &lt;?php</span><br><span class="line">2 Parse error: syntax error, unexpected &#39;)&#39; in &#x2F;www&#x2F;mytest&#x2F;exception&#x2F;try-catch.php on line 71</span><br><span class="line">3 ?&gt;</span><br><span class="line">　　由此引出一个奇葩的问题：问什么不能触发，为什么框架中是可以的？其实原因很简单，只在 parse-time 出错时是不会调用本函数的。只有在 run-time 出错的时候，才会调用本函数，我的理解是语法检查器前没有执行 register_shutdown_function()去把需要注册的函数放到调用的堆栈中，所以就根本不会运行。那框架中为什么任何错误都能进入到 register_shutdown_function()中呢，其实在框架中一般会有统一的入口 index.php，然后每个类库文件都会通过 include \*\* 的方式加载到 index.php 中，相当与所有的程序都会在 index.php 中聚集，同样，你写的具有语法错误的文件也会被引入到入口文件中，这样的话，调用框架，执行 index.php，index.php 本身并没有语法错误，也就不会产生 parse-time 错误，而是 include 文件出错了，是 run-time 的时候出错了，所以框架执行完之后就会触发 register_shutdown_function();</span><br><span class="line">　　所以现在可是试一下这个写法，这样就会触发 zyfshutdownfunc()回调了：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 a.php 文件<br>2 <?php3 　　// 模拟语法错误4 　　 var_dump(23+-+);5 ?><br>6<br>7 b.php 文件<br>8 <?php9 register_shutdown_function('zyfshutdownfunc');10 function zyfshutdownfunc()11 {12 if ($error = error_get_last()) {13             var_dump('<b>register_shutdown_function: Type:' . $error['type'] . ' Msg: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . \$error['line'] . '</b>');14 }15 }16 require 'a.php';17 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　 3：set_exception_handler()</span><br><span class="line">　　设置默认的异常处理程序，用在没有用 try&#x2F;catch 块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。看一下用法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 set_exception_handler('zyfexception');3 function zyfexception($exception)4     {5         var_dump("<b>set_exception_handler: Exception: " . $exception->getMessage() . '</b>');6 }7 throw new Exception("zyf exception");8 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">四、巧妙的捕获错误和异常</span><br><span class="line">　　 1：把错误以异常的形式抛出(不能完全抛出)</span><br><span class="line">　　　　由上面的讲解我们知道，php 中的错误是不能以异常的像是捕获的，但是我们需要让他们抛出，已达到扩展 try-catch 的影响范围，我们前面讲到过 set_error_handler() 方法，他是干嘛用的，他是捕获错误的，所以我们就可以借助他来吧错误捕获，然后再以异常的形式抛出，ok，试试下面的写法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 set_error_handler('zyferror');3 function zyferror($type, $message, $file, $line)4 {5 throw new \Exception($message . 'zyf错误当做异常'); 6     } 7  8     $num = 0;9 try {10 echo 1/$num;11 12     } catch (Exception $e){13 echo \$e->getMessage();14 }15 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　好了，试一下，会打印出：</span><br><span class="line"></span><br><span class="line">1 Division by zero zyf123</span><br><span class="line">　　流程：本来是除 0 错误，然后触发 set_error_handler()，在 set_error_handler()中相当与杀了个回马枪，再把错误信息以异常的形式抛出来，这样就可以实现错误以异常的形式抛出。大家要注意：这样做是有缺点的，会受到 set_error_handler()函数捕获级别的限制。</span><br><span class="line"></span><br><span class="line">     2：捕获所有的错误</span><br><span class="line">        由set_error_handler()可知，他能够捕获一部分错误，不能捕获系统级E_ERROR、E_PARSE等错误，但是这部分可以由register_shutdown_function()捕获。所以两者结合能出现很好的功能。</span><br><span class="line">        看下面的程序：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 a.php 内容：<br>2 <?3 // 模拟 Fatal error 错误4 //test();56 // 模拟用户产生 ERROR 错误7 //trigger_error('zyf-error', E_USER_ERROR);89 // 模拟语法错误10 var_dump(23+-+);1112 // 模拟 Notice 错误13 //echo \$f;1415 // 模拟 Warning 错误16 //echo '123';17 //ob_flush();18 //flush();19 //header("Content-type:text/html;charset=gb2312");20 ?></p><p>21 b.php 内容：<br>22 <?23 error_reporting(0);24 register_shutdown_function('zyfshutdownfunc');25 function zyfshutdownfunc()26 {27 if ($error = error_get_last()) {28             var_dump('<b>register_shutdown_function: Type:' . $error['type'] . ' Msg: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line'] . '</b>');29         }30     }31 32     set_error_handler('zyferror');33     function zyferror($type, $message, $file, $line)34     {35         var_dump('<b>set_error_handler: ' . $type . ':' . $message . ' in ' . $file . ' on ' . \$line . ' line .</b><br />');36 }3738 require 'a.php';39 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　到此就可以解释开头的那个程序了吧，test.php 如果是单文件执行是不能捕获到错误的，如果你在框架中执行就是可以的，当然你按照我上面介绍的来扩展也是可以的。</span><br><span class="line"></span><br><span class="line">五、自定义异常处理和异常嵌套</span><br><span class="line"></span><br><span class="line">1：自定义异常处理</span><br><span class="line"></span><br><span class="line">在复杂的系统中，我们往往需要自己捕获我们需要特殊处理的异常，这些异常可能是特殊情况下抛出的。所以我们就自己定义一个异常捕获类，该类必须是 exception 类的一个扩展，该类继承了 PHP 的 exception 类的所有属性，并且我们可以添加自定义的函数，使用的时候其实和之前的一样，大致写法如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 class zyfException extends Exception3 {4 public function errorzyfMessage()5 {6 return 'Error line ' . $this->getLine().' in ' . $this->getFile()7 .': <b>' . $this->getMessage() . '</b> Must in (0 - 60)'; 8         } 9     }10 11     $age = 10;12 try {13 $age = intval($age);14 if($age > 60) {15             throw new zyfException($age);16 }1718 } catch (zyfException $e) {19         echo $e->errorzyfMessage();2021 }22 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　 2：异常嵌套</span><br><span class="line"></span><br><span class="line">异常嵌套是比较常见的写法，在自定义的异常处理中，try 块中可以定义多个异常捕获，然后分层传递异常，理解和冒泡差不多，看下面的实现：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 $age = 10; 3     try { 4         $age = intval($age); 5         if($age > 60) {6 throw new zyfException($age); 7         } 8  9         if ($age <= 0) {10 throw new Exception($age . ' must > 0');11         }12 13     } catch (zyfException $e) {14 echo $e->errorzyfMessage();15 16     } catch(Exception $e) {17 echo \$e->getMessage();18 }19 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　当然也可以在 catch 中再抛出异常给上层：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 $age = 100; 3     try { 4         try { 5             $age = intval($age); 6             if($age > 60) {7 throw new Exception($age); 8             } 9 10         } catch (Exception $e) {11 throw new zyfException($age);12 13         }14 15     } catch (zyfException $e) {16 echo \$e->errorzyfMessage();17 }18 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">六、PHP7 中的异常处理</span><br><span class="line">　　现在写 PHP 必须考虑版本情况，上面的写法在 PHP7 中大部分都能实现，但是也会有不同点，在 PHP7 更新中有一条：更多的 Error 变为可捕获的 Exception，现在的 PHP7 实现了一个全局的 throwable 接口，原来老的 Exception 和其中一部分 Error 实现了这个接口(interface)，PHP7 中更多的 Error 变为可捕获的 Exception 返回给捕捉器，这样其实和前面提到的扩展 try-catch 影响范围一样，但是如果不捕获则还是按照 Error 对待，看下面两个：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 try {3 test();45 } catch(Throwable $e) { 6         echo $e->getMessage() . ' zyf';7 }89 try {10 test();1112 } catch(Error $e) {13         echo $e->getMessage() . ' zyf';14 }15 ?></p><p>```<br>因为 PHP7 实现了 throwable 接口，那么就可以使用第一个这种方式来捕获异常。又因为部分 Error 实现了接口，并且更多的 Error 变为可捕获的 Exception，那么就可以使用第二种方式来捕获异常。下面是在网上找的 PHP7 的异常层次树：<br>Throwable<br>　　 Exception 异常<br>　　　　…<br>　　 Error 错误<br>　　　　 ArithmeticError 算数错误<br>　　　　　　 DivisionByZeroError 除数为 0 的错误<br>　　　　 AssertionError 声明错误<br>　　　　 ParseError 解析错误<br>　　　　 TypeError 类型错误<br>转载：<br><a href="http://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html">http://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html</a> </p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http与rpc区别，以及如何使用rpc</title>
      <link href="/blog/2020/06/19/HTTP/%E5%BE%AE%E6%9C%8D%E5%8A%A1-http%E4%B8%8Erpc%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8rpc/"/>
      <url>/blog/2020/06/19/HTTP/%E5%BE%AE%E6%9C%8D%E5%8A%A1-http%E4%B8%8Erpc%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8rpc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>HTTP就是一种RPC(Remote Procedure Call) ,http是七层iso模型，转换步骤多，且基于http有更多的报文</p></blockquote><p><strong>http好比普通话，rpc好比团伙内部黑话。</strong><br>只要是远程调用都可以叫RPC()，和是不是通过http没什么关系<br>讲普通话，好处就是谁都听得懂，谁都会讲。<br>讲黑话，好处是可以更精简、更加保密、更加可定制，坏处就是要求“说”黑话的那一方（client端）也要懂，而且一旦大家都说一种黑话了，换黑话就困难了。</p><blockquote><p>首先 http 和 rpc 并不是一个并行概念。</p></blockquote><p>rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。</p><p>传输协议包含: 如著名的 [gRPC](<a href="https://link.zhihu.com/?target=http%3A//www.grpc.io/">grpc / grpc.io</a>) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。</p><p>序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。</p><p>因此我理解的问题应该是：<strong>为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？</strong></p><p>解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。</p><p>首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于<strong>连接的建立与断开</strong>。http协议是支持<strong>连接池复用</strong>的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。</p><p>通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>即使编码协议也就是body是使用二进制编码协议，报文元数据也就是<strong>header头的键值对却用了文本编码，非常占字节数</strong>。如上图所使用的报文中有效字节数仅仅占约 30%，<strong>也就是70%的时间用于传输元数据废编码</strong>。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。</p><p>那么假如我们使用自定义tcp协议的报文如下</p><p><img src= "/blog/img/loading.gif" data-lazy-src="https://pic2.zhimg.com/80/v2-89c905b0806577471aa7789a25ac0d44_720w.jpg" alt="tcp"></p><p>报头占用的字节数也就只有16个byte，极大地精简了传输内容。</p><p>这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因</p><p>简单来说成熟的rpc库相对http容器，更多的是封装了“服务发现”，”负载均衡”，“熔断降级”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。</p><blockquote><p>那http和rpc和websocket三者有什么关系呢？</p></blockquote><p><a href="https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Web_Service">Web Service</a> 也提出了好久了, 那么究竟什么是 <a href="https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Web_Service">Web Service</a> ?<br> 简单地说, 也就是服务器如何向客户端提供服务.<br> 常用的方法有:<br> <a href="https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> 所谓的远程过程调用 (面向方法)<br> <a href="https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Service-oriented_architecture">SOA</a> 所谓的面向服务的架构(面向消息)<br> <a href="https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Representational_State_Transfer">REST</a> 所谓的 <strong>Representational state transfer</strong> (面向资源)</p><p>转载整理自：<a href="https://www.zhihu.com/question/41609070/answer/191965937">https://www.zhihu.com/question/41609070/answer/191965937</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG笔记1-基础数据类型</title>
      <link href="/blog/2020/06/09/GOLANG/GOLANG-%E7%AC%94%E8%AE%B01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/blog/2020/06/09/GOLANG/GOLANG-%E7%AC%94%E8%AE%B01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="int-和-uint"><a href="#int-和-uint" class="headerlink" title="int  和 uint"></a>int  和 uint</h3><p>uint类型长度取决于 CPU，如果是32位CPU就是4个字节，如果是64位就是8个字节。我的电脑是64位的，而 playground 是32位的</p><blockquote><p>int是带符号的，表示范围是：-2147483648到2147483648，即-2^31到2^31次方。</p></blockquote><blockquote><p>uint则是不带符号的，表示范围是：2^32即0到4294967295。</p></blockquote><blockquote><p>uint可以使用十进制，二进制，十六进制。和long,ulong,float,double,decimal等预定义可以进行隐式转换。但是需要注意值是否在可转换的范围内，不然会出现异常。</p></blockquote><p>The Uint keyword signifies an integral type that stores calues according to the size and ranges shown in the following table.</p><blockquote><p>关键字表示一种整型类型，该类型根据下表显示的大小和范围存储值。<br>————————————————</p></blockquote><p>原文链接：<a href="https://blog.csdn.net/janny_flower/article/details/81082424">https://blog.csdn.net/janny_flower/article/details/81082424</a></p>]]></content>
      
      
      <categories>
          
          <category> golang </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HEXO快捷方式</title>
      <link href="/blog/2020/06/09/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
      <url>/blog/2020/06/09/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://www.jianshu.com/p/1c888a6b8297?utm_source=oschina-app">https://www.jianshu.com/p/1c888a6b8297?utm_source=oschina-app</a></p><h3 id="新编写BLOG"><a href="#新编写BLOG" class="headerlink" title="新编写BLOG"></a>新编写BLOG</h3><p>hexo new [layout] <title></p><h3 id="push到github："><a href="#push到github：" class="headerlink" title="push到github："></a>push到github：</h3><p>hexo deploy</p><p>hexo clean</p><p>hexo deploy</p><h3 id="每次都要执行-hexo-clean-和-hexo-deploy，不如写个新的脚本"><a href="#每次都要执行-hexo-clean-和-hexo-deploy，不如写个新的脚本" class="headerlink" title="每次都要执行 hexo clean 和 hexo deploy，不如写个新的脚本"></a>每次都要执行 hexo clean 和 hexo deploy，不如写个新的脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; package.json</span><br><span class="line">&quot;dev&quot;: &quot;hexo s&quot;,</span><br><span class="line">&quot;build&quot;: &quot;hexo clean &amp; hexo deploy&quot;</span><br></pre></td></tr></table></figure><p>npm run build</p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQl索引</title>
      <link href="/blog/2020/06/09/MSYQL/MYSQl-%E7%B4%A2%E5%BC%95/"/>
      <url>/blog/2020/06/09/MSYQL/MYSQl-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>  docker logs -t -f –tail 100 im4<br>处理init问题</p><p>一、查询和更新上的区别<br>这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。建议尽量选择普通索引。<br>1.1 MySQL 的查询操作<br>普通索引<br>查找到第一个满足条件的记录后，继续向后遍历，直到第一个不满足条件的记录。<br>唯一索引<br>由于索引定义了唯一性，查找到第一个满足条件的记录后，直接停止继续检索。<br>普通索引会多检索一次，几乎没有影响。因为 InnoDB 的数据是按照数据页为单位进行读写的，需要读取数据时，并不是直接从磁盘读取记录，而是先把数据页读到内存，再去数据页中检索。<br>一个数据页默认 16 KB，对于整型字段，一个数据页可以放近千个 key，除非要读取的数据在数据页的最后一条记录，就需要再读一个数据页，这种情况很少，对CPU的消耗基本可以忽略了。<br>因此说，在查询数据方面，普通索引和唯一索引没差别。</p><p>1.2 MySQL 的更新操作<br>更新操作并不是直接对磁盘中的数据进行更新，是先把数据页从磁盘读入内存，再更新数据页。<br>普通索引<br>将数据页从磁盘读入内存，更新数据页。<br>唯一索引<br>将数据页从磁盘读入内存，判断是否唯一，再更新数据页。<br>由于 MySQL 中有个 change buffer 的机制，会导致普通索引和唯一索引在更新上有一定的区别。<br>change buffer的作用是为了降低IO 操作，避免系统负载过高。change buffer将数据写入数据页的过程，叫做merge。<br>如果需要更新的数据页在内存中时，会直接更新数据页；如果数据不在内存中，会先将更新操作记入change buffer，当下一次读取数据页时，顺带merge到数据页中，change buffer也有定期merge策略。数据库正常关闭的过程中，也会触发merge。<br>对于唯一索引，更新前需要判断数据是否唯一（不能和表中数据重复），如果数据页在内存中，就可以直接判断并且更新，如果不在内存中，就需要去磁盘中读出来，判断一下是否唯一，是的话就更新。change buffer是用不到的。即使数据页不在内存中，还是要读出来。<br>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><p>结论：唯一索引用不了change buffer，只有普通索引可以用。</p><p>二、change buffer 和 redo log的区别<br>2.1 change buffer 的适用场景<br>change buffer 的作用是降低更新操作的频率，缓存更新操作。这样会有一个缺点，就是更新不及时，对于读操作比较频繁的表，不建议使用 change buffer。<br>因为更新操作刚记录进change buffer中，就读取了该表，数据页被读到了内存中，数据马上就merge到数据页中了。这样不仅不会降低性能消耗，反而会增加维护change buffer的成本。<br>适用于写多读少的表。</p><p>2.2 change buffer 和 redo log 区别<br>我们举一个例子用来理解 redo log 和 change buffer。我们执行以下 SQL 语句：<br>mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</p><p>假设，(id1,k1) 在数据页 Page 1 中，(id2,k2) 在数据页 Page 2 中。并且 Page 1 在内存中，Page 2 不在内存中。<br>执行过程如下：<br>直接向 Page 1 中写入 (id1,k1)；<br>在change buffer 中记下”向 Page 2 中写入(id2,k2)”这条信息；<br>将以上两个动作记入redo log。<br>做完上面这些，事务就可以完成了。执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。<br>这条更新语句，涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。<br>如果要读数据的话，过程是怎样的？<br>mysql&gt; select * from t where k in (k1, k2);</p><p>假设读操作在更新后不久，此时内存中还有 Page 1，没有 Page 2，那么读操作就和 redo log 以及 ibdata1 无关了。<br>从内存中获取到 Page 1 上的最新数据 (id1,k1)；<br>将数据页 Page 2 读入内存，执行merge 操作，此时内存中的 Page 2 也有最新数据(id2,k2)；<br>需要注意的是：<br>redo log中的数据，可能还没有 flush 到磁盘，磁盘中的 Page 1 和 Page 2 中并没有最新数据，但我们依然可以拿到最新数据（内存中的 Page 1 就是最新的，Page 2 虽然不是最新的，但是从磁盘读到内存中后，执行了merge操作，内存中的 Page 2 就是最新的了。）<br>如果此时 MySQL 异常宕机了，比如服务器异常掉电，change buffer 中的数据会不会丢？</p><p>change buffer 中的数据分为两部分，一部分是已经merge到ibdata1中的数据，这部分数据已经持久化，不会丢失。另一部分数据，还在 change buffer 中，没有merge 到ibdata1，分 3 种情况：</p><p>（1）change buffer 写入数据到内存，redo log 也已经写入（ib-log-filex），但是未 commit，binlog中也没有fsync到磁盘，这部分数据会丢失；<br>（2）change buffer 写入数据到内存，redo log 也已经写入（ib-log-filex），但是未 commit，binlog 已写入到磁盘，这部分不会多丢失，异常重启后会先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer；<br>（3）change buffer 写入数据到内存，redo log 和 binlog 都已经fsync，直接从redo log 恢复，不会丢失。<br>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗</p><p>转载自：<a href="https://www.cnblogs.com/hhhhuanzi/p/12318504.html">https://www.cnblogs.com/hhhhuanzi/p/12318504.html</a></p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL_排序</title>
      <link href="/blog/2020/01/20/MSYQL/MYSQL-%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2020/01/20/MSYQL/MYSQL-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSYQL </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/blog/2019/12/27/MSYQL/MYSQL-%E6%97%A5%E5%BF%97/"/>
      <url>/blog/2019/12/27/MSYQL/MYSQL-%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h3><ul><li><p>首先分享一个查看大日志的工具，只有几百k,适合用来实时查看mysql的日志</p><p><code>BareTail</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis基础知识</title>
      <link href="/blog/2019/12/27/REDIS/REDIS-redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/blog/2019/12/27/REDIS/REDIS-redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="redis-pubsub-发布和订阅"><a href="#redis-pubsub-发布和订阅" class="headerlink" title="redis pubsub 发布和订阅"></a>redis pubsub 发布和订阅</h3><p>常用命令：</p><blockquote><p>查看发布的频道：PUBSUB CHANNELS</p></blockquote><blockquote><p>新建频道： PUBLISH mychannel “hello world”</p></blockquote><blockquote><p>订阅频道：SUBSCRIBE mychannel |   Psubscribe 多个channel |支持 channel* 格式</p></blockquote><blockquote><p>退订频道：UNSUBSCRIBE mychannel | Punsubscribe  多个channel  |支持 channel* 格式</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pubsub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis进阶知识</title>
      <link href="/blog/2019/12/27/REDIS/REDIS-redis%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/blog/2019/12/27/REDIS/REDIS-redis%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="关于redis-一些基本知识点"><a href="#关于redis-一些基本知识点" class="headerlink" title="关于redis 一些基本知识点"></a>关于redis 一些基本知识点</h3><h4 id="redis基本介绍"><a href="#redis基本介绍" class="headerlink" title="redis基本介绍"></a>redis基本介绍</h4><p>remote Dictionary Serer (远程字典服务) ANSI C 编写 支持网络 基于内存可持久化的日志型 key=&gt;value 数据库</p><p>官网 redis.io   作者：Salvatore Sanfilippo 意大利人 网名 antirez</p><h4 id="redis被使用的原因"><a href="#redis被使用的原因" class="headerlink" title="redis被使用的原因"></a>redis被使用的原因</h4><p>  传统型关系型数据库如mysql 已经不能适用所有场景，秒杀库存 app首页流量访问高峰  所以考虑缓存中间件，目前市面上比较常用的就是redis 和memcached </p><h4 id="redis-基本的数据结构"><a href="#redis-基本的数据结构" class="headerlink" title="redis 基本的数据结构"></a>redis 基本的数据结构</h4><p>String 、字典Hash、列表List、集合Set、有序集合 SortedSet、 HyperLogLog、Geo、Pub/Sub</p><h5 id="BloomFilter-布隆过滤器"><a href="#BloomFilter-布隆过滤器" class="headerlink" title="BloomFilter 布隆过滤器"></a>BloomFilter 布隆过滤器</h5><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5db69365518825645656c0de">避免缓存击穿的利器之BloomFilter</a></p><h4 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h4><p>-先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放</p><h4 id="redis关键的一个特性："><a href="#redis关键的一个特性：" class="headerlink" title="redis关键的一个特性："></a>redis关键的一个特性：</h4><p>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<code>scan</code>指令，<code>scan</code>指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长</p><h4 id="使用Redis做异步队列"><a href="#使用Redis做异步队列" class="headerlink" title="使用Redis做异步队列"></a>使用Redis做异步队列</h4><p>一般使用list结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><p>list还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><h4 id="实现延时队列"><a href="#实现延时队列" class="headerlink" title="实现延时队列"></a>实现延时队列</h4><p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理。</p><h4 id="生产一次消费多次"><a href="#生产一次消费多次" class="headerlink" title="生产一次消费多次"></a>生产一次消费多次</h4><p>使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列</p><p>缺点：消费者下线的话 生产者会消失，使用MQ</p><h4 id="Redis是怎么持久化"><a href="#Redis是怎么持久化" class="headerlink" title="Redis是怎么持久化"></a>Redis是怎么持久化</h4><p>RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>RDB的原理: fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF&#x2F;RDB文件城后，Redis启动成功； AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息</span><br></pre></td></tr></table></figure><h4 id="Pipeline有什么好处"><a href="#Pipeline有什么好处" class="headerlink" title="Pipeline有什么好处"></a>Pipeline有什么好处</h4><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h4 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h4><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis进阶知识</title>
      <link href="/blog/2019/12/27/REDIS/REDIS-redis%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/"/>
      <url>/blog/2019/12/27/REDIS/REDIS-redis%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="关于redis-一些基本知识点"><a href="#关于redis-一些基本知识点" class="headerlink" title="关于redis 一些基本知识点"></a>关于redis 一些基本知识点</h3><h4 id="redis基本介绍"><a href="#redis基本介绍" class="headerlink" title="redis基本介绍"></a>redis基本介绍</h4><p>remote Dictionary Serer (远程字典服务) ANSI C 编写 支持网络 基于内存可持久化的日志型 key=&gt;value 数据库</p><p>官网 redis.io   作者：Salvatore Sanfilippo 意大利人 网名 antirez</p><h4 id="redis被使用的原因"><a href="#redis被使用的原因" class="headerlink" title="redis被使用的原因"></a>redis被使用的原因</h4><p>  传统型关系型数据库如mysql 已经不能适用所有场景，秒杀库存 app首页流量访问高峰  所以考虑缓存中间件，目前市面上比较常用的就是redis 和memcached </p><h4 id="redis-基本的数据结构"><a href="#redis-基本的数据结构" class="headerlink" title="redis 基本的数据结构"></a>redis 基本的数据结构</h4><p>String 、字典Hash、列表List、集合Set、有序集合 SortedSet、 HyperLogLog、Geo、Pub/Sub</p><h5 id="BloomFilter-布隆过滤器"><a href="#BloomFilter-布隆过滤器" class="headerlink" title="BloomFilter 布隆过滤器"></a>BloomFilter 布隆过滤器</h5><p><a href="https://link.zhihu.com/?target=https%3A//juejin.im/post/5db69365518825645656c0de">避免缓存击穿的利器之BloomFilter</a></p><h4 id="redis分布式锁"><a href="#redis分布式锁" class="headerlink" title="redis分布式锁"></a>redis分布式锁</h4><p>-先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放</p><h4 id="redis关键的一个特性："><a href="#redis关键的一个特性：" class="headerlink" title="redis关键的一个特性："></a>redis关键的一个特性：</h4><p>redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用<code>scan</code>指令，<code>scan</code>指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长</p><h4 id="使用Redis做异步队列"><a href="#使用Redis做异步队列" class="headerlink" title="使用Redis做异步队列"></a>使用Redis做异步队列</h4><p>一般使用list结构作为队列，<code>rpush</code>生产消息，<code>lpop</code>消费消息。当lpop没有消息的时候，要适当sleep一会再重试。</p><p>list还有个指令叫<code>blpop</code>，在没有消息的时候，它会阻塞住直到消息到来。</p><h4 id="实现延时队列"><a href="#实现延时队列" class="headerlink" title="实现延时队列"></a>实现延时队列</h4><p>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用<code>zrangebyscore</code>指令获取N秒之前的数据轮询进行处理。</p><h4 id="生产一次消费多次"><a href="#生产一次消费多次" class="headerlink" title="生产一次消费多次"></a>生产一次消费多次</h4><p>使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列</p><p>缺点：消费者下线的话 生产者会消失，使用MQ</p><h4 id="Redis是怎么持久化"><a href="#Redis是怎么持久化" class="headerlink" title="Redis是怎么持久化"></a>Redis是怎么持久化</h4><p>RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。</p><p>RDB的原理: fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF&#x2F;RDB文件城后，Redis启动成功； AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息</span><br></pre></td></tr></table></figure><h4 id="Pipeline有什么好处"><a href="#Pipeline有什么好处" class="headerlink" title="Pipeline有什么好处"></a>Pipeline有什么好处</h4><p>可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。</p><h4 id="Redis的同步机制"><a href="#Redis的同步机制" class="headerlink" title="Redis的同步机制"></a>Redis的同步机制</h4><p>Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO-butteryly</title>
      <link href="/blog/2019/12/18/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-butteryly/"/>
      <url>/blog/2019/12/18/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-butteryly/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="主题·文档"><a href="#主题·文档" class="headerlink" title="主题·文档"></a>主题·文档</h3><p><a href="https://jerryc.me/">https://jerryc.me/</a></p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>gittalk<br><a href="https://github.com/settings/applications/1190035">https://github.com/settings/applications/1190035</a><br>登录GitHub进行评论，会生成issue<br>Valine<br><a href="https://leancloud.cn/dashboard/applist.html#/apps">https://leancloud.cn/dashboard/applist.html#/apps</a><br>特点在于可以免登陆进行评论，输入验证码评论</p><p>Laibili（来必力）<br>域名到期不稳定<br>Disqus<br>暂时未测试使用到期</p><p>还是准备用valine做第一期</p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词条</title>
      <link href="/blog/2019/12/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AF%8D%E6%9D%A1/"/>
      <url>/blog/2019/12/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AF%8D%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>rss:</p><p>简易信息聚合（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。 [1]  RSS可以是以下三个解释的其中一个： Really Simple Syndication；RDF (Resource Description Framework) Site Summary； Rich Site Summary。但其实这三个解释都是指同一种Syndication的技术。<br>RSS广泛用于网上新闻频道，blog和wiki，主要的版本有0.91, 1.0, 2.0。使用RSS订阅能更快地获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码</title>
      <link href="/blog/2019/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BC%96%E7%A0%81/"/>
      <url>/blog/2019/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>出现%20 或者%%的问题</p><p><a href="http://www.soupan.info/tool/utf-8.php">http://www.soupan.info/tool/utf-8.php</a><br>%20/</p><p>编码空格字符的URL：+或%20？</p><p>当URL中的空格编码为+，什么时候编码到%20?</p><p>%7C%7C%20</p><p>||</p><p>按“转换”即可将其转换为UTF-8字符。再按“还原”即可将其还原为简体中文。</p><blockquote><p>【转】utf-8的中文是一个汉字占三个字节长度<br>英文字母和中文汉字在不同字符集编码下的字节数<br>英文字母：</p></blockquote><p>字节数 : 1;编码：GB2312</p><p>字节数 : 1;编码：GBK</p><p>字节数 : 1;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 1;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><p>中文汉字：</p><p>字节数 : 2;编码：GB2312</p><p>字节数 : 2;编码：GBK</p><p>字节数 : 2;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 3;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><p>1、美国人首先对其英文字符进行了编码，也就是最早的ascii码，用一个字节的低7位来表示英文的128个字符，高1位统一为0；</p><p>2、后来欧洲人发现尼玛你这128位哪够用，比如我高贵的法国人字母上面的还有注音符，这个怎么区分，得，把高1位编进来吧，这样欧洲普遍使用一个全字节进行编码，最多可表示256位。欧美人就是喜欢直来直去，字符少，编码用得位数少；</p><p>3、但是即使位数少，不同国家地区用不同的字符编码，虽然0–127表示的符号是一样的，但是128–255这一段的解释完全乱套了，即使2进制完全一样，表示的字符完全不一样，比如135在法语，希伯来语，俄语编码中完全是不同的符号；</p><p>4、更麻烦的是，尼玛这电脑高科技传到中国后，中国人发现我们有10万多个汉字，你们欧美这256字塞牙缝都不够。于是就发明了GB2312这些汉字编码，典型的用2个字节来表示绝大部分的常用汉字，最多可以表示65536个汉字字符，这样就不难理解有些汉字你在新华字典里查得到，但是电脑上如果不处理一下你是显示不出来的了吧。</p><p>5、这下各用各的字符集编码，这世界咋统一？俄国人发封email给中国人，两边字符集编码不同，尼玛显示都是乱码啊。为了统一，于是就发明了unicode，将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码，现在unicode可以容纳100多万个符号，每个符号的编码都不一样，这下可统一了，所有语言都可以互通，一个网页页面里可以同时显示各国文字。</p><p>6、然而，unicode虽然统一了全世界字符的二进制编码，但没有规定如何存储啊，亲。x86和amd体系结构的电脑小端序和大端序都分不清，别提计算机如何识别到底是unicode还是acsii了。如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。这样导致一个后果：出现了Unicode的多种存储方式。</p><p>7、互联网的兴起，网页上要显示各种字符，必须统一啊，亲。utf-8就是Unicode最重要的实现方式之一。另外还有utf-16、utf-32等。UTF-8不是固定字长编码的，而是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。这是种比较巧妙的设计，如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p><p>8、注意unicode的字符编码和utf-8的存储编码表示是不同的，例如”严”字的Unicode码是4E25，UTF-8编码是E4B8A5，这个7里面解释了的，UTF-8编码不仅考虑了编码，还考虑了存储，E4B8A5是在存储识别编码的基础上塞进了4E25。</p><p>9、UTF-8 使用一至四个字节为每个字符编码。128 个 ASCII 字符（Unicode 范围由 U+0000 至 U+007F）只需一个字节，带有变音符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及马尔代夫语（Unicode 范围由 U+0080 至 U+07FF）需要二个字节，其他基本多文种平面（BMP）中的字符（CJK属于此类-Qieqie注）使用三个字节，其他 Unicode 辅助平面的字符使用四字节编码。</p><p>10、最后，要回答你的问题，常规来看，中文汉字在utf-8中到底占几个字节，一般是3个字节，最常见的编码方式是1110xxxx 10xxxxxx 10xxxxxx。</p><hr><blockquote><p>知乎解答 <a href="https://www.zhihu.com/question/23374078">https://www.zhihu.com/question/23374078</a><br>Unicode 是「字符集」<br>UTF-8 是「编码规则」<br>其中：<br>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）<br>编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）<br>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和UTF-8、UTF-16、UTF-32 等等编码……<br>Unicode 字符集为每一个字符分配一个码位，例如「知」的码位是 30693，记作 U+77E5（30693的十六进制为 0x77E5）。</p></blockquote><p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节：</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编码 </tag>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-hello-world/"/>
      <url>/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图片链接</title>
      <link href="/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5/"/>
      <url>/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p> github头像地址链接<br> <a href="https://avatars0.githubusercontent.com/u/23631580?s=400&amp;u=8adfff85bef758535f26ec7c91204d21da557643&amp;v=4">https://avatars0.githubusercontent.com/u/23631580?s=400&amp;u=8adfff85bef758535f26ec7c91204d21da557643&amp;v=4</a><br> 微信头像地址<br> <a href="http://s2-cdn.oneitfarm.com/e12ece12233b4059860acf48637d830a.jpg">http://s2-cdn.oneitfarm.com/e12ece12233b4059860acf48637d830a.jpg</a><br> 动态壁纸链接：<br> <a href="https://source.unsplash.com/collection/collectionid/1600x900">https://source.unsplash.com/collection/collectionid/1600x900</a><br> <a href="https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture">https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture</a><br> <a href="https://api.dujin.org/bing/1920.php">https://api.dujin.org/bing/1920.php</a><br> <a href="https://api.dujin.org/bing/1366.php">https://api.dujin.org/bing/1366.php</a></p><p>blog背景链接：<br>wechat:<br><a href="http://s2-cdn.oneitfarm.com/ec13d36268ae41d7aaf87d5505324b6a.png">http://s2-cdn.oneitfarm.com/ec13d36268ae41d7aaf87d5505324b6a.png</a>   (迷你版本)<br><a href="http://s2-cdn.oneitfarm.com/fc44dd8d7da4467da3831cd9e6229e19.jpg">http://s2-cdn.oneitfarm.com/fc44dd8d7da4467da3831cd9e6229e19.jpg</a><br>alipay:<br><a href="http://s2-cdn.oneitfarm.com/2eef3a681187495aa43ff8bbe1173c09.png">http://s2-cdn.oneitfarm.com/2eef3a681187495aa43ff8bbe1173c09.png</a>   (迷你版本)<br><a href="http://s2-cdn.oneitfarm.com/96c2b14feb774e49ae2d110bb500770c.jpg">http://s2-cdn.oneitfarm.com/96c2b14feb774e49ae2d110bb500770c.jpg</a></p><p>网站默认背景：<br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/top_img_index.jpg">https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/top_img_index.jpg</a></p><p>文字默认图片：<br>default_cover: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png</a></p><p>阅读背景：<br>archive_img: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/archive.jpg">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/archive.jpg</a></p><p>tag背景：<br>tag_img: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/tag-bg.png">https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/tag-bg.png</a></p><p>目录背景：<br>category_img: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/category-bg">https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/category-bg</a></p><p>如果你有使用hexo-douban去生成movie界面，可配置這個<br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/Photo/movie.jpg">https://cdn.jsdelivr.net/gh/jerryc127/CDN/Photo/movie.jpg</a></p><p>评论背景<br><a href="http://s2-cdn.oneitfarm.com/94f489ea603c42ed854f035fe491222d.png">http://s2-cdn.oneitfarm.com/94f489ea603c42ed854f035fe491222d.png</a></p><p>404背景<br><a href="http://s2-cdn.oneitfarm.com/b09dd72b0fb94cbaab76bdfbb121c4d6.jpg">http://s2-cdn.oneitfarm.com/b09dd72b0fb94cbaab76bdfbb121c4d6.jpg</a><br>icp背景<br><a href="http://s2-cdn.oneitfarm.com/850aa332dae84b7c8f82f5d0631aa154.png">http://s2-cdn.oneitfarm.com/850aa332dae84b7c8f82f5d0631aa154.png</a></p><p>loading 的svg<br><a href="http://s2-cdn.oneitfarm.com/7ab2d4e7a3a34c81912580725f45c393.svg">http://s2-cdn.oneitfarm.com/7ab2d4e7a3a34c81912580725f45c393.svg</a></p><p>algolia的svg<br><a href="http://s2-cdn.oneitfarm.com/0339c65e9ab74f3e919624ed02755dba.svg">http://s2-cdn.oneitfarm.com/0339c65e9ab74f3e919624ed02755dba.svg</a></p><p>私有的bg<br><a href="https://s2-cdn.oneitfarm.com/92b19077218b48d8b6c1f8726d736c9f.jpg">https://s2-cdn.oneitfarm.com/92b19077218b48d8b6c1f8726d736c9f.jpg</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> photo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PV,UV</title>
      <link href="/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-My-New-Post/"/>
      <url>/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-My-New-Post/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>PV：页面访问量，即PageView，用户每次对网站的访问均被记录，用户对同一页面的多次访问，访问量累计。 UV：独立访问用户数：即UniqueVisitor，访问网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
          <category> PlayStation </category>
          
          <category> Games </category>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
