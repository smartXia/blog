<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Some</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>https://smartxia.github.io/blog</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2021-11-16T03:14:33.111Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>golang调度</title>
    <link href="https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Channel/"/>
    <id>https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Channel/</id>
    <published>2021-11-15T10:56:27.000Z</published>
    <updated>2021-11-16T03:14:33.111Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><strong>Channel</strong></p><h3><span id="设计原理">设计原理</span></h3><p>不要通过恭喜内存的方式进行通信，二十通过通信的方式共享内存。</p><p>很多主流编程语言中，多个线程传递数据方式一般情况都是共享内存，为了解决线程竞争，需要限制同一时间读写这些变量的线程数量</p><p>虽然可以通过共享内存加互斥锁进行通信，但是go提供了一种不同并发的模型，即顺序通讯进程，</p><p>Gorouting 和channel分别对应csp中实体和传递信息媒介。</p><p><strong>gorutine通过channel传递数据</strong></p><p>两个独立的goroutine ，一个会向channel中发送数据，另一个会从channel中读取数据，两个能独立的运行，并不存在直接关联，但是通过channel完成通讯</p><p><strong>先入先出原则</strong>（FIFO）</p><ul><li>先从channel读取数据的goroutine会先接受到数据</li><li>先向channel发送数据的goroutine会得到先发送的权力</li></ul><p>这种 FIFO 的设计是相对好理解的，但是稍早的 Go 语言实现却没有严格遵循这一语义，我们能在 <a href="https://github.com/golang/go/issues/11506">runtime: make sure blocked channels run operations in FIFO order</a> 中找到关于带缓冲区的 Channel 在执行收发操作时没有遵循先进先出的讨论<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:2">2</a>。</p><ul><li>发送方会向缓冲区写入数据，然后唤醒接收方，多个接受方会先尝试从缓冲区读取数据，如果没有读取到会重新陷入休眠。</li><li>接收方会从缓冲区去读数据，然后唤醒接收方，发送方会尝试像缓冲去写入数据，如果缓冲区已满会重新陷入休眠</li></ul><p>这种基于重试的机制会导致channel的处理遵循先进先出的原则。</p><p><strong>无锁管道</strong></p><p><strong>数据结构</strong></p><p>Go在channel中运行使用runtime.hchan ,新建chnanel结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="keyword">uint</span></span><br><span class="line">dataqsiz <span class="keyword">uint</span></span><br><span class="line">buf      unsafe.Pointer</span><br><span class="line">elemsize <span class="keyword">uint16</span></span><br><span class="line">closed   <span class="keyword">uint32</span></span><br><span class="line">elemtype *_type</span><br><span class="line">sendx    <span class="keyword">uint</span></span><br><span class="line">recvx    <span class="keyword">uint</span></span><br><span class="line">recvq    waitq</span><br><span class="line">sendq    waitq</span><br><span class="line"></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的channel，如上结构构造地城循环队列：五个字段</p><ul><li>qcount channel中元素个数</li><li>dataqsiz channel循环长度</li><li>buf channel缓冲指针</li><li>sendx channel发送操作处理到的位置</li><li>recvx channel 接受的操作位置</li></ul><p>除此之外，elemsize elemtype 标识channel收发的元素类型和大小</p><p>sendq和recvq存储当前channel由于缓冲区元素不足而阻塞的goroutine 列表，这些等待队列可以用双向列表runtime.waitq标识，链表中所有元素都是runtime.sudog</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 表示一个在等待列表中的 Goroutine，该结构中存储了两个分别指向前后 <a href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 的指针以构成链表。</p><p><strong>创建管道</strong></p><p>go中所有channel节点创建都会使用make关键字，编译器会将make(chan int,10)表达式转换成OMAKE类型的节点，并在类型检查阶段，将OMAKEl类型节点转为OMAKECHAN类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func typecheck1(n *Node, top int) (res *Node) &#123;</span><br><span class="line">switch n.Op &#123;</span><br><span class="line">case OMAKE:</span><br><span class="line">...</span><br><span class="line">switch t.Etype &#123;</span><br><span class="line">case TCHAN:</span><br><span class="line">l &#x3D; nil</span><br><span class="line">if i &lt; len(args) &#123; &#x2F;&#x2F; 带缓冲区的异步 Channel</span><br><span class="line">...</span><br><span class="line">n.Left &#x3D; l</span><br><span class="line">&#125; else &#123; &#x2F;&#x2F; 不带缓冲区的同步 Channel</span><br><span class="line">n.Left &#x3D; nodintconst(0)</span><br><span class="line">&#125;</span><br><span class="line">n.Op &#x3D; OMAKECHAN</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一阶段会对传入 <code>make</code> 关键字的缓冲区大小进行检查，如果我们不向 <code>make</code> 传递表示缓冲区大小的参数，那么就会设置一个默认值 0，也就是当前的 Channel 不存在缓冲区。</p><ul><li>如果当前 Channel 中不存在缓冲区，那么就只会为 <a href="https://draveness.me/golang/tree/runtime.hchan"><code>runtime.hchan</code></a> 分配一段内存空间；</li><li>如果当前 Channel 中存储的类型不是指针类型，会为当前的 Channel 和底层的数组分配一块连续的内存空间；</li><li>在默认情况下会单独为 <a href="https://draveness.me/golang/tree/runtime.hchan"><code>runtime.hchan</code></a> 和缓冲区分配内存；</li></ul><p>在函数的最后会统一更新 <a href="https://draveness.me/golang/tree/runtime.hchan"><code>runtime.hchan</code></a> 的 <code>elemsize</code>、<code>elemtype</code> 和 <code>dataqsiz</code> 几个字段。</p><p><strong>发送数据</strong></p><p>当我们想要向Channel发送数据时候，就需要使用ch&lt;-i语句，编译器将会将它解析冲OSEND节点，并在xxx ,转换runtime.channelsend1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span> *<span class="title">Node</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OSEND:</span><br><span class="line">n1 := n.Right</span><br><span class="line">n1 = assignconv(n1, n.Left.Type.Elem(), <span class="string">&quot;chan send&quot;</span>)</span><br><span class="line">n1 = walkexpr(n1, init)</span><br><span class="line">n1 = nod(OADDR, n1, <span class="literal">nil</span>)</span><br><span class="line">n = mkcall1(chanfn(<span class="string">&quot;chansend1&quot;</span>, <span class="number">2</span>, n.Left.Type), <span class="literal">nil</span>, init, n.Left, n1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://draveness.me/golang/tree/runtime.chansend1"><code>runtime.chansend1</code></a> 只是调用了 <a href="https://draveness.me/golang/tree/runtime.chansend"><code>runtime.chansend</code></a> 并传入 Channel 和需要发送的数据。<a href="https://draveness.me/golang/tree/runtime.chansend"><code>runtime.chansend</code></a> 是向 Channel 中发送数据时一定会调用的函数，该函数包含了发送数据的全部逻辑，如果我们在调用时将 <code>block</code> 参数设置成 <code>true</code>，那么表示当前发送操作是阻塞的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止多个线程并发修改数据。如果 Channel 已经关闭，那么向该 Channel 发送数据时会报 “send on closed channel” 错误并中止程序。</p><p>因为 <a href="https://draveness.me/golang/tree/runtime.chansend"><code>runtime.chansend</code></a> 函数的实现比较复杂，所以我们这里将该函数的执行过程分成以下的三个部分：</p><ul><li>当存在等待的接收者时，通过 <a href="https://draveness.me/golang/tree/runtime.send"><code>runtime.send</code></a> 直接将数据发送给阻塞的接收者；</li><li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；</li><li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li></ul><p>小结：</p><h3><span id="小结">小结 </span></h3><p>我们在这里可以简单梳理和总结一下使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p><ol><li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；</li><li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 <code>sendx</code> 所在的位置上；</li><li>如果不满足上面的两种情况，会创建一个 <a href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 结构并将其加入 Channel 的 <code>sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li></ol><p>发送数据的过程中包含几个会触发 Goroutine 调度的时机：</p><ol><li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度；</li><li>发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 Channel 的 <code>sendq</code> 队列并调用 <a href="https://draveness.me/golang/tree/runtime.goparkunlock"><code>runtime.goparkunlock</code></a> 触发 Goroutine 的调度让出处理器的使用权；</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang调度</title>
    <link href="https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2021-11-15T10:56:27.000Z</published>
    <updated>2021-11-15T11:00:55.187Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>golang调度</title>
    <link href="https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-%E8%B0%83%E5%BA%A6/"/>
    <id>https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-%E8%B0%83%E5%BA%A6/</id>
    <published>2021-11-15T10:56:27.000Z</published>
    <updated>2021-11-15T10:57:17.638Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>数据四层七层</title>
    <link href="https://smartxia.github.io/blog/2021/11/10/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/"/>
    <id>https://smartxia.github.io/blog/2021/11/10/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/</id>
    <published>2021-11-10T07:08:25.000Z</published>
    <updated>2021-11-10T07:09:13.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP-析构函数-destruct</title>
    <link href="https://smartxia.github.io/blog/2021/11/10/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
    <id>https://smartxia.github.io/blog/2021/11/10/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</id>
    <published>2021-11-10T03:29:02.837Z</published>
    <updated>2021-11-10T03:29:02.837Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3><span id="析构函数destruct">析构函数destruct</span></h3><p><img src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：<strong>construct()在初始化对象的时候默认执行的<br>析构函数：</strong>destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data &#x3D; [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#39;appkey&#39;] &#x3D; getAppkey();</span><br><span class="line">        $data[&#39;channel&#39;] &#x3D; getChannel();</span><br><span class="line">        $this-&gt;data[] &#x3D; $data;</span><br><span class="line">        &#x2F;&#x2F;这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id &#x3D; $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#39;id &lt;&#39; &#x3D;&gt; $id - 50000</span><br><span class="line">            ], &#39;&#39;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend&#x3D;new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="php" scheme="https://smartxia.github.io/blog/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2021/11/10/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
    <id>https://smartxia.github.io/blog/2021/11/10/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</id>
    <published>2021-11-10T03:29:02.827Z</published>
    <updated>2021-11-10T03:29:02.827Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. :&#x3D; &#x3D; &#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">:&#x3D; 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">&#x3D; 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 :&#x3D; make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val :&#x3D; make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">ch :&#x3D; make(chan int, 100) &#x2F;&#x2F; make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据</span><br><span class="line">&#x2F;&#x2F; 并把值赋给 v</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>开发空间使用文档</title>
    <link href="https://smartxia.github.io/blog/2021/09/01/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>https://smartxia.github.io/blog/2021/09/01/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</id>
    <published>2021-09-01T07:44:30.000Z</published>
    <updated>2021-11-12T05:40:08.634Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="开发空间使用文档">开发空间使用文档</span></h2><h3><span id="项目设置">项目设置</span></h3><h4><span id="项目主页">项目主页</span></h4><p>项目名称：默认创建的时候的名称，可以在这里修改</p><p>封面：项目的封面，可以用来发布，图片尺寸符合页面提示内容</p><p>简介：项目的一些简单介绍</p><h4><span id="代码仓库">代码仓库</span></h4><p>代码仓库默认分为语言类型的git仓库，所带有的框架默认支持打包，和支持中台的基本框架</p><p>前端仓库：vue idg等</p><p>后端仓库：golang java php node 等 </p><p>ios,android,中台小程序，微信小程序，h5，浏览器插件，pc，跨段应用，</p><p>勤务仓库，和区块链专用仓库，并支持复制其他仓库</p><h5><span id="仓库使用">仓库使用：</span></h5><p>默认开发者为主master分支管理员</p><p>分支:</p><p>合并请求：可以合并其他用户提交的合并请求</p><p>标签：利用此标签可以用来打包集成各类型的资产包和镜像</p><p>成员：可以添加成员</p><h4><span id="镜像管理">镜像管理</span></h4><p>可以分为两大类：镜像（可以直接放在服务器运行的）包管理（可以支持其他服务引入的）</p><p>镜像根据仓库类型里的tag然后进行打包：</p><p>包括：php(5-*7)类型，golang(13-15)java 和其他类型打包 vue类型镜像</p><p>包根据仓库里的tag进行打包：</p><p>包括:npm android ios composer h5等类型dab</p><h4><span id="成员管理">成员管理</span></h4><p>此处用来添加用户，其中项目成员基本权限要有：项目负责人或者项目参与者。支持批量添加用户角色</p><h4><span id="部署设置">部署设置</span></h4><p>b部署设置放在此处比较早，需要后端或者项目负责人添加。</p><p>其中包括：对项目所需要的容器资源类型进行配置，和资源模板配置，cpu membery port 等</p><h3><span id="产品定义">产品定义</span></h3><ul><li>模块列表：默认有主模块。主模块权限属于第一个使用产品定义的人，并非创建者。</li></ul><p>可以选择新增模块，填写模块名称和描述，模块标签</p><p>模块之间支持的功能：利用密钥来实现复制（内容复制）和分享（通道分享）</p><p>模块之间可以添加用户，给用户赋予模块负责人、模块参与者（只有浏览权限）</p><ul><li><p>任务列表：</p><p>包括产品、后端、设计使用的基本工具和文档</p><p>需求定义：产品需要写的一些基本功能提供。项目创立之初的一些信息收集，和基本的作图，设计用例，数据模型等功能的支持</p><p>设计文档：一些基本的设计图片文稿，竞品分析，设计用的图片且支持图片拖动执行</p><p>技术定义：后端的一些基本api文档填写</p><p>数据定义：数据库相关的基本使用</p><p>每个分类下分为各种的类型使用，种类繁多，满足项目创立之初所有的使用</p></li></ul><h3><span id="多语言管理">多语言管理</span></h3><h4><span id="项目多语言">项目多语言</span></h4><p>支撑项目内关键词，各个国家语言的翻译使用</p><h3><span id="会议记录">会议记录</span></h3><p>记录项目成员每次开会使用的基本任务</p><h3><span id="接入管理">接入管理</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="资源管理">资源管理</span></h3><p>容器云所需的资源购买和资源配置</p><h3><span id="部署空间">部署空间</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="项目管理">项目管理</span></h3><p>项目issue配置</p><h3><span id="cicd">CICD</span></h3><p>项目自动化测试</p><h3><span id="发布管理">发布管理</span></h3><p>项目发布到市场</p><h3><span id="gui管理">GUI管理</span></h3><p>gui前端界面自动化添加</p><h3><span id="wiki">WIKI</span></h3><p>项目Wiki记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GOLGANG-笔记6-学习日志位运算符</title>
    <link href="https://smartxia.github.io/blog/2021/08/27/GOLANG/GOLGANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://smartxia.github.io/blog/2021/08/27/GOLANG/GOLGANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2021-08-27T01:55:06.000Z</published>
    <updated>2021-11-12T05:40:08.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>位运算：位运算符对整数在内存中的二进制位进行操作。</p><p> &amp;, |, 和 ^ </p><p>》》》 《《《</p><p>数组</p><p>var a 【5】string</p><p>a:=[5]string[“2”,”3”,”4”,”2”,”3”]</p><p>a:=[….]string[“2”,”3”,”4”,”2”,”3”]</p><p>空指针：指针定义后没有分配到任何变量就会错</p><p>旧的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  topocpzejlq4huin6cmhieqxxn8fep7n  263</p><p>新的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  8191a23b9783477599b9f01f53f5bab7 37</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机基础-转义字符</title>
    <link href="https://smartxia.github.io/blog/2021/06/22/Wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/06/22/Wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</id>
    <published>2021-06-22T02:54:33.000Z</published>
    <updated>2021-11-12T05:40:08.614Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是转义字符有什么用">什么是转义字符？有什么用？</span></h3><p>转义字符是一种特殊的字符常量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://smartxia.github.io/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="转义字符" scheme="https://smartxia.github.io/blog/tags/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    
      <category term="wiki" scheme="https://smartxia.github.io/blog/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式-修饰符</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2021-06-07T08:09:29.000Z</published>
    <updated>2021-11-10T03:29:02.849Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ul><li><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p></li><li><p>标记不写在正则表达式里，标记位于表达式之外</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;pattern&#x2F;flags</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h4><span id="元字符">元字符</span></h4><h4><span id="运算符优先级">运算符优先级</span></h4><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/categories/regex/"/>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式-语法</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/</id>
    <published>2021-06-07T05:40:59.000Z</published>
    <updated>2021-11-10T03:29:02.849Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></p><h4><span id="1普通字符1-9-a-z-a-z-标点符号和一些其他符号">1.普通字符：1-9 a-z A-Z 标点符号和一些其他符号。</span></h4><p><img src="//s2-cdn.oneitfarm.com/eab92d4dcdab496abde257a6adf121c8.png" alt></p><table><thead><tr><th>key</th><th>val</th><th>desc</th><th>exp</th></tr></thead><tbody><tr><td>/*/</td><td></td><td>基础语法区隔，转义符号</td><td></td></tr><tr><td>^</td><td></td><td>开始位置</td><td></td></tr><tr><td>$</td><td></td><td>结束位置</td><td></td></tr><tr><td>[0-9]</td><td></td><td>匹配数字</td><td></td></tr><tr><td>[a-z]</td><td></td><td>小写字母</td><td></td></tr><tr><td>[A-Z]</td><td></td><td>大写字母</td><td></td></tr><tr><td>+</td><td>runoo+b</td><td>匹配一个或多个</td><td></td></tr><tr><td>-</td><td></td><td>连接字符</td><td></td></tr><tr><td>{}</td><td>{3,5}</td><td>字符长度3-5</td><td>^[a-z0-9_-]{3,15}$</td></tr><tr><td>？</td><td>colou?r</td><td>匹配 color 或者 colour</td><td></td></tr><tr><td>…</td><td>[…]</td><td>匹配所有字符</td><td></td></tr><tr><td>( )</td><td>(  )</td><td>子表达式的开始和结束位置</td><td></td></tr></tbody></table><h4><span id="2非打印字符">2.非打印字符</span></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/categories/regex/"/>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-06-07T01:49:48.000Z</published>
    <updated>2021-11-10T03:29:02.829Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><!-- toc --><ul><li><a href="#10-网络协议tcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</a></li><li><a href="#11-请求头">1.1 请求头</a></li><li><a href="#12-三次握手四次挥手">1.2 三次握手四次挥手</a></li><li><a href="#13-报文抓取工具">1.3 报文抓取工具</a><ul><li><a href="#20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</a></li></ul></li><li><a href="#21-请求报文">2.1 请求报文</a></li><li><a href="#22-响应报文">2.2 响应报文</a></li><li><a href="#23-http-抓取工具">2.3 HTTP 抓取工具</a></li><li><a href="#24-session-cookie">2.4 Session Cookie</a><ul><li><a href="#30-总结">3.0 总结</a></li></ul></li></ul><!-- tocstop --><h4><span id="10-网络协议tcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</span></h4><ul><li><p>TCP 七层网络模型<br>主机层：<br>媒介层：</p><p><img src="http://s2-cdn.oneitfarm.com/767fb54c00ef41d1b15f28a8c33f3d16.png" alt></p></li></ul><h4><span id="11-请求头">1.1 请求头</span></h4><h4><span id="12-三次握手四次挥手">1.2 三次握手四次挥手</span></h4><h4><span id="13-报文抓取工具">1.3 报文抓取工具</span></h4><h3><span id="20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</span></h3><p><img src="//s2-cdn.oneitfarm.com/205566ffbffc4786af2443e348192532.png" alt></p><h4><span id="21-请求报文">2.1 请求报文</span></h4><h4><span id="22-响应报文">2.2 响应报文</span></h4><h4><span id="23-http-抓取工具">2.3 HTTP 抓取工具</span></h4><h4><span id="24-session-cookie">2.4 Session Cookie</span></h4><h3><span id="30-总结">3.0 总结</span></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://smartxia.github.io/blog/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>The MIT License</title>
    <link href="https://smartxia.github.io/blog/2021/05/27/Wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://smartxia.github.io/blog/2021/05/27/Wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-05-27T01:25:29.000Z</published>
    <updated>2021-11-12T05:40:08.605Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>MIT许可证（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件授权条款（如GPL、LGPL、BSD）相比，MIT是相对宽松的软件授权条款。</p></blockquote><h3><span id="1条款内容">1.条款内容</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span><br><span class="line">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br></pre></td></tr></table></figure><h3><span id="2mit与其他开源许可证的区别">2.MIT与其他开源许可证的区别</span></h3><p><img src="//s2-cdn.oneitfarm.com/2bec9f7690a945a499ebc95fd84a0cb5.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="其他" scheme="https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>孔乙己和阿Q</title>
    <link href="https://smartxia.github.io/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/"/>
    <id>https://smartxia.github.io/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/</id>
    <published>2021-05-26T02:23:14.000Z</published>
    <updated>2021-11-10T03:29:02.848Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>孔乙己原为鲁迅笔下的一个旧时代的人物，我们可以简单理解为一个臭读书的<br>阿Q我们听到的最多的是阿Q精神：自恋不自知的小人物<br>这些都是鲁迅笔下的小人物，之前不大明白鲁迅为何喜欢写这些我们现在看起来抨击小人物的短片小说，<br>包括对闰土 阿Q 孔乙己 祥林嫂 范爱农等等这些现在看起来很离谱的事情，这要是放到现在不得不说是一股奇葩的力量<br>在微博贡献，因为本人也是个冲浪的键盘侠。<br>但了解过鲁迅大大说过一句很经典的话：学医救不了中国人<br>当时是民国 想想这句话到底有几个味道大家便知道了<br>现在提起来中国人，你走到哪里都是自豪的，除了蜜汁自信呢的美帝，最起码在国外是没问题的，对于一个长时间被中央人民广播电台熏陶的年青人是这样的</p><p>当时中国是被侵略，被十几个人打，想想那画面，不敢还手，对于国家至此，何况老百姓。<br>其实鲁迅笔下任务用的最多为小小的底层任务对社会，谈不上社会，而是对自己的生活圈子里造成的影响，可有可无的那种。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>从正则表达式的iUs说说模式修正符</title>
    <link href="https://smartxia.github.io/blog/2021/05/25/PHP/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/05/25/PHP/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/</id>
    <published>2021-05-25T11:06:09.000Z</published>
    <updated>2021-11-10T03:29:02.835Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>本想做个简单的采集程序，发现被抓页面代码的规律后发现抓下来的内容没有放到一个数组中，而是放在一个元素中，无奈找遍资料发现在正则表达式后加上”/iUs”后竟然可以了。<br>hexo<br>网上关于iUs的说明多数都是抄袭的，没有做过多的解释，对于一个小学毕业证是买来的人来说是在是不好理解。不过幸亏Google让我找到答案。</p><p>“iUs” 在这里叫“模式修正符”。模式修正符其实就是几个字母，可以一次使用一个也可以一次使用多个，每一个都具有一定的意义，模式修正符是对正则表达式的扩展；“/模式修正符”，其中正斜线“/”为边界符。下表列出来有那些模式修正符：</p><p>模式修正符    说明<br>i    表示在和模式进行匹配进不区分大小写<br>m    将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束<br>s    如果没有使用这个模式修正符号，元字符中的”.”默认不能表示换行符号,将字符串视为单行<br>x    表示模式中的空白忽略不计<br>e    正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说)<br>A    以模式字符串开头，相当于元字符^<br>Z    以模式字符串结尾，相当于元字符$<br>U    正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式</p><h3><span id="1模式修正符m">1，模式修正符m。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;^abc&#x2F;m’;</span><br><span class="line">$string &#x3D; ‘bcd</span><br><span class="line">abc</span><br><span class="line">cba’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>匹配结果是成功的。注意：我们在使用模式修正符m的时候，将匹配字符串看成是多行而不是默认的单行，所以任何一行只要是以abc开头，就匹配成功。但是，如果能匹配的行前面有空格的话，就不能匹配了!除非修改正则表达式的匹配模式。</p><h3><span id="2模式修正符s">2，模式修正符s。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;a.*c&#x2F;s’;</span><br><span class="line">$string &#x3D; ‘adsadsa</span><br><span class="line">c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配记过也是成功的。如果你将上例中的模式修正符s去掉的话，匹配就会失败。因为模式修正符s将匹配字符串看作是单行的，所以这个时候，元字符中的”.”就可以表示换行符号了。</p><h3><span id="3模式修正符x">3，模式修正符x。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;a c&#x2F;x’;</span><br><span class="line">$string &#x3D; ‘a c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配结果是失败的。因为我们使用模式修正符x取消了模式中的空格。注意：我们无法使用模式修正符取消\s表示的空白。</p><h3><span id="4模式修正符a">4，模式修正符A。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;ac&#x2F;A’;</span><br><span class="line">$string &#x3D; ‘acahgyghvbm’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正则表达式表示的含义是匹配以ac开头的字符串，结果成功。</p><p>模式修正符Z表示的是以字符串结尾的匹配，和A的用法是一样的，我们不再进行演示。</p><h3><span id="5模式修正符u">5，模式修正符U。</span></h3><p>这个模式修正符是十分重要的!在正则表达式中，其本身是“贪婪”的。那什么是贪婪模式呢?贪婪模式的意思就是说，正则表达式默认会在查找到第一个匹配后，继续尝试后面的匹配，如果能找到匹配，则匹配最大的范围字符串。但有的时候这并不是我们想要的结果，所以我们需要取消贪婪模式。</p><p>我们还是先看一个贪婪模式的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*&lt;\&#x2F;b&gt;&#x2F;’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个实例的本意是匹配welcome，但是结果却匹配了welcome to phpfuns整个字符串(注意我们的字符串’welcome to phpfuns’，其开头和结尾正好构成了正则表达式的模式匹配，所以匹配成功)，这就是正则表达式的贪婪模式。当然，这不是我们要的结果。</p><p>取消贪婪模式<br>我们可以使用模式修正符U和元字符?两种方式取消正则表达式的贪婪模式。</p><p>模式修正符U取消贪婪模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*&lt;\&#x2F;b&gt;&#x2F;U’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>元字符?取消贪婪模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*?&lt;\&#x2F;b&gt;&#x2F;’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;dsadsadas’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意元字符的位置，我们必须在“”之前结束贪婪模式，才能达到我们的目的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 URL 中协议的省略</title>
    <link href="https://smartxia.github.io/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/"/>
    <id>https://smartxia.github.io/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/</id>
    <published>2021-05-25T01:15:06.000Z</published>
    <updated>2021-11-10T03:29:02.843Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>前天看了 Google HTML/CSS 代码风格指南，里面有很多值得借鉴的地方，也学到了一些新东西，其中第一条说道，HTML 和 CSS 代码中引用的图片、媒体、CSS 和 JS 文件中的 URL 都可以去掉协议部分（http: 和 https:），比如</p><script src="http://www.google-analytics.com/ga.js" type="text/javascript"></script><script src="https://www.google-analytics.com/ga.js" type="text/javascript"></script><p>都可以换成：</p><script src="//www.google-analytics.com/ga.js" type="text/javascript"></script><p>只要是使用 http、https 这两种协议都可以省略。原因是可以节省一点文件体积（当然只是那么一点点），另外一个原因 Google 说是可以解决混合内容的问题。起初我对这个第二点不是很了解，所以特意搜索了下。最后从 Paul Irish 的一篇文章找到答案，链接在文后。文章是两三年前写的，老外研究问题总是比我们要早啊。</p><p>以 // 开头的叫做相对URL（protocol-relative URL），相关的标准可以看 RFC 3986 Section 4.2，内容不是一般的长估计大家也没耐心去看吧。总之浏览器遇到相对 URL，则会根据当前的网页协议，自动在 // 前面加上相同的协议。如当前网页是 http 访问，那么所有的相对引用 // 都会变成http://。https 同理。如果你在本地查看，协议就会变成 file://。</p><p>所以，如果省略协议，就需要保证引用的外部资源也采用和网页相同的协议，或者保证资源可以同时通过 http 和 https 访问。经过 StackOverflow 网友测试，这种用法几乎所有的浏览器都能支持，只有在 IE7/8 下会有一点小问题，就是通过相对 URL 引用的 CSS 文件（无论 <link> 或 @import）会被下载两遍。所以对性能有一点影响。</p><p>至于 Google 提到的混合内容问题，其实是指IE有时会弹出的一个警告框：</p><p>这个框想必大家也都见过。通常是在浏览 https 网页的时候出现，原因是网页里引用了 http 协议的外部资源，由于 http 被认为是不安全的，IE 才会给出提示。如果引用的时候写成相对 URL，浏览器就会自动采用 https 协议下载，这样就解决了问题。</p><p>所以，我们平时写代码还是可以放心使用相对 URL 的，写博客的大概很少开 https，当然做项目的就例外了。如果你引用的资源里有 https 协议的就特别处理一下，或者只要 http 也能访问到资源就可以。我看了下国内的站点这么用的还不多，有一次看到百度音乐这么用过。不过 Google 很多站点都已经是这样的写法了。</p><hr>> 参考资料：<p><a href="http://paulirish.com/2010/the-protocol-relative-url/">http://paulirish.com/2010/the-protocol-relative-url/</a><br><a href="http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just">http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just</a><br><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><blockquote><p>转载 自：<a href="http://pandacafe.net/post/231?huvqlc=r5eup1">http://pandacafe.net/post/231?huvqlc=r5eup1</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="前端知识" scheme="https://smartxia.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="http://" scheme="https://smartxia.github.io/blog/tags/http/"/>
    
      <category term="https://" scheme="https://smartxia.github.io/blog/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>天气晴-2021-5-20</title>
    <link href="https://smartxia.github.io/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/"/>
    <id>https://smartxia.github.io/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/</id>
    <published>2021-05-20T01:09:27.000Z</published>
    <updated>2021-11-10T03:29:02.847Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="今天是2021年5月20日是个好日子">今天是2021年5月20日，是个好日子</span></h3><p> 早上打开电脑 撇了下右下角的电脑，是2021/5/20 嗯是个吉利的数字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>百年孤独</title>
    <link href="https://smartxia.github.io/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/"/>
    <id>https://smartxia.github.io/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/</id>
    <published>2021-05-18T01:33:24.000Z</published>
    <updated>2021-11-10T03:29:02.850Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><h3><span id="家族的第一个人被捆在树上最后一个人正被蚂蚁吃掉">家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉</span></h3></blockquote><ul><li>这本书到底讲了什么？作者想表达什么？自己有了什么样的感触<hr></li></ul><h3><span id="经典语句">经典语句</span></h3><p>1、多年以后，奥雷连诺上校站在行刑队面前，准会想起父亲带他去参观冰块的那个遥远的下午。</p><p>2、 过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂热最坚贞的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。</p><p>3、买下一张永久车票，登上一列永无终点的火车。</p><p>4、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>5、生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p><p>6、我确实一度死去，但难以忍受孤独又重返人世。</p><p>7、他渴望孤独，对整个世界的怨恨咬噬着他的内心。</p><p>8、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>9、所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。</p><p>10、这手稿上所写的事情过去不曾，将来也永远不会重复，因为命中注定要一百年处于孤独的世家决不会有出现在世上的第二次机会。</p><h3><span id="百年孤独讲述了什么">百年孤独讲述了什么</span></h3><p>《百年孤独》讲的是一个叫布恩迪亚家族百年的兴衰以及小镇马孔多的发展变迁史。</p><p>布恩迪亚家族的每一代人都在努力地摆脱孤独落后的生活状态，但是却一次又一次的失败，最终，家族的最后一个人被蚂蚁吃掉，整个屋子也被风卷走，从此消失在地球上，再未出现。</p><p>孤独会让人丧失对生活的希望。没有人喜欢孤独，布恩迪亚家族的人付出了一辈又一辈的努力，却依然是一场空，书也表现了人类的抗争，对命运的无可奈何以及天性的顽固。</p><h3><span id="百年孤独反思">百年孤独反思</span></h3><p>《百年孤独》是哥伦比亚作家加西亚·马尔克斯的一部长篇小说</p><p>百年孤独比较适合25岁以上，经历过社会的人看。这样才能读出韵味的。</p><p>说到底《百年孤独》好在它的新颖，不仅让人们看到一个不一样的故事，也让人看到了小说不一样的表现手，而且这种不一样的表现手法，被国内许多的作家所借鉴引用。这也就是《百年孤独》的好处。</p><p>可以不客气地说，《百年孤独》影响了中国当代文学的走向，国内许多的作家，正是由于看了这本小说之后，才开始写出了自己最为重要的作品，例如莫言、陈忠实、余华、阎连科等等，这些国内一线作家，那都是受到了《百年孤独》的影响，他们的作品里，都有着《百年孤独》的影子。也正是这一份影响，使得它在国人心目中，有着崇高的地位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>git 使用 connot stat</title>
    <link href="https://smartxia.github.io/blog/2021/05/17/GIT/cannot%20stat/"/>
    <id>https://smartxia.github.io/blog/2021/05/17/GIT/cannot%20stat/</id>
    <published>2021-05-17T06:12:35.000Z</published>
    <updated>2021-11-10T03:29:02.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>1.记一次使用bug<br><img src="http://s2-cdn.oneitfarm.com/c71c1444ef7b472fbad9c71ba803fa95.png" alt><br>git error: cannot stat<br>原因是因为，在某个编辑器打开了master分支的一个文件，然后切换到feat分支，文件并不消失，拉取时候出现问题，</p><p>解决办法：关掉编辑器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="git" scheme="https://smartxia.github.io/blog/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-改善golang50个有效实践</title>
    <link href="https://smartxia.github.io/blog/2021/05/14/GOLANG/GOLANG-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    <id>https://smartxia.github.io/blog/2021/05/14/GOLANG/GOLANG-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-05-14T05:24:11.000Z</published>
    <updated>2021-11-10T03:29:02.825Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>闲逛好久go论坛，找到一本适合看的教程，花了点时间将这个文章搬运过来，自己慢慢研读</p></blockquote><h4><span id="1-语言的前生今世">1 </span></h4><h4><span id="2-语言的设计哲学之一简单">2 </span></h4><h4><span id="3-语言的设计哲学之二组合">3  </span></h4><h4><span id="4-go语言的设计哲学之三并发">4  </span></h4><h4><span id="5-go-语言的设计哲学之四面向工程">5  </span></h4><h4><span id="6-参考-go-项目布局设计你的项目结构">6  </span></h4><h4><span id="7-gofmtgo代码风格的唯一标准">7  </span></h4><h4><span id="8-go-标识符的命名惯例">8  </span></h4><h4><span id="9-变量声明形式尽量保持一致">9  </span></h4><h4><span id="10-无类型常量让代码更简化">10  </span></h4><h4><span id="11-go枚举常量的惯用实现方法">11  </span></h4><h4><span id="12-定义零值可用的类型">12  </span></h4><h4><span id="13-用复合字面值作初值构造器">13  </span></h4><h4><span id="14-深入理解和高效运用切片slice">14  </span></h4><h4><span id="15-注意go-字符串是原生类型">15  </span></h4><h4><span id="16-理解包导入路径的含义">16  </span></h4><h4><span id="17-init-函数的妙用">17  </span></h4><h4><span id="18-go-函数是一等公民">18  </span></h4><h4><span id="19-defer-让你的代码更清">19  </span></h4><h4><span id="20-方法的本质">20  </span></h4><h4><span id="21-方法集合决定接口实现">21  </span></h4><h4><span id="22-变长参数函数的妙用">22  </span></h4><hr>转载自慕课资源，仅供学习使用，如有侵权联系自行删除]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
      <category term="书籍" scheme="https://smartxia.github.io/blog/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="推荐" scheme="https://smartxia.github.io/blog/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
</feed>
