<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Some</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>https://smartxia.github.io/blog</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2020-09-02T06:50:51.775Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>PHP-解决循环内存占用溢出-缓冲查询</title>
    <link href="https://smartxia.github.io/blog/2020/09/02/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/"/>
    <id>https://smartxia.github.io/blog/2020/09/02/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-09-02T06:50:51.000Z</published>
    <updated>2020-09-02T06:50:51.775Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP-深拷贝浅拷贝</title>
    <link href="https://smartxia.github.io/blog/2020/09/02/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://smartxia.github.io/blog/2020/09/02/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-09-02T06:50:07.000Z</published>
    <updated>2020-09-02T06:51:16.770Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Git-代码提交规范</title>
    <link href="https://smartxia.github.io/blog/2020/09/02/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
    <id>https://smartxia.github.io/blog/2020/09/02/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</id>
    <published>2020-09-02T06:13:27.000Z</published>
    <updated>2020-09-02T06:13:40.078Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Git commit message 是Git提交的必要信息，message的信息完整度也反映了工程师对于代码提交的重视程度，不清晰的git message信息甚至会让工程师完全回忆不起自己当初做了什么调整，导致后续代码维护成本特别大。因此为了提高线上代码库的管理程度，特此制定GIT commit message规范。</p><p>一、commit message格式<br>1、Type(必须)<br>用于说明 git commit 的类别，只允许使用下面的标识。<br>feat：新功能（feature）。<br>fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。<br>fix：产⽣diff并自动修复此问题。适合于一次提交直接修复问题<br>to：只产⽣diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix<br>docs：文档（documentation）。<br>style：格式（不影响代码运行的变动）。<br>refactor：重构（即不是新增功能，也不是修改bug的代码变动）。<br>perf：优化相关，比如提升性能、体验。<br>test：增加测试。<br>chore：构建过程或辅助工具的变动。<br>revert：回滚到上一个版本。<br>merge：代码合并。<br>sync：同步主线或分⽀的Bug</p><p>2、scope(可选)<br>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。<br>例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。<br>如果你的修改影响了不止一个scope，你可以使用*代替。</p><p>3、subject(必须)<br>subject是commit目的的简短描述，不超过50个字符。<br>1.建议使用中文。<br>2.结尾不加句号或其他标点符号。<br>根据以上规范 git commit message 将是如下的格式：<br>fix(DAO): 用户查询缺少username属性<br>feat(Controller): 用户查询接口开发</p><p>二、规范的好处<br>我们这样规范git commit到底有哪些好处呢？<br>1.便于程序员对提交历史进行追溯，了解发⽣了什么情况。<br>2.一旦约束了commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个git commit里面，这样一来整个代码改动的历史也将更加清晰。<br>3.格式化的commit message才可以用于自动化输出Change log。</p><p>三、标准执行监管<br>为了更好的执行标准，公司针对git提交会进行相关监管功能的研发，当工程师提了不合规的commit，会收到相关的邮件警告。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>前端-npm私有源加载平台</title>
    <link href="https://smartxia.github.io/blog/2020/09/01/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
    <id>https://smartxia.github.io/blog/2020/09/01/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/</id>
    <published>2020-09-01T09:30:06.000Z</published>
    <updated>2020-09-03T07:05:42.976Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="调研平台：sinopia，Verdaccio"><a href="#调研平台：sinopia，Verdaccio" class="headerlink" title="调研平台：sinopia，Verdaccio"></a>调研平台：sinopia，Verdaccio</h3><h4 id="Verdaccio"><a href="#Verdaccio" class="headerlink" title="Verdaccio"></a>Verdaccio</h4><h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><p><a href="https://verdaccio.org/docs/en/configuration">https://verdaccio.org/docs/en/configuration</a></p><p>搭建：</p><h5 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h5><p>身份验证与您正在使用的auth <a href="https://verdaccio.org/docs/en/plugins">插件相关</a>。软件包限制也由<a href="https://verdaccio.org/docs/en/packages">Package Access</a>处理。</p><p>客户端：基于npm客户端登录后会生成一个配置令牌，在.npmrc中</p><p><a href="https://docs.npmjs.com/files/npmrc">https://docs.npmjs.com/files/npmrc</a></p><p>且允许匿名发布包</p><p>包发布的时候允许阻止访问和下载</p><p>服务端关于组的验证:</p><p>​    access: $all-&gt;<br>​    publish: $all<br>​    proxy: npmjs</p><p><img src= "/blog/img/loading.gif" data-lazy-src="//s2-cdn.oneitfarm.com/186bdf368bd54a57b12eb71ba2e10636.png" alt="image-20200901175328057"></p><p> 不同的包读取权限限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">packages:</span><br><span class="line">  <span class="string">&#x27;jquery&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $all</span><br><span class="line">  <span class="string">&#x27;my-company-*&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">  <span class="string">&#x27;@my-local-scope/*&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">    proxy: npmjs</span><br></pre></td></tr></table></figure><p>组 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;company-*&#39;:</span><br><span class="line">  access: admin internal</span><br><span class="line">  publish: admin</span><br><span class="line">  proxy: server1</span><br><span class="line">&#39;supersecret-*&#39;:</span><br><span class="line">  access: secret super-secret-area ultra-secret-area</span><br><span class="line">  publish: secret ultra-secret-area</span><br><span class="line">  proxy: server1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>其他-CRLF、CR、LF详解</title>
    <link href="https://smartxia.github.io/blog/2020/09/01/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://smartxia.github.io/blog/2020/09/01/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-09-01T06:42:31.000Z</published>
    <updated>2020-09-01T06:47:37.168Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>很长一段时间里，对于CRLF、CR、LF的理解仅限于不同操作系统下对换行符的定义。所谓知其然需知其所以然，从学习中找到乐趣，对知识的记忆才会更加深刻。</p><p>名词解释<br>CR：Carriage Return，对应ASCII中转义字符\r，表示回车<br>LF：Linefeed，对应ASCII中转义字符\n，表示换行<br>CRLF：Carriage Return &amp; Linefeed，\r\n，表示回车并换行<br>众所周知，Windows操作系统采用两个字符来进行换行，即CRLF；Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行；另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。</p><p>野史<br>老式机械打字机（来源：视觉中国）<br>据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。</p><p>当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。</p><p>随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。</p><p>结论<br>许多现代的文本编辑器和命令行工具都提供了可选择的换行符配置，方便用户按照自己的意愿来改变换行符的表现形式，所以我们只需要知道CRLF、CR、LF的作用即可。</p><p>参考文献<br><a href="http://en.wikipedia.org/wiki/Newline">http://en.wikipedia.org/wiki/Newline</a><br><a href="https://en.wikipedia.org/wiki/Control_character">https://en.wikipedia.org/wiki/Control_character</a><br><a href="https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types">https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types</a></p><p>作者：JSoon<br>链接：<a href="https://www.jianshu.com/p/b03ad01acd69">https://www.jianshu.com/p/b03ad01acd69</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>关于blog更新周期</title>
    <link href="https://smartxia.github.io/blog/2020/08/31/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/"/>
    <id>https://smartxia.github.io/blog/2020/08/31/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/</id>
    <published>2020-08-31T02:22:54.000Z</published>
    <updated>2020-08-31T07:51:59.002Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>每周 三篇基础知识文档编写</p><p>每两周一次总结工作情况</p><p>每月一次的软件使用教程记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP-辅助函数</title>
    <link href="https://smartxia.github.io/blog/2020/08/28/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"/>
    <id>https://smartxia.github.io/blog/2020/08/28/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-28T05:33:20.000Z</published>
    <updated>2020-08-31T02:11:31.778Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>PHP-匿名类匿名函数（闭包）</title>
    <link href="https://smartxia.github.io/blog/2020/08/28/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/"/>
    <id>https://smartxia.github.io/blog/2020/08/28/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/</id>
    <published>2020-08-28T03:31:08.000Z</published>
    <updated>2020-09-03T07:15:07.689Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4 id="1-写一个匿名函数"><a href="#1-写一个匿名函数" class="headerlink" title="1.写一个匿名函数"></a>1.写一个匿名函数</h4><blockquote><p>类中 的写法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $result = array_reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$result, $value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array_merge($result, array_values($value));</span><br><span class="line">        &#125;, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将匿名函数交个一个变量</span></span><br><span class="line">        $a = <span class="function"><span class="keyword">function</span> (<span class="params">$result, $value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array_merge($result, array_values($value));</span><br><span class="line">        &#125;;</span><br><span class="line">        $result = array_reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], $a, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> $result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-理解一个闭包（匿名函数）"><a href="#2-理解一个闭包（匿名函数）" class="headerlink" title="2.理解一个闭包（匿名函数）"></a>2.理解一个闭包（匿名函数）</h4><p>目前php用到闭包的数组函数包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">array_map — 为数组的每个元素应用回调函数</span><br><span class="line">array_walk — 使用用户自定义函数对数组中的每个元素做回调处理</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">array_filter — 用回调函数过滤数组中的单元</span><br><span class="line">该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回结果数组中。数组键名保持不变。</span><br><span class="line">array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引</span><br><span class="line">array_intersect_ukey — 用回调函数比较键名来计算数组的交集</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">拼接成类似 (1,2,3,4,5) </span><br><span class="line"></span><br><span class="line">array_walk_recursive — 对数组中的每个成员递归地应用用户函数</span><br><span class="line">----等等</span><br><span class="line">常用的就是: array_map array_walk</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-临时总结"><a href="#3-临时总结" class="headerlink" title="3.临时总结"></a>3.临时总结</h4><p><strong>异同点</strong><br> array_filter() 重点在于过滤（而不是新增）某个元素，当你处理到一个元素时，返回过滤后的数组<br> array_map() 重点在于遍历一个数组或多个数组的元素，返回一个新的数组<br> array_walk() 重点在于遍历数组进行某种操作</p><p> array_filter() 和 array_walk()对一个数组进行操作，数组参数在前，函数参数在后<br> array_map() 可以处理多个数组，因此函数参数在前，数组参数在后，可以根据实际情况放入多个数组参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="Closure" scheme="https://smartxia.github.io/blog/tags/Closure/"/>
    
      <category term="匿名函数" scheme="https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
      <category term="匿名类" scheme="https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>PHP-运行模式cli fastcgi</title>
    <link href="https://smartxia.github.io/blog/2020/08/28/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartxia.github.io/blog/2020/08/28/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-28T03:31:08.000Z</published>
    <updated>2020-11-25T06:51:55.661Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>　　<strong>1.cgi全称“通用网关接口”(Common Gateway Interface)， 它可以让一个客户端，从浏览器向Web服务器上的程序请求数据，是客户端和程序之间传输数据的一种标准，另外CGI独立于任何语言，所以可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。CGI针对每个用户请求都要开单独的子进程去维护，执行结束处理掉这个进程。典型的fork-and-execute方式</strong></p><p>　　<strong>2.fastcgi，根据1中cgi的特性，可以知道消耗很大，如果很多用户请求，则会申请很多个子进程。。这时候出现了FastCGI。FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。这个是当下用的最多的了。。linux+nginx+php+mysql</strong></p><p>　FastCGI的工作原理是：</p><p><em>(1)、Web Server启动时载入FastCGI进程管理器【PHP的FastCGI进程管理器是PHP-FPM(php-FastCGI Process Manager)】（nginx);</em><br><em>(2)、FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自WebServer的连接。</em><br><em>(3)、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</em><br><em>(4)、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。在正常的CGI模式中，php-cgi或 .exe在此便退出了。</em><br><em>在CGI模式中，你可以想象 CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</em><br>　　<em>3.module形式一般用于apache，模块模式是以mod_php5模块的形式集成，此时mod_php5模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求，然后将处理后的结果返回给Apache。</em><br>　　<em>4.cli模式。命令行执行php，一般不用。我们在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式；也可以直接命令行执行php xxx.php</em></p><h4 id="1-php一共分为五大运行模式：包括ducgi-、fast-cgi、cli、isapi、apache-模块的-DLLCGI"><a href="#1-php一共分为五大运行模式：包括ducgi-、fast-cgi、cli、isapi、apache-模块的-DLLCGI" class="headerlink" title="1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI"></a>1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI</h4><p>  关于PHP目前比较常见的五大运行模式：</p><p>1）CGI（通用网关接口/ Common Gateway Interface）<br>2）FastCGI（常驻型CGI / Long-Live CGI）<br>3）CLI（命令行运行 / Command Line Interface）<br>4）LoadModule（Apache独有）：<br>在Apache配置文件httpd.conf里，通常加的LoadModule php7_module “D:/…/php71/php7apache2_4.dll”起到的作用就是这个<br>5）ISAPI（Internet Server Application Program Interface）<br>IIS独有：<br>备注：在PHP5.3以后，PHP不再有ISAPI模式，安装后也不再有php5isapi.dll这个文件。要在IIS6上使用高版本PHP，必须安装FastCGI 扩展，然后使IIS6支持FastCGI。  </p><h3 id="2、php-cli-与php-fpm（fastcgi-process-manager）"><a href="#2、php-cli-与php-fpm（fastcgi-process-manager）" class="headerlink" title="2、php-cli 与php-fpm（fastcgi process manager）"></a>2、php-cli 与php-fpm（fastcgi process manager）</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190420173441325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbnFpYW45OTk=,size_16,color_FFFFFF,t_70" alt="[**CGI、FastCGI和PHP-FPM关系图解**](https://www.awaimai.com/371.html)"></p><p>cli 模式就是常见的命令使用的php命令，其实他也可以提供http请求服务，内置了http服务器<br>fpm 是一个多进程架构的FastCgi 服务，内置PHP解释器进程常驻后台，自带进程管理支持进程池配置和配置Nginx使用</p><p>cli 和fpm 是两个运行方式 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="cgi" scheme="https://smartxia.github.io/blog/tags/cgi/"/>
    
      <category term="fastcgi" scheme="https://smartxia.github.io/blog/tags/fastcgi/"/>
    
      <category term="cli" scheme="https://smartxia.github.io/blog/tags/cli/"/>
    
  </entry>
  
  <entry>
    <title>PHP-理解php的Generator,yield,Iterator接口</title>
    <link href="https://smartxia.github.io/blog/2020/08/28/PHP-%E7%90%86%E8%A7%A3php%E7%9A%84Generator,yield,Iterator%E6%8E%A5%E5%8F%A3/"/>
    <id>https://smartxia.github.io/blog/2020/08/28/PHP-%E7%90%86%E8%A7%A3php%E7%9A%84Generator,yield,Iterator%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-08-28T03:21:32.000Z</published>
    <updated>2020-08-28T03:26:17.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="Generator" scheme="https://smartxia.github.io/blog/tags/Generator/"/>
    
      <category term="yield" scheme="https://smartxia.github.io/blog/tags/yield/"/>
    
      <category term="Iterator - 等待更新" scheme="https://smartxia.github.io/blog/tags/Iterator-%E7%AD%89%E5%BE%85%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>其他-server酱打卡网易云</title>
    <link href="https://smartxia.github.io/blog/2020/08/26/%E5%85%B6%E4%BB%96-Server%E9%85%B1%E6%89%93%E5%8D%A1%E7%BD%91%E6%98%93%E4%BA%91%20%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://smartxia.github.io/blog/2020/08/26/%E5%85%B6%E4%BB%96-Server%E9%85%B1%E6%89%93%E5%8D%A1%E7%BD%91%E6%98%93%E4%BA%91%20%E5%B0%8F%E6%8A%80%E5%B7%A7/</id>
    <published>2020-08-26T01:57:49.000Z</published>
    <updated>2020-08-26T02:26:57.563Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="其他" scheme="https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="网易云 server酱 py 云函数  待更新" scheme="https://smartxia.github.io/blog/tags/%E7%BD%91%E6%98%93%E4%BA%91-server%E9%85%B1-py-%E4%BA%91%E5%87%BD%E6%95%B0-%E5%BE%85%E6%9B%B4%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Docker-info</title>
    <link href="https://smartxia.github.io/blog/2020/08/20/Docker-%E5%88%B6%E4%BD%9C-1/"/>
    <id>https://smartxia.github.io/blog/2020/08/20/Docker-%E5%88%B6%E4%BD%9C-1/</id>
    <published>2020-08-20T09:18:43.000Z</published>
    <updated>2020-08-20T09:48:17.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4 id="注册登录"><a href="#注册登录" class="headerlink" title="注册登录"></a>注册登录</h4><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h4 id="Docker快捷键"><a href="#Docker快捷键" class="headerlink" title="Docker快捷键"></a>Docker快捷键</h4><blockquote><p>常用： start restart stop  images ps-a</p></blockquote><h5 id="带有参数的使用"><a href="#带有参数的使用" class="headerlink" title="带有参数的使用"></a>带有参数的使用</h5><p>docker ps -a ：查看最近使用的容器id</p><p>docker rm 容器id:删除某个容器</p><p>docker images</p><p>docker rmi 镜像id:删除某个镜像</p><p>docker run :</p><p>docker run -d -p 9200:9200 -p 5601:5601 nshou/elasticsearch-kibana</p><blockquote><p>-d 后台运行，-p 内部端口/宿主机端口 容器id</p></blockquote><p>docker exec -it /bash :进入容器</p><p>docker login -u xx -p xxx：登录</p><h4 id="配置加速源"><a href="#配置加速源" class="headerlink" title="配置加速源"></a>配置加速源</h4><p>1.阿里云：百度如何通过阿里云加速docker拉取和推送速度</p><p>2.DaoCloud ：大公司，国内的。网站：<a href="https://www.daocloud.io/mirror">https://www.daocloud.io/mirror</a></p><blockquote><p>加速url</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux:curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><p>原理：编辑   /etc/docker/daemon.json  这个文件夹</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;f1361db2.m.daocloud.io&quot;,&quot;https:&#x2F;&#x2F;vbw6t0eb.mirror.aliyuncs.com&quot;]&#125;</span><br></pre></td></tr></table></figure><h4 id="查看当前docker配置文件"><a href="#查看当前docker配置文件" class="headerlink" title="查看当前docker配置文件"></a>查看当前docker配置文件</h4><p>docker info :可以查看是否配置成功加速 版本信息等各种信息</p><h4 id="打包镜像源和推送到docker-io"><a href="#打包镜像源和推送到docker-io" class="headerlink" title="打包镜像源和推送到docker.io"></a>打包镜像源和推送到docker.io</h4><p>1.docker pull xxx镜像:tag</p><p>2.docker images 查看镜像</p><p>3.docker run -d -p 8080:8081 xxx镜像:version</p><p>4.docker ps -a 查看是不是启动了，然后stop start restart 找找感觉</p><p>5.docker exec -it 镜像id bash :进入镜像进行修改：拉代码，查bug ,增加mysql实例等</p><p>6.docker commit -m “php71-daemon:xhprof-graphviz” -a “some” f69187b4375e “18260356308/php71-daemon:xhprof”</p><p>​    docker commit -m “提交log” -a “作者”  容器id “docker账户名/自定义镜像名：tag” 就会制作成一个新的image了</p><p>7.执行docker push xxx镜像的id：</p><blockquote><p>tips:</p><p>前提是得登录，还有  注意一个问题,给自己镜像命名的时候格式应该是: docker注册用户名/镜像名,比如我的docker用户名为 test123,那么我的镜像tag就为 test123/whalesay,不然是push不上去的</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="DOCKER" scheme="https://smartxia.github.io/blog/categories/DOCKER/"/>
    
    
      <category term="docekr images" scheme="https://smartxia.github.io/blog/tags/docekr-images/"/>
    
  </entry>
  
  <entry>
    <title>PHP-xhprof-性能优化</title>
    <link href="https://smartxia.github.io/blog/2020/08/20/PHP-xhprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://smartxia.github.io/blog/2020/08/20/PHP-xhprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2020-08-20T09:16:14.000Z</published>
    <updated>2020-08-26T02:14:26.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><hr><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><hr><h3 id="嵌入代码"><a href="#嵌入代码" class="headerlink" title="嵌入代码"></a>嵌入代码</h3><hr><h3 id="查看分析报告"><a href="#查看分析报告" class="headerlink" title="查看分析报告"></a>查看分析报告</h3><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><hr><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p>Function Name：方法名称。</p><p>Calls：方法被调用的次数。</p><p>Calls%：方法调用次数在同级方法总数调用次数中所占的百分比。</p><p>Incl.Wall Time(microsec)：方法执行花费的时间，包括子方法的执行时间。（单位：微秒）</p><p>IWall%：方法执行花费的时间百分比。</p><p>Excl. Wall Time(microsec)：方法本身执行花费的时间，不包括子方法的执行时间。（单位：微秒）</p><p>EWall%：方法本身执行花费的时间百分比。</p><p>Incl. CPU(microsecs)：方法执行花费的CPU时间，包括子方法的执行时间。（单位：微秒）</p><p>ICpu%：方法执行花费的CPU时间百分比。</p><p>Excl. CPU(microsec)：方法本身执行花费的CPU时间，不包括子方法的执行时间。（单位：微秒）</p><p>ECPU%：方法本身执行花费的CPU时间百分比。</p><p>Incl.MemUse(bytes)：方法执行占用的内存，包括子方法执行占用的内存。（单位：字节）</p><p>IMemUse%：方法执行占用的内存百分比。</p><p>Excl.MemUse(bytes)：方法本身执行占用的内存，不包括子方法执行占用的内存。（单位：字节）</p><p>EMemUse%：方法本身执行占用的内存百分比。</p><p>Incl.PeakMemUse(bytes)：Incl.MemUse峰值。（单位：字节）</p><p>IPeakMemUse%：Incl.MemUse峰值百分比。</p><p>Excl.PeakMemUse(bytes)：Excl.MemUse峰值。单位：（字节）</p><p>EPeakMemUse%：Excl.MemUse峰值百分比。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="xhprof docker push" scheme="https://smartxia.github.io/blog/tags/xhprof-docker-push/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2020/06/29/GOLANG-%E7%AC%94%E8%AE%B0-ArrayMapSlice/"/>
    <id>https://smartxia.github.io/blog/2020/06/29/GOLANG-%E7%AC%94%E8%AE%B0-ArrayMapSlice/</id>
    <published>2020-06-29T11:17:32.000Z</published>
    <updated>2020-08-21T02:00:25.193Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Array(数组)<br>内部机制<br>在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。</p><p>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p><p>总结<br>数组是 slice 和 map 的底层结构。<br>slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。<br>内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。<br>slice 有容量的约束，不过可以通过内建函数 append 来增加元素。<br>map 没有容量一说，所以也没有任何增长限制。<br>内建函数 len 可以用来获得 slice 和 map 的长度。<br>内建函数 cap 只能作用在 slice 上。<br>可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。<br>在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>PHP-SPL(数据结构)</title>
    <link href="https://smartxia.github.io/blog/2020/06/23/PHP-SPL(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/"/>
    <id>https://smartxia.github.io/blog/2020/06/23/PHP-SPL(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/</id>
    <published>2020-06-23T10:04:39.000Z</published>
    <updated>2020-08-28T03:29:29.980Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>php SPL四种常用的数据结构<br>1.栈【先进后出】</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$stack &#x3D; new SplStack();</span><br><span class="line">$stack-&gt;push(&#39;data1&#39;);</span><br><span class="line">$stack-&gt;push(&#39;data2&#39;);</span><br><span class="line">$stack-&gt;push(&#39;data3&#39;);</span><br><span class="line">echo $stack-&gt;pop();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data3&lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;font-size:24px;font-weight: bold;&quot;&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>2.队列【先进先出 后进后出】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$queue &#x3D; new SplQueue();</span><br><span class="line">$queue-&gt;enqueue(&quot;data1&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data2&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data3&quot;);</span><br><span class="line">echo $queue-&gt;dequeue();</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data1&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>3.堆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$heap &#x3D; new SplMinHeap();</span><br><span class="line">$heap-&gt;insert(&quot;data1&quot;);</span><br><span class="line">$heap-&gt;insert(&quot;data2&quot;);</span><br><span class="line">echo $heap-&gt;extract();</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data1&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>4.固定尺寸数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$array &#x3D; new SplFixedArray(5);</span><br><span class="line">$array[0]&#x3D;1;</span><br><span class="line">$array[3]&#x3D;3;</span><br><span class="line">$array[2]&#x3D;2;</span><br><span class="line">var_dump($array);</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F; object(SplFixedArray)[1]</span><br><span class="line">&#x2F;&#x2F; public 0 &#x3D;&gt; int 1</span><br><span class="line">&#x2F;&#x2F; public 1 &#x3D;&gt; null</span><br><span class="line">&#x2F;&#x2F; public 2 &#x3D;&gt; int 2</span><br><span class="line">&#x2F;&#x2F; public 3 &#x3D;&gt; int 3</span><br></pre></td></tr></table></figure><p>————————————————<br>推荐学习：<a href="http://www.imooc.com/video/4849">http://www.imooc.com/video/4849</a><br>原文链接：<a href="https://blog.csdn.net/zhengwish/article/details/51742264">https://blog.csdn.net/zhengwish/article/details/51742264</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/tags/PHP/"/>
    
      <category term="数据结构" scheme="https://smartxia.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PHP-SPL(数据结构)</title>
    <link href="https://smartxia.github.io/blog/2020/06/23/PHP-Use-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>https://smartxia.github.io/blog/2020/06/23/PHP-Use-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</id>
    <published>2020-06-23T10:04:39.000Z</published>
    <updated>2020-08-28T03:28:46.763Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>php SPL四种常用的数据结构<br>1.栈【先进后出】PHP-Use-使用场景</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$stack &#x3D; new SplStack();</span><br><span class="line">$stack-&gt;push(&#39;data1&#39;);</span><br><span class="line">$stack-&gt;push(&#39;data2&#39;);</span><br><span class="line">$stack-&gt;push(&#39;data3&#39;);</span><br><span class="line">echo $stack-&gt;pop();</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data3&lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;font-size:24px;font-weight: bold;&quot;&gt;</span><br><span class="line">&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>2.队列【先进先出 后进后出】</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$queue &#x3D; new SplQueue();</span><br><span class="line">$queue-&gt;enqueue(&quot;data1&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data2&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data3&quot;);</span><br><span class="line">echo $queue-&gt;dequeue();</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data1&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>3.堆</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$heap &#x3D; new SplMinHeap();</span><br><span class="line">$heap-&gt;insert(&quot;data1&quot;);</span><br><span class="line">$heap-&gt;insert(&quot;data2&quot;);</span><br><span class="line">echo $heap-&gt;extract();</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F;data1&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure><p>4.固定尺寸数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$array &#x3D; new SplFixedArray(5);</span><br><span class="line">$array[0]&#x3D;1;</span><br><span class="line">$array[3]&#x3D;3;</span><br><span class="line">$array[2]&#x3D;2;</span><br><span class="line">var_dump($array);</span><br><span class="line">&#x2F;&#x2F;输出结果为</span><br><span class="line">&#x2F;&#x2F; object(SplFixedArray)[1]</span><br><span class="line">&#x2F;&#x2F; public 0 &#x3D;&gt; int 1</span><br><span class="line">&#x2F;&#x2F; public 1 &#x3D;&gt; null</span><br><span class="line">&#x2F;&#x2F; public 2 &#x3D;&gt; int 2</span><br><span class="line">&#x2F;&#x2F; public 3 &#x3D;&gt; int 3</span><br></pre></td></tr></table></figure><p>————————————————<br>推荐学习：<a href="http://www.imooc.com/video/4849">http://www.imooc.com/video/4849</a><br>原文链接：<a href="https://blog.csdn.net/zhengwish/article/details/51742264">https://blog.csdn.net/zhengwish/article/details/51742264</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/tags/PHP/"/>
    
      <category term="数据结构" scheme="https://smartxia.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>PHP-use</title>
    <link href="https://smartxia.github.io/blog/2020/06/23/PHP-use/"/>
    <id>https://smartxia.github.io/blog/2020/06/23/PHP-use/</id>
    <published>2020-06-23T10:04:39.000Z</published>
    <updated>2020-08-28T03:24:41.919Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>php use用法</p><h4 id="1、user-namespace"><a href="#1、user-namespace" class="headerlink" title="1、user namespace"></a>1、user namespace</h4><h4 id="2、use-一个trait"><a href="#2、use-一个trait" class="headerlink" title="2、use 一个trait"></a>2、use 一个trait</h4><p>针对于trait的即多继承</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> A&#123; eat()&#125; <span class="keyword">trait</span> B&#123; drink()&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="keyword">use</span> <span class="title">A</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">B</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">Class</span> <span class="title">D</span></span>&#123;</span><br><span class="line">d=new Class C()</span><br><span class="line">d-&gt;eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 当不同的trait中，却有着同名的方法或属性，会产生冲突，可以使用insteadof或 as进行解决，insteadof 是进行替代，而as是给它取别名</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use trait1,trait2&#123;</span><br><span class="line">        trait1::eat insteadof trait2;</span><br><span class="line">        trait1::drive insteadof trait2;</span><br><span class="line">        trait2::eat as eaten;</span><br><span class="line">        trait2::drive as driven;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-闭包-gt-匿名函数"><a href="#3-闭包-gt-匿名函数" class="headerlink" title="3.闭包-&gt;匿名函数"></a>3.闭包-&gt;匿名函数</h4><p>好处：节省内存  适合做回调函数</p><p>匿名函数：定义时未定义函数的名称<br>闭包： 创建时封装周围状态的函数，及时周围的环境不存在了，闭包中的状态还会存在</p><p>使用法则：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/tags/PHP/"/>
    
      <category term="USE" scheme="https://smartxia.github.io/blog/tags/USE/"/>
    
  </entry>
  
  <entry>
    <title>PHP-strlen与mb_strlen</title>
    <link href="https://smartxia.github.io/blog/2020/06/22/PHP-strlen%E4%B8%8Emb-strlen/"/>
    <id>https://smartxia.github.io/blog/2020/06/22/PHP-strlen%E4%B8%8Emb-strlen/</id>
    <published>2020-06-22T11:11:39.000Z</published>
    <updated>2020-08-21T02:19:33.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>在PHP中，strlen与mb_strlen是求字符串长度的函数<br>PHP内置的字符串长度函数strlen无法正确处理中文字符串，它得到的只是字符串所占的字节数。对于GB2312的中文编码，strlen得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍（在 UTF-8编码下，一个汉字占3个字节）。</p><p>采用mb_strlen函数可以较好地解决这个问题。mb_strlen的用法和strlen类似，只不过它有第二个可选参数用于指定字符编码。例如得到UTF-8的字符串str长度，可以用mbstrlen(str长度，可以用mbstrlen(str,‘UTF-8’)。如果省略第二个参数，则会使用PHP的内部编码。内部编码可以通过 mb_internal_encoding()函数得到。</p><p>需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即确保“extension=php_mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。</p><hr><p>在strlen计算中，对待一个UTF8的中文字符，处理为3个字节长度，所以为3+1+2+1+9=16个</p><p>当mb_strlen的内码选择为UTF-8的时候，则会将中文字符当成一个字符,所以为3+1+2+1+3=10;</p><p>当mb_strlen的内码选择为gbk的时候，一个中文字符当成1.5个字符来处理来处理,最后就是:3+1+2+1+4.5=11.5</p><p>函数：mb_internal_encoding()会得到当前PHP使用的内部编码</p><p>strlen,得到的是字符串所占的字节数，所以在查看一个字符串的长度的时候，strlen并不能得到我们需要的真实值</p><p>mb_strlen 函数可以很好的处理这一点</p><p>注意：mb_strlen函数并不是php的核心函数，只是PHP的一个扩展函数，使用之前要判断是否加在的mbstring扩展模块，在Php.ini文件中可以查看相关配置</p><blockquote><p>strlen结果为什么是4<br>strlen在遇到第一个\0时结束，后面的字符无视。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/tags/PHP/"/>
    
      <category term="strlen" scheme="https://smartxia.github.io/blog/tags/strlen/"/>
    
  </entry>
  
  <entry>
    <title>其他-科学上网</title>
    <link href="https://smartxia.github.io/blog/2020/06/22/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://smartxia.github.io/blog/2020/06/22/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</id>
    <published>2020-06-22T07:57:49.000Z</published>
    <updated>2020-08-21T02:17:12.446Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1 id="解决System-Reflection-TargetInvocationException-调用的目标发生了异常。"><a href="#解决System-Reflection-TargetInvocationException-调用的目标发生了异常。" class="headerlink" title="解决System.Reflection.TargetInvocationException: 调用的目标发生了异常。"></a>解决System.Reflection.TargetInvocationException: 调用的目标发生了异常。</h1><blockquote><p>windows7系统运行没有问题，但是放到Windows10 上面就出现连接不上的问题，试了很多种方法还是这种解决了。</p></blockquote><p>问题：</p><p>System.Reflection.TargetInvocationException: 调用的目标发生了异常。</p><p>—&gt; System.Reflection.TargetInvocationException: 调用的目标发生了异常。</p><p>—&gt; System.InvalidOperationException: 此实现不是 Windows 平台 FIPS 验证的加密算法的一部分</p><p>解决办法：需要修改注册表,cmd命令，输入regedit打开注册表然后找到以下路径</p><p>KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy</p><p>修改此路径下的Enable值为1，然后重新打开shadowsocks，大功告成！记得重启ssr</p><p>（如果1不行那就切换成0）</p><p>————————————————<br>原文链接：<a href="https://blog.csdn.net/qq_27536941/article/details/103300646">https://blog.csdn.net/qq_27536941/article/details/103300646</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="其他" scheme="https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="ssr" scheme="https://smartxia.github.io/blog/tags/ssr/"/>
    
  </entry>
  
  <entry>
    <title>PHP-异常类</title>
    <link href="https://smartxia.github.io/blog/2020/06/22/PHP-%E5%BC%82%E5%B8%B8%E7%B1%BB/"/>
    <id>https://smartxia.github.io/blog/2020/06/22/PHP-%E5%BC%82%E5%B8%B8%E7%B1%BB/</id>
    <published>2020-06-22T03:27:10.000Z</published>
    <updated>2020-08-21T02:19:40.618Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>PHP 异常与错误 —— Throwable<br>Throwable</p><p>官方文档地址： <a href="http://php.net/manual/en/class.throwable.php">http://php.net/manual/en/class.throwable.php</a></p><p>PHP 支持版本： 7</p><blockquote><p>PHP7 异常与错误处理机制 Exception, Error, Throwable<br>Throwable 是 PHP 7 中可以用作任何对象抛出声明的基本接口，包括 Expection （异常）和 Error （错误）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Throwable &#123;</span><br><span class="line">    </span><br><span class="line">  &#x2F;* 抽象方法 *&#x2F;</span><br><span class="line">  abstract public string getMessage ( void ) &#x2F;&#x2F; 获取抛出的消息内容</span><br><span class="line"></span><br><span class="line">  abstract public int getCode ( void ) &#x2F;&#x2F; 获取抛出的错误代码</span><br><span class="line"></span><br><span class="line">  abstract public string getFile ( void ) &#x2F;&#x2F; 获取产生异常的文件名</span><br><span class="line"></span><br><span class="line">  abstract public int getLine ( void ) &#x2F;&#x2F; 获取相关行号</span><br><span class="line"></span><br><span class="line">  abstract public array getTrace ( void ) &#x2F;&#x2F; 获取追踪信息，返回数组形式</span><br><span class="line"></span><br><span class="line">  abstract public string getTraceAsString ( void ) &#x2F;&#x2F; 获取追踪信息，返回字符串形式</span><br><span class="line"></span><br><span class="line">  abstract public Throwable getPrevious ( void ) &#x2F;&#x2F; 返回上一个 Throwable</span><br><span class="line"></span><br><span class="line">  abstract public string __toString ( void ) &#x2F;&#x2F; 抛出的对象以字符串形式返回，可以用 echo 打印相应结果</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请一定要注意，没有特殊说明：本例 PHP Version &lt; 7<br>　　说起 PHP 异常处理，大家首先会想到 try-catch，那好，我们先看一段程序吧：有一个 test.php 文件，有一段简单的 PHP 程序，内容如下，然后命令行执行：php test.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 $num &#x3D; 0;</span><br><span class="line">3     try &#123;</span><br><span class="line">4         echo 1&#x2F;$num;</span><br><span class="line">5</span><br><span class="line">6 &#125; catch (Exception $e)&#123;</span><br><span class="line">7         echo $e-&gt;getMessage();</span><br><span class="line">8 &#125;</span><br><span class="line">9 ?&gt;</span><br></pre></td></tr></table></figure><p>　　我的问题是：这段程序能正确的捕捉到除 0 的错误信息吗？<br>　　如果你回答能，那你就把这篇文章看完吧！应该能学点东西。</p><p>本文章分 5 个部分介绍我的异常处理的理解：</p><p>一、异常与错误的概述</p><p>二、ERROR 的级别</p><p>三、PHP 异常处理中的黑科技</p><p>四、巧妙的捕获错误和异常</p><p>五、自定义异常处理和异常嵌套</p><p>六、PHP7 中的异常处理</p><p>一、异常与错误的概述<br>　　 PHP 中什么是异常：<br>　　程序在运行中出现不符合预期的情况，允许发生（你也不想让他出现不正常的情况）但他是一种不正常的情况，按照我们的正常逻辑本不该出的错误，但仍然会出现的错误，属于逻辑和业务流程的错误，而不是编译或者语法上的错误。</p><p>PHP 中什么是错误：<br>　　属于 php 脚本自身的问题，大部分情况是由错误的语法，服务器环境导致，使得编译器无法通过检查，甚至无法运行的情况。warning、notice 都是错误，只是他们的级别不同而已，并且错误是不能被 try-catch 捕获的。</p><p>上面的说法是有前提条件的：<br>　　在 PHP 中，因为在其他语言中就不能这样下结论了，也就是说异常和错误的说法在不同的语言有不同的说法。在 PHP 中任何自身的错误或者是非正常的代码都会当做错误对待，并不会以异常的形式抛出，但是也有一些情况会当做异常和错误同时抛出(据说是，我没有找到合适的例子)。也就是说，你想在数据库连接失败的时候自动捕获异常是行不通的，因为这就不是异常，是错误。但是在 java 中就不一样了，他会把很多和预期不一致的行为当做异常来进行捕获。</p><p>PHP 异常处理很鸡肋？<br>　　在上面的分析中我们可以看出，PHP 并不能主动的抛出异常，但是你可以手动抛出异常，这就很无语了，如果你知道哪里会出问题，你添加 if else 解决不就行了吗，为啥还要手动抛出异常，既然能手动抛出就证明这个不是异常，而是意料之中。以我的理解，这就是 PHP 异常处理鸡肋的地方（不一定对啊）。所以 PHP 的异常机制不是那么的完美，但是使用过框架的同学都知道有这个情况：你在框架中直接写开头那段 php“自动”捕获异常的代码是可以的，这是为什么？看过源码的同学都知道框架中都会涉及三个函数：register_shutdown_function，set_error_handler，set_exception_handler 后面我会重点讲解着三个黑科技，通过这几个函数我们可以实现 PHP 假自动捕获异常和错误。</p><p>二、ERROR 的级别<br>　　只有熟悉错误级别才能对错误捕捉有更好的认识。 ERROR 有不同的错误级别，我之前的一篇文章中有写到：<a href="http://www.cnblogs.com/zyf-zhaoyafei/p/3649434.html">http://www.cnblogs.com/zyf-zhaoyafei/p/3649434.html</a><br>　　下面我再总结性的给出这几类错误级别：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 Fatal Error:致命错误（脚本终止运行）</span><br><span class="line">2 E_ERROR &#x2F;&#x2F; 致命的运行错误，错误无法恢复，暂停执行脚本</span><br><span class="line">3 E_CORE_ERROR &#x2F;&#x2F; PHP 启动时初始化过程中的致命错误</span><br><span class="line">4 E_COMPILE_ERROR &#x2F;&#x2F; 编译时致命性错，就像由 Zend 脚本引擎生成了一个 E_ERROR</span><br><span class="line">5 E_USER_ERROR &#x2F;&#x2F; 自定义错误消息。像用 PHP 函数 trigger_error（错误类型设置为：E_USER_ERROR）</span><br><span class="line">6</span><br><span class="line">7 Parse Error：编译时解析错误，语法错误（脚本终止运行）</span><br><span class="line">8 E_PARSE &#x2F;&#x2F;编译时的语法解析错误</span><br><span class="line">9</span><br><span class="line">10 Warning Error：警告错误（仅给出提示信息，脚本不终止运行）</span><br><span class="line">11 E_WARNING &#x2F;&#x2F; 运行时警告 (非致命错误)。</span><br><span class="line">12 E_CORE_WARNING &#x2F;&#x2F; PHP 初始化启动过程中发生的警告 (非致命错误) 。</span><br><span class="line">13 E_COMPILE_WARNING &#x2F;&#x2F; 编译警告</span><br><span class="line">14 E_USER_WARNING &#x2F;&#x2F; 用户产生的警告信息</span><br><span class="line">15</span><br><span class="line">16 Notice Error：通知错误（仅给出通知信息，脚本不终止运行）</span><br><span class="line">17 E_NOTICE &#x2F;&#x2F; 运行时通知。表示脚本遇到可能会表现为错误的情况.</span><br><span class="line">18 E_USER_NOTICE &#x2F;&#x2F; 用户产生的通知信息。</span><br></pre></td></tr></table></figure><p>　　由此可知有 5 类是产生 ERROR 级别的错误，这种错误直接导致 PHP 程序退出。<br>　　可以定义成：</p><p>1 ERROR = E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_PARSE<br>三、PHP 异常处理中的黑科技<br>　　前面提到框架中是可以捕获所有的错误和异常的，之所以能实现应该是使用了黑科技，哈哈！其实也不是什么黑科技，主要是三个重要的函数：</p><p>1：set_error_handler()<br>　　看到这个名字估计就知道什么意思了，这个函数用于捕获错误，设置一个用户自定义的错误处理函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 set_error_handler(&#39;zyferror&#39;);</span><br><span class="line">3 function zyferror($type, $message, $file, $line)</span><br><span class="line">4 &#123;</span><br><span class="line">5 　　 var_dump(&#39;&lt;b&gt;set_error_handler: &#39; . $type . &#39;:&#39; . $message . &#39; in &#39; . $file . &#39; on &#39; . $line . &#39; line .&lt;&#x2F;b&gt;&lt;br &#x2F;&gt;&#39;);</span><br><span class="line">6 &#125;</span><br><span class="line">7 ?&gt;</span><br></pre></td></tr></table></figure><p>　　当程序出现错误的时候自动调用此方法，不过需要注意一下两点：第一，如果存在该方法，相应的 error_reporting()就不能在使用了。所有的错误都会交给自定义的函数处理。第二，此方法不能处理以下级别的错误：E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，set_error_handler() 函数所在文件中产生的 E_STRICT，该函数只能捕获系统产生的一些 Warning、Notice 级别的错误。<br>　　并且他有多种调用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 &#x2F;&#x2F; 直接传函数名 NonClassFunction</span><br><span class="line">3 set_error_handler(&#39;function_name&#39;);</span><br><span class="line">4</span><br><span class="line">5 &#x2F;&#x2F; 传 class_name &amp;&amp; function_name</span><br><span class="line">6 set_error_handler(array(&#39;class_name&#39;, &#39;function_name&#39;));</span><br><span class="line">7 ?&gt;</span><br></pre></td></tr></table></figure><p>　　 2：register_shutdown_function()<br>　　捕获 PHP 的错误：Fatal Error、Parse Error 等，这个方法是 PHP 脚本执行结束前最后一个调用的函数，比如脚本错误、die()、exit、异常、正常结束都会调用，多么牛逼的一个函数啊！通过这个函数就可以在脚本结束前判断这次执行是否有错误产生，这时就要借助于一个函数：error_get_last()；这个函数可以拿到本次执行产生的所有错误。error_get_last();返回的信息：<br>　　[type] - 错误类型<br>　　[message] - 错误消息<br>　　[file] - 发生错误所在的文件<br>　　[line] - 发生错误所在的行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 register_shutdown_function(&#39;zyfshutdownfunc&#39;);</span><br><span class="line">3 function zyfshutdownfunc()</span><br><span class="line">4 &#123;</span><br><span class="line">5 if ($error &#x3D; error_get_last()) &#123;</span><br><span class="line">6             var_dump(&#39;&lt;b&gt;register_shutdown_function: Type:&#39; . $error[&#39;type&#39;] . &#39; Msg: &#39; . $error[&#39;message&#39;] . &#39; in &#39; . $error[&#39;file&#39;] . &#39; on line &#39; . \$error[&#39;line&#39;] . &#39;&lt;&#x2F;b&gt;&#39;);</span><br><span class="line">7 &#125;</span><br><span class="line">8 &#125;</span><br><span class="line">9 ?&gt;</span><br></pre></td></tr></table></figure><p>　　通过这种方法就可以巧妙的打印出程序结束前所有的错误信息。但是我在测试的时候我发现并不是所有的错误终止后都会调用这个函数，可以看下面的一个测试文件，内容是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 register_shutdown_function(&#39;zyfshutdownfunc&#39;);</span><br><span class="line">3 function zyfshutdownfunc()</span><br><span class="line">4 &#123;</span><br><span class="line">5 if ($error &#x3D; error_get_last()) &#123;</span><br><span class="line"> 6             var_dump(&#39;&lt;b&gt;register_shutdown_function: Type:&#39; . $error[&#39;type&#39;] . &#39; Msg: &#39; . $error[&#39;message&#39;] . &#39; in &#39; . $error[&#39;file&#39;] . &#39; on line &#39; . \$error[&#39;line&#39;] . &#39;&lt;&#x2F;b&gt;&#39;);</span><br><span class="line">7 &#125;</span><br><span class="line">8 &#125;</span><br><span class="line">9 var_dump(23+-+); &#x2F;&#x2F;此处语法错误</span><br><span class="line">10 ?&gt;</span><br><span class="line"></span><br><span class="line">　　自己可以试一下，你可以看到根本就不会触发 zyfshutdownfunc()函数，其实这是一个语法错误，直接报了一个：</span><br><span class="line"></span><br><span class="line">1 &lt;?php</span><br><span class="line">2 Parse error: syntax error, unexpected &#39;)&#39; in &#x2F;www&#x2F;mytest&#x2F;exception&#x2F;try-catch.php on line 71</span><br><span class="line">3 ?&gt;</span><br><span class="line">　　由此引出一个奇葩的问题：问什么不能触发，为什么框架中是可以的？其实原因很简单，只在 parse-time 出错时是不会调用本函数的。只有在 run-time 出错的时候，才会调用本函数，我的理解是语法检查器前没有执行 register_shutdown_function()去把需要注册的函数放到调用的堆栈中，所以就根本不会运行。那框架中为什么任何错误都能进入到 register_shutdown_function()中呢，其实在框架中一般会有统一的入口 index.php，然后每个类库文件都会通过 include \*\* 的方式加载到 index.php 中，相当与所有的程序都会在 index.php 中聚集，同样，你写的具有语法错误的文件也会被引入到入口文件中，这样的话，调用框架，执行 index.php，index.php 本身并没有语法错误，也就不会产生 parse-time 错误，而是 include 文件出错了，是 run-time 的时候出错了，所以框架执行完之后就会触发 register_shutdown_function();</span><br><span class="line">　　所以现在可是试一下这个写法，这样就会触发 zyfshutdownfunc()回调了：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 a.php 文件<br>2 <?php3 　　// 模拟语法错误4 　　 var_dump(23+-+);5 ?><br>6<br>7 b.php 文件<br>8 <?php9 register_shutdown_function('zyfshutdownfunc');10 function zyfshutdownfunc()11 {12 if ($error = error_get_last()) {13             var_dump('<b>register_shutdown_function: Type:' . $error['type'] . ' Msg: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . \$error['line'] . '</b>');14 }15 }16 require 'a.php';17 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　 3：set_exception_handler()</span><br><span class="line">　　设置默认的异常处理程序，用在没有用 try&#x2F;catch 块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。看一下用法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 set_exception_handler('zyfexception');3 function zyfexception($exception)4     {5         var_dump("<b>set_exception_handler: Exception: " . $exception->getMessage() . '</b>');6 }7 throw new Exception("zyf exception");8 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">四、巧妙的捕获错误和异常</span><br><span class="line">　　 1：把错误以异常的形式抛出(不能完全抛出)</span><br><span class="line">　　　　由上面的讲解我们知道，php 中的错误是不能以异常的像是捕获的，但是我们需要让他们抛出，已达到扩展 try-catch 的影响范围，我们前面讲到过 set_error_handler() 方法，他是干嘛用的，他是捕获错误的，所以我们就可以借助他来吧错误捕获，然后再以异常的形式抛出，ok，试试下面的写法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 set_error_handler('zyferror');3 function zyferror($type, $message, $file, $line)4 {5 throw new \Exception($message . 'zyf错误当做异常'); 6     } 7  8     $num = 0;9 try {10 echo 1/$num;11 12     } catch (Exception $e){13 echo \$e->getMessage();14 }15 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　好了，试一下，会打印出：</span><br><span class="line"></span><br><span class="line">1 Division by zero zyf123</span><br><span class="line">　　流程：本来是除 0 错误，然后触发 set_error_handler()，在 set_error_handler()中相当与杀了个回马枪，再把错误信息以异常的形式抛出来，这样就可以实现错误以异常的形式抛出。大家要注意：这样做是有缺点的，会受到 set_error_handler()函数捕获级别的限制。</span><br><span class="line"></span><br><span class="line">     2：捕获所有的错误</span><br><span class="line">        由set_error_handler()可知，他能够捕获一部分错误，不能捕获系统级E_ERROR、E_PARSE等错误，但是这部分可以由register_shutdown_function()捕获。所以两者结合能出现很好的功能。</span><br><span class="line">        看下面的程序：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 a.php 内容：<br>2 <?3 // 模拟 Fatal error 错误4 //test();56 // 模拟用户产生 ERROR 错误7 //trigger_error('zyf-error', E_USER_ERROR);89 // 模拟语法错误10 var_dump(23+-+);1112 // 模拟 Notice 错误13 //echo \$f;1415 // 模拟 Warning 错误16 //echo '123';17 //ob_flush();18 //flush();19 //header("Content-type:text/html;charset=gb2312");20 ?></p><p>21 b.php 内容：<br>22 <?23 error_reporting(0);24 register_shutdown_function('zyfshutdownfunc');25 function zyfshutdownfunc()26 {27 if ($error = error_get_last()) {28             var_dump('<b>register_shutdown_function: Type:' . $error['type'] . ' Msg: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line'] . '</b>');29         }30     }31 32     set_error_handler('zyferror');33     function zyferror($type, $message, $file, $line)34     {35         var_dump('<b>set_error_handler: ' . $type . ':' . $message . ' in ' . $file . ' on ' . \$line . ' line .</b><br />');36 }3738 require 'a.php';39 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　到此就可以解释开头的那个程序了吧，test.php 如果是单文件执行是不能捕获到错误的，如果你在框架中执行就是可以的，当然你按照我上面介绍的来扩展也是可以的。</span><br><span class="line"></span><br><span class="line">五、自定义异常处理和异常嵌套</span><br><span class="line"></span><br><span class="line">1：自定义异常处理</span><br><span class="line"></span><br><span class="line">在复杂的系统中，我们往往需要自己捕获我们需要特殊处理的异常，这些异常可能是特殊情况下抛出的。所以我们就自己定义一个异常捕获类，该类必须是 exception 类的一个扩展，该类继承了 PHP 的 exception 类的所有属性，并且我们可以添加自定义的函数，使用的时候其实和之前的一样，大致写法如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 class zyfException extends Exception3 {4 public function errorzyfMessage()5 {6 return 'Error line ' . $this->getLine().' in ' . $this->getFile()7 .': <b>' . $this->getMessage() . '</b> Must in (0 - 60)'; 8         } 9     }10 11     $age = 10;12 try {13 $age = intval($age);14 if($age > 60) {15             throw new zyfException($age);16 }1718 } catch (zyfException $e) {19         echo $e->errorzyfMessage();2021 }22 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　 2：异常嵌套</span><br><span class="line"></span><br><span class="line">异常嵌套是比较常见的写法，在自定义的异常处理中，try 块中可以定义多个异常捕获，然后分层传递异常，理解和冒泡差不多，看下面的实现：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 $age = 10; 3     try { 4         $age = intval($age); 5         if($age > 60) {6 throw new zyfException($age); 7         } 8  9         if ($age <= 0) {10 throw new Exception($age . ' must > 0');11         }12 13     } catch (zyfException $e) {14 echo $e->errorzyfMessage();15 16     } catch(Exception $e) {17 echo \$e->getMessage();18 }19 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　当然也可以在 catch 中再抛出异常给上层：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 $age = 100; 3     try { 4         try { 5             $age = intval($age); 6             if($age > 60) {7 throw new Exception($age); 8             } 9 10         } catch (Exception $e) {11 throw new zyfException($age);12 13         }14 15     } catch (zyfException $e) {16 echo \$e->errorzyfMessage();17 }18 ?></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">六、PHP7 中的异常处理</span><br><span class="line">　　现在写 PHP 必须考虑版本情况，上面的写法在 PHP7 中大部分都能实现，但是也会有不同点，在 PHP7 更新中有一条：更多的 Error 变为可捕获的 Exception，现在的 PHP7 实现了一个全局的 throwable 接口，原来老的 Exception 和其中一部分 Error 实现了这个接口(interface)，PHP7 中更多的 Error 变为可捕获的 Exception 返回给捕捉器，这样其实和前面提到的扩展 try-catch 影响范围一样，但是如果不捕获则还是按照 Error 对待，看下面两个：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 try {3 test();45 } catch(Throwable $e) { 6         echo $e->getMessage() . ' zyf';7 }89 try {10 test();1112 } catch(Error $e) {13         echo $e->getMessage() . ' zyf';14 }15 ?></p><p>```<br>因为 PHP7 实现了 throwable 接口，那么就可以使用第一个这种方式来捕获异常。又因为部分 Error 实现了接口，并且更多的 Error 变为可捕获的 Exception，那么就可以使用第二种方式来捕获异常。下面是在网上找的 PHP7 的异常层次树：<br>Throwable<br>　　 Exception 异常<br>　　　　…<br>　　 Error 错误<br>　　　　 ArithmeticError 算数错误<br>　　　　　　 DivisionByZeroError 除数为 0 的错误<br>　　　　 AssertionError 声明错误<br>　　　　 ParseError 解析错误<br>　　　　 TypeError 类型错误<br>转载：<br><a href="http://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html">http://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/tags/PHP/"/>
    
      <category term="异常" scheme="https://smartxia.github.io/blog/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
</feed>
