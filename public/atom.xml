<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Some</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>https://smartxia.github.io/blog</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2021-11-18T06:09:17.557Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GOLANG-GPM的深入理解</title>
    <link href="https://smartxia.github.io/blog/2021/11/18/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>https://smartxia.github.io/blog/2021/11/18/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-11-18T02:08:03.000Z</published>
    <updated>2021-11-18T06:09:17.557Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>深入golang runtime的调度</p><h3><span id="理解调度器的启动">理解调度器的启动</span></h3><p>runtime：</p><p>scheduler:</p><p>TLS:</p><p>spinning:</p><p>systemstack,mcall,asmcgocall</p><p>主要源码文件:</p><p>调度基本组件：</p><p><strong>G(goroutine)</strong>：调度器的基本单位，存储的goroutine的执行stack信息，状态以及任务函数</p><p>在g的眼中只有p,p就是运行的G的“CPU”</p><p>相当于两级线程</p><blockquote><p>g的任务函数</p></blockquote><p>每个g的实例都有任务函数，如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userFun:&#x3D;func()&#123;fmt.Println(&quot;111&quot;)&#125;</span><br><span class="line">go userFunc();</span><br></pre></td></tr></table></figure><p>go的关键词创建了一个goroutine,此时gouroutine的任务函数userFun</p><p><strong>P（processor）</strong></p><p>p表示逻辑processor，代表M执行的上下文</p><p>p的最大作用是拥有各种G的对象队列，链表，cache,和状态</p><p>p的数量也代表go的执行并发度，即多少个goroutine可以同时执行</p><p>这里的p虽然表示逻辑处理器，但是p并不代表任何执行代码，对于g来说，p相当于cpu的核，g只有绑定p才能调度。对于M来说，p提供了执行环境（Context），如分配内存状态（mcache）,任务队列G等</p><p><strong>M(machine)</strong></p><p>M代表真正的执行计算资源，可以任务他就是os thread(系统线程)</p><p>M是真正的执行者，每个M就像一个勤劳的工作者，总是从各种队列找到可运行的G,而且这样的M的可以同时存在多个</p><p>M在绑定有效P，可以进行调度循环，而且M并不保留G状态，这个是g可以跨M调度的基础</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-纯纯的语法仔的没落</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/</id>
    <published>2021-11-17T03:57:39.000Z</published>
    <updated>2021-11-18T05:39:16.298Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="基础">基础</span></h2><h3><span id="1-对于已经关闭的channel的处理">1. 对于已经关闭的channel的处理</span></h3><p>读已经关闭的channel，一直能读到东西，但是读到的东西根据通道内关闭前是否有元素而不同，</p><ul><li>关闭前，buffer有还未读取的，会读取到chan内的值，且返回是否读取成功的bool值为true</li><li>关闭前，buffer的值读完，channel元素值为0，bool值为false</li></ul><p>写入：直接panic</p><h3><span id="2-make和new区别">2. Make和new区别</span></h3><p>make：返回特定类型channel，slice,map</p><p>new: 开辟新内存和指针</p><h3><span id="3-nil-切片和空切片一不一样">3. nil 切片和空切片一不一样</span></h3><p>指向的地址不一样。nill引用指针地址为0，空切片执行数组指针地址，且为一个固定值</p><p>数据结构：data,len,cap</p><h3><span id="4-字符串转byte数组会发生内存拷贝吗">4. 字符串转byte数组，会发生内存拷贝吗</span></h3><p>严格来说，只要发生类型强转，都会发生内存拷贝。</p><p>那么go有个很强的包叫 <code>unsafe</code> 。先获取变量地址，字符串转成底层结构，通过unsafe包，转为切片数组,再通过指针指向实际内容</p><p>string 数据结构 {data,len} </p><h3><span id="5-json包变量不加tag会怎么样">5. json包变量不加tag会怎么样</span></h3><p>和key的大小写有关</p><h3><span id="6-gpm">6. GPM</span></h3><p>指向另一篇详细（）</p><h3><span id="7docker-的网络通信模式">7.Docker 的网络通信模式。</span></h3><p>四种：</p><p>1.host模式：和宿主机公用一个network NameSpace 。容器不会配置任何自己网卡，而是使用自己宿主机的IP和端口</p><p>2.container模式：指定和其他容器共享network nameSpace,而不是和宿主机共享</p><p>3.none模式：告诉容器放到自己网站堆里，但是不要配置他的网络</p><p>4.brideg模式：docker默认的网络模式，此模式会将主机docker链接到虚拟网桥上</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-grpc/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-grpc/</id>
    <published>2021-11-17T02:28:40.000Z</published>
    <updated>2021-11-17T03:57:26.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>grpc 官网：<a href="https://grpc.io/docs/languages/go/basics/">https://grpc.io/docs/languages/go/basics/</a> 中文翻译版本：<a href="http://doc.oschina.net/grpc?t=56831">http://doc.oschina.net/grpc?t=56831</a></p></blockquote><p>1、下载protobuf的编译器protoc</p><p>地址：</p><p>1、<code>https://github.com/google/protobuf/releases</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window：</span><br><span class="line">  下载: protoc-3.3.0-win32.zip</span><br><span class="line">  解压，把bin目录下的protoc.exe复制到GOPATH&#x2F;bin下，GOPATH&#x2F;bin加入环境变量。</span><br><span class="line">当然也可放在其他目录，需加入环境变量，能让系统找到protoc.exe</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">    下载：protoc-3.3.0-linux-x86_64.zip 或 protoc-3.3.0-linux-x86_32.zip</span><br><span class="line">解压，把bin目录下的protoc复制到GOPATH&#x2F;bin下，GOPATH&#x2F;bin加入环境变量。</span><br><span class="line">如果喜欢编译安装的，也可下载源码自行安装，最后将可执行文件加入环境变量。</span><br></pre></td></tr></table></figure><p>2、获取protobuf的编译器插件<code>protoc-gen-go</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  进入GOPATH目录</span><br><span class="line">  运行</span><br><span class="line">&gt; go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br><span class="line">  如果成功，会在GOPATH&#x2F;bin下生成protoc-gen-go.exe文件</span><br></pre></td></tr></table></figure><p>3、创建一个<code>test.proto</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指定版本</span><br><span class="line">&#x2F;&#x2F;注意proto3与proto2的写法有些不同</span><br><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;包名，通过protoc生成时go文件时</span><br><span class="line">package test;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;手机类型</span><br><span class="line">&#x2F;&#x2F;枚举类型第一个字段必须为0</span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    HOME &#x3D; 0;</span><br><span class="line">    WORK &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;手机</span><br><span class="line">message Phone &#123;</span><br><span class="line">    PhoneType type &#x3D; 1;</span><br><span class="line">    string number &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;人</span><br><span class="line">message Person &#123;</span><br><span class="line">    &#x2F;&#x2F;后面的数字表示标识号</span><br><span class="line">    int32 id &#x3D; 1;</span><br><span class="line">    string name &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F;repeated表示可重复</span><br><span class="line">    &#x2F;&#x2F;可以有多个手机</span><br><span class="line">    repeated Phone phones &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;联系簿</span><br><span class="line">message ContactBook &#123;</span><br><span class="line">    repeated Person persons &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; protoc --go_out&#x3D;. *.proto</span><br><span class="line">会生成一个test.pb.go的文件，具体的文件内容我就不截图了。</span><br></pre></td></tr></table></figure><p>5、在go语言中使用protobuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;github.com&#x2F;golang&#x2F;protobuf&#x2F;proto&quot;</span><br><span class="line">    &quot;protobuf&#x2F;test&quot;</span><br><span class="line">    &quot;io&#x2F;ioutil&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func write() &#123;</span><br><span class="line">    p1 :&#x3D; &amp;test.Person&#123;</span><br><span class="line">        Id:   1,</span><br><span class="line">        Name: &quot;小张&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;111111111&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;222222222&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    p2 :&#x3D; &amp;test.Person&#123;</span><br><span class="line">        Id:   2,</span><br><span class="line">        Name: &quot;小王&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;333333333&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;444444444&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;创建地址簿</span><br><span class="line">    book :&#x3D; &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    book.Persons &#x3D; append(book.Persons, p1);</span><br><span class="line">    book.Persons &#x3D; append(book.Persons, p2);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;编码数据</span><br><span class="line">    data, _ :&#x3D; proto.Marshal(book);</span><br><span class="line">    &#x2F;&#x2F;把数据写入文件</span><br><span class="line">    ioutil.WriteFile(&quot;.&#x2F;test.txt&quot;, data, os.ModePerm);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func read() &#123;</span><br><span class="line">    &#x2F;&#x2F;读取文件数据</span><br><span class="line">    data, _ :&#x3D; ioutil.ReadFile(&quot;.&#x2F;test.txt&quot;);</span><br><span class="line">    book :&#x3D; &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F;解码数据</span><br><span class="line">    proto.Unmarshal(data, book);</span><br><span class="line">    for _, v :&#x3D; range book.Persons &#123;</span><br><span class="line">        fmt.Println(v.Id, v.Name);</span><br><span class="line">        for _, vv :&#x3D; range v.Phones &#123;</span><br><span class="line">            fmt.Println(vv.Type, vv.Number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    write();</span><br><span class="line">    read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5367714-2eb580ad8e2e7a93.png" alt="img"></p><p>image.png</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;go:generate protoc -I ..&#x2F;routeguide --go_out&#x3D;plugins&#x3D;grpc:..&#x2F;routeguide ..&#x2F;routeguide&#x2F;route_guide.proto protoc</span><br></pre></td></tr></table></figure><p><code>-I</code> 参数：指定import路径，可以指定多个-I参数，编译时按顺序查找，不指定时默认查找当前目录</p><p><code>--go_out</code> ：golang编译支持，支持以下参数<br>plugins=plugin1+plugin2 - 指定插件，目前只支持grpc，即：plugins=grpc</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>PHP-析构函数-destruct</title>
    <link href="https://smartxia.github.io/blog/2021/11/16/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
    <id>https://smartxia.github.io/blog/2021/11/16/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</id>
    <published>2021-11-16T03:33:44.698Z</published>
    <updated>2021-11-16T03:33:44.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3><span id="析构函数destruct">析构函数destruct</span></h3><p><img src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：<strong>construct()在初始化对象的时候默认执行的<br>析构函数：</strong>destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data &#x3D; [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#39;appkey&#39;] &#x3D; getAppkey();</span><br><span class="line">        $data[&#39;channel&#39;] &#x3D; getChannel();</span><br><span class="line">        $this-&gt;data[] &#x3D; $data;</span><br><span class="line">        &#x2F;&#x2F;这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id &#x3D; $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#39;id &lt;&#39; &#x3D;&gt; $id - 50000</span><br><span class="line">            ], &#39;&#39;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend&#x3D;new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="php" scheme="https://smartxia.github.io/blog/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2021/11/16/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
    <id>https://smartxia.github.io/blog/2021/11/16/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</id>
    <published>2021-11-16T03:33:44.686Z</published>
    <updated>2021-11-16T10:01:25.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. :&#x3D; &#x3D; &#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">:&#x3D; 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">&#x3D; 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 :&#x3D; make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val :&#x3D; make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">ch :&#x3D; make(chan int, 100) &#x2F;&#x2F; make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据</span><br><span class="line">&#x2F;&#x2F; 并把值赋给 v</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>golang Context上下文</title>
    <link href="https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2021-11-15T10:56:27.000Z</published>
    <updated>2021-11-16T10:01:25.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>数据四层七层</title>
    <link href="https://smartxia.github.io/blog/2021/11/10/REDIS/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/"/>
    <id>https://smartxia.github.io/blog/2021/11/10/REDIS/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/</id>
    <published>2021-11-10T07:08:25.000Z</published>
    <updated>2021-11-16T03:33:44.703Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="reids" scheme="https://smartxia.github.io/blog/categories/reids/"/>
    
    
  </entry>
  
  <entry>
    <title>golang里的进程线程携程的调度方式</title>
    <link href="https://smartxia.github.io/blog/2021/10/10/GOLANG/golang%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/"/>
    <id>https://smartxia.github.io/blog/2021/10/10/GOLANG/golang%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-10T10:56:27.000Z</published>
    <updated>2021-11-17T04:00:59.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>找工作本来想靠实力和经验，奈何仍需背面试题，刷算法，可以说是可恶了<br>作者：腾讯技术工程<br>链接：<a href="https://www.zhihu.com/question/20862617/answer/921061289">https://www.zhihu.com/question/20862617/answer/921061289</a><br>来源：知乎</p><h2><span id="goroutine-实现">goroutine 实现:</span></h2><p><img src="https://pic1.zhimg.com/50/v2-5f7f337c089077babfbe296e8a82c88a_720w.jpg?source=1940ef5c" alt="img"></p><p>我们去看调度的一个进化, 从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程. go 实现的协程为有栈协程, go 协程的用法和线程的用法基本类似. 很多人会疑问, 协程到底是个什么东西? 用户态的调度感觉很陌生, 很抽象, 到底是个什么东西?</p><p>我觉得要理解调度, 要理解两个概念: 运行和阻塞. 特别是在协程中, 这两个概念不容易被正确理解. 我们理解概念时往往会代入自身感受, 觉得线程或协程运行就是像我们吭哧吭哧的处理事情, 线程或协程阻塞就是做事情时我们需要等待其他人. 然后就在这等着了. 要是其他人搞好了, 那我们就继续做当前的事.</p><p>其实主体对象搞错了.正确的理解应该是我们处理事情时就像 CPU, 而不是像线程或者协程. 假如我当前在写某个服务, 发现依赖别人的函数还没有 ready, 那就把写服务这件事放一边. 点开企业微信, 我去和产品沟通一些问题了. 我和产品沟通了一会后, 检查一下, 发现别人已经把依赖的函数提交了, 然后我就最小化企业微信, 切到 IDE, 继续写服务 A 了.</p><p>对操作系统有过一些了解, 知道 linux 下的线程其实是 task_struct 结构, 线程其实并不是真正运行的实体, 线程只是代表一个执行流和其状态.真正运行驱动流程往前的其实是 CPU. CPU 在时钟的驱动下, 根据 PC 寄存器从程序中取指令和操作数, 从 RAM 中取数据, 进行计算, 处理, 跳转, 驱动执行流往前. CPU 并不关注处理的是线程还是协程, 只需要设置 PC 寄存器, 设置栈指针等(这些称为上下文), 那么 CPU 就可以欢快的运行这个线程或者这个协程了.</p><p>线程的运行, 其实是被运行.其阻塞, 其实是切换出调度队列, 不再去调度执行这个执行流. 其他执行流满足其条件, 便会把被移出调度队列的执行流重新放回调度队列.协程同理, 协程其实也是一个数据结构, 记录了要运行什么函数, 运行到哪里了.<br>go 在用户态实现调度, 所以 go 要有代表协程这种执行流的结构体, 也要有保存和恢复上下文的函数, 运行队列. 理解了阻塞的真正含义, 也就知道能够比较容易理解, 为什么 go 的锁, channel 这些不阻塞线程.</p><p>对于实现的同步执行流效果, 又不阻塞线程的网络, 接下来也会介绍.</p><h3><span id="协程结构体和切换函数"><strong>协程结构体和切换函数</strong></span></h3><p><img src="https://pic1.zhimg.com/50/v2-85a56b6e215d2b427ac4f5252ce3c619_720w.jpg?source=1940ef5c" alt="img"></p><p>我们 go 一个 func 时一般这样写</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func1(arg1 type1,arg2 type2)&#123;....&#125;(a1,a2)</span><br></pre></td></tr></table></figure><p>一个协程代表了一个执行流, 执行流有需要执行的函数(对应上面的 func1), 有函数的入参(a1, a2), 有当前执行流的状态和进度(对应 CPU 的 PC 寄存器和 SP 寄存器), 当然也需要有保存状态的地方, 用于执行流恢复.</p><p>真正代表协程的是 runtime.g 结构体. 每个 go func 都会编译成 runtime.newproc 函数, 最终有一个 runtime.g 对象放入调度队列. 上面的 func1 函数的指针设置在 runtime.g 的 startfunc 字段, 参数会在 newproc 函数里拷贝到 stack 中, sched 用于保存协程切换时的 pc 位置和栈位置.</p><p>协程切换出去和恢复回来需要保存上下文, 恢复上下文, 这些由以下两个汇编函数实现. 以上就能实现协程这种执行流, 并能进行切换和恢复.(下图中的 struct 和函数都做了精简)</p><h3><span id="gm-模型及-gpm-模型"><strong>GM 模型及 GPM 模型</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-836e26770ed9489f835605529e608c37_720w.jpg?source=1940ef5c" alt="img"></p><p>有了协程的这种执行流形式, 那待运行的协程放在哪呢?<br>在 Go1.0 的时候:</p><ol><li>调度队列 schedt 是全局的, 对该队列的操作均需要竞争同一把锁, 导致伸缩性不好.</li><li>新生成的协程也会放入全局的队列, 大概率是被其他 m(可以理解为底层线程的一个表示)运行了, 内存亲和性不好. 当前协程 A 新生成了协程 B, 然后协程 A 比较大概率会结束或者阻塞, 这样 m 直接去执行协程 B, 内存的亲和性也会好很多.</li><li>因为 mcache 与 m 绑定, 在一些应用中(比如文件操作或其他可能会阻塞线程的系统调用比较多), m 的个数可能会远超过活跃的 m 个数, 导致比较大的内存浪费.</li></ol><p>那是不是可以给 m 分配一个队列, 把阻塞的 m 的 mcache 给执行 go 代码的 m 使用? Go 1.1 及以后就是这样做的.</p><p><img src="https://pic1.zhimg.com/50/v2-a06db1f245421b17c64d7bc4f338b71e_720w.jpg?source=1940ef5c" alt="img"></p><p>再 1.1 中调度模型更改为 GPM 模型, 引入逻辑 Process 的概念, 表示执行 Go 代码所需要的资源, 同时也是执行 Go 代码的最大的并行度.</p><p>这个概念可能很多人不知道怎么理解. P 涉及到几点, 队列和 mcache, 还有 P 的个数的选取.</p><p>首先为什么把全局队列打散, 以及 mcache 为什么跟随 P, 这个在 GM 模型那一页就讲的比较清楚了.然后为什么 P 的个数默认是 CPU 核数: Go 尽量提升性能, 那么在一个 n 核机器上, 如何能够最大利用 CPU 性能呢? 当然是同时有 n 个线程在并行运行中, 把 CPU 喂饱, 即所有核上一直都有代码在运行.</p><p>在 go 里面, 一个协程运行到阻塞系统调用, 那么这个协程和运行它的线程 m, 自然是不再需要 CPU 的, 也不需要分配 go 层面的内存. 只有一直在并行运行的 go 代码才需要这些资源, 即同时有 n 个 go 协程在并行执行, 那么就能最大的利用 CPU, 这个时候需要的 P 的个数就是 CPU 核数. (注意并行和并发的区别)</p><h2><span id="协程状态及流转"><strong>协程状态及流转</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-95c62d2ff20b8a75e0ec2eddddaf4bd2_720w.jpg?source=1940ef5c" alt="img"></p><p>协程的状态其实和线程状态类似,状态转换和发生状态转换的时机如图所示. 还是需要注意: 协程只是一个执行流, 并不是运行实体.</p><h2><span id="调度"><strong>调度</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-0328b09cc3dd5537bd463e10ef17db6e_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有一个一直在运行调度的调度器实体. 当一个协程切换出去或新生成的 m, go 的运行时从 stw 中恢复等情况时, 那么接下来就需要发生调度. go 的调度是通过线程(m)执行 runtime.schedule 函数来完成的.</p><h2><span id="sysmon-协程"><strong>sysmon 协程</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-28f751cb1c56fcc275bc545d7f82d869_720w.jpg?source=1940ef5c" alt="img"></p><p>在 linux 内核中有一些执行定时任务的线程, 比如定时写回脏页的 pdflush, 定期回收内存的 kswapd0, 以及每个 cpu 上都有一个负责负载均衡的 migration 线程等.在 go 运行时中也有类似的协程, sysmon.功能比较多: 定时从 netpoll 中获取 ready 的协程, 进行抢占, 定时 GC,打印调度信息,归还内存等定时任务.</p><h2><span id="协作式抢占"><strong>协作式抢占</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-d8baadb9a783032443d3d2fd6b0b5227_720w.jpg?source=1940ef5c" alt="img"></p><p>go 目前(1.12)还没有实现非协作的抢占. 基本流程是 sysmon 协程标记某个协程运行过久, 需要切换出去, 该协程在运行函数时会检查栈标记, 然后进行切换.</p><h2><span id="同步执行流不阻塞线程的网络的实现"><strong>同步执行流不阻塞线程的网络的实现</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-7bed4181eb6bbcba7be4a6b43a604c3e_720w.jpg?source=1940ef5c" alt="img"></p><p>go 写后台最舒服的就是能够以同步写代码的方式操作网络, 但是网络操作不阻塞线程.主要是结合了非阻塞的 fd, epoll 以及协程的切换和恢复.linux 提供了网络 fd 的非阻塞模式, 对于没有 ready 的非阻塞 fd 执行网络操作时, linux 内核不阻塞线程, 会直接返回 EAGAIN, 这个时候将协程状态设置为 wait, 然后 m 去调度其他协程.</p><p>go 在初始化一个网络 fd 的时候, 就会把这个 fd 使用 epollctl 加入到全局的 epoll 节点中. 同时放入 epoll 中的还有 polldesc 的指针.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func netpollopen(fd uintptr, pd *pollDesc) int32 &#123;</span><br><span class="line">    var ev epollevent</span><br><span class="line">    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sysmon 中, schedule 函数中, start the world 中等情况下, 会执行 netpoll 调用 epollwait 系统调用, 把 ready 的网络事件从 epoll 中取出来, 每个网络事件可以通过前面传入的 polldesc 获取到阻塞在其上的协程, 以此恢复协程为 runnable.</p><h2><span id="调度相关结构体"><strong>调度相关结构体</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-85359486219d4ce31b93fa450b592083_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="调度综述"><strong>调度综述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7f7ea37737a8e4ac2809a8122ba62c1c_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic1.zhimg.com/50/v2-8d5f447993ab105b88eac9fb827b2a3c_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="内存分配"><strong>内存分配</strong></span></h2><h2><span id="内存分配简介"><strong>内存分配简介</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-eb6d4ba5968ebe8a0a86318c2ef35ca6_720w.jpg?source=1940ef5c" alt="img"></p><p>Go 的分配采用了类似 tcmalloc 的结构.特点: 使用一小块一小块的连续内存页, 进行分配某个范围大小的内存需求. 比如某个连续 8KB 专门用于分配 17-24 字节,以此减少内存碎片. 线程拥有一定的 cache, 可用于无锁分配.</p><p>同时 Go 对于 GC 后回收的内存页, 并不是马上归还给操作系统, 而是会延迟归还, 用于满足未来的内存需求.</p><h2><span id="内存空间结构"><strong>内存空间结构</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-c1b2977bf1d33669bb9c2774c7b6d8d8_720w.jpg?source=1940ef5c" alt="img"></p><p>在 1.10 以前 go 的堆地址空间是线性连续扩展的, 比如在 1.10(linux amd64)中, 最大可扩展到 512GB. 因为 go 在 gc 的时候会根据拿到的指针地址来判断是否位于 go 的 heap 的, 以及找到其对应的 span, 其判断机制需要 gc heap 是连续的. 但是连续扩展有个问题, cgo 中的代码(尤其是 32 位系统上)可能会占用未来会用于 go heap 的内存. 这样在扩展 go heap 时, mmap 出现不连续的地址, 导致运行时 throw.</p><p>在 1.11 中, 改用了稀疏索引的方式来管理整体的内存. 可以超过 512G 内存, 也可以允许内存空间扩展时不连续.在全局的 mheap struct 中有个 arenas 二阶数组, 在 linux amd64 上,一阶只有一个 slot, 二阶有 4M 个 slot, 每个 slot 指向一个 heapArena 结构, 每个 heapArena 结构可以管理 64M 内存, 所以在新的版本中, go 可以管理 4M*64M=256TB 内存, 即目前 64 位机器中 48bit 的寻址总线全部 256TB 内存.</p><h2><span id="span-机制"><strong>span 机制</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-84e72feda2d2cd49aaad59bb6f72837c_720w.jpg?source=1940ef5c" alt="img"></p><p>前面提到了 go 的内存分配类似于 tcmalloc, 采用了 span 机制来减少内存碎片. 每个 span 管理 8KB 整数倍的内存, 用于分配一定范围的内存需求.</p><h2><span id="内存分配全景"><strong>内存分配全景</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-11756712c78ee841873eb9aa22198f3c_720w.jpg?source=1940ef5c" alt="img"></p><p>多层次的分配 Cache, 每个 P 上有一个 mcache, mcache 会为每个 size 最多缓存一个 span, 用于无锁分配. 全局每个 size 的 span 都有一个 mcentral, 锁的粒度相对于全局的 heap 小很多, 每个 mcentral 可以看成是每个 size 的 span 的一个全局后备 cache.</p><p>在 gc 完成后, 会把 P 中的 span 都 flush 到 mcentral 中, 用于清扫后再分配. P 有需要 span 时, 从对应 size 的 mcentral 获取. 获取不到再上升到全局的 heap.</p><h2><span id="几种特殊的分配器"><strong>几种特殊的分配器</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-e35ffea692133cbe86898cdf3eb55352_720w.jpg?source=1940ef5c" alt="img"></p><p>对于很小的对象分配, go 做了个优化, 把小对象合并, 以移动指针的方式分配.对于栈内存有 stackcache 分配, 也有多个层次的分配, 同时 stack 也有多个不同 size. 用于分配 stack 的内存也是位于 go gc heap, 用 mspan 管理, 不过这个 span 的状态和用于分配对象的 mspan 状态不太一样, 为 mSpanManual.</p><p>我们可以思考一个问题, go 的对象是分配在 go gc heap 中, 并由 mcache, mspan, mcentral 这些结构管理, 那么 mcache, mspan, mcentral 这些结构又是哪里管理和分配的呢? 肯定不是自己管理自己. 这些都是由特殊的分配 fixalloc 分配的, 每种类型有一个 fixalloc, 大致原理就是通过 mmap 从进程空间获取一小块内存(百 KB 的样子), 然后用来分配这个固定大小的结构.</p><h2><span id="内存分配综合"><strong>内存分配综合</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-1a3d04db061c92d10bed0e5ab0df1c16_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc"><strong>GC</strong></span></h2><h2><span id="golang-gc-简述"><strong>Golang GC 简述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7eb346f748153072b454b9b78759e067_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc-简介"><strong>GC 简介</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-ecebbf99b365d076f7076b31a30fc3e8_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 并不是个新事物, 使得 GC 大放光彩的是 Java 语言.</p><p><img src="https://pica.zhimg.com/50/v2-05266f76d410fe9d90fd1dbd23570953_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic3.zhimg.com/50/v2-291b501f005c3958111daf30bcec1a2b_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="golang-gc-发展"><strong>Golang GC 发展</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-558037836bb253c0777a4a822516d27e_720w.jpg?source=1940ef5c" alt="img"></p><p>上面是几个比较重要的版本.左图是根据 twitter 工程师的数据绘制的(堆比较大), 从 1.4 的百 ms 级别的停顿到 1.8 以后的小于 1ms.右图是我对线上服务(Go 1.11 编译)测试的一个结果, 是一个批量拉取数据的服务, 大概 3000qps, 服务中发起的 rpc 调用大概在 2w/s. 可以看到大部分情况下 GC 停顿小于 1ms, 偶尔超过一点点.</p><p>整体来说 golang gc 用起来是很舒心的, 几乎不用你关心.</p><h2><span id="三色标记"><strong>三色标记</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-652acc8ca5d0f04c455c68d1084cd309_720w.jpg?source=1940ef5c" alt="img"></p><p>go 采用的是并发三色标记清除法. 图展示的是一个简单的原理.有几个问题可以思考一下:</p><ul><li>并发情况下, 会不会漏标记对象?</li><li>对象的三色状态存放在哪?</li><li>如何根据一个对象来找到它引用的对象?</li></ul><h3><span id="写屏障"><strong>写屏障</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-8c43a67a0eba214a81f56c873504c884_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 最基本的就是正确性: 不漏标记对象, 程序还在用的对象都被清除了, 那程序就错误了. 有一点浮动垃圾是允许的.<br>在并发情况下, 如果没有一些措施来保障, 那可能会有什么问题呢?</p><p>看左边的代码和图示, 第 2 步标记完 A 对象, A 又没有引用对象, 那 A 变成黑色对象. 在第 3 步的时候, muator(程序)运行, 把对象 C 从 B 转到了 A, 第 4 步, GC 继续标记, 扫描 B, 此时 B 没有引用对象, 变成了黑色对象. 我们会发现 C 对象被漏标记了.</p><p>如何解决这个问题? go 使用了写屏障, 这里的写屏障是指由编译器生成的一小段代码. 在 gc 时对指针操作前执行的一小段代码, 和 CPU 中维护内存一致性的写屏障不太一样哈.所以有了写屏障后, 第 3 步, A.obj=C 时, 会把 C 加入写屏障 buf. 最终还是会被扫描的.</p><p><img src="https://pic3.zhimg.com/50/v2-69b05d315557f599251e091a0d4a00d9_720w.jpg?source=1940ef5c" alt="img"></p><p>这里感受一下写屏障具体生成的代码. 我们可以看到在写入指针 slot 时, 对写屏障是否开启做了判断, 如果开启了, 会跳转到写屏障函数, 执行加入写屏障 buf 的逻辑. 1.8 中写屏障由 Dijkstra 写屏障改成了混合式写屏障, 使得 GC 停顿达到了 1ms 以下.</p><h3><span id="三色状态"><strong>三色状态</strong></span></h3><p><img src="https://pic2.zhimg.com/50/v2-4dd9c75a72c82eaf3690386dcf286cdb_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有这样一个集合把不同状态对象放到对应集合中. 只是一个逻辑上的意义.</p><h3><span id="扫描和元信息"><strong>扫描和元信息</strong></span></h3><p><img src="https://pica.zhimg.com/50/v2-ee14e9737cbb929bc95ec3af883e5474_720w.jpg?source=1940ef5c" alt="img"></p><p>gc 拿到一个指针, 如何把这个指针指向的对象其引用的子对象都加到扫描队列呢? 而且 go 还允许内部指针, 似乎更麻烦了. 我们分析一下, 要知道对象引用的子对象, 从对象开始到对象结尾, 把对象那一块内存上是指针的放到扫描队列就好了. 那我们是不是得知道对象有多大, 从哪开始到哪结束, 同时要知道内存上的 8 个字节, 哪里是指针, 哪里是普通的数据.</p><p>首先 go 的对象是 mspan 管理的, 我们如果能知道对象属于哪个 mspan, 就知道对象多大, 从哪开始, 到哪结束了. 前面我们讲到了 areans 结构, 可以通过指针加上一定得偏移量, 就知道属于哪个 heap arean 64M 块. 再通过对 64M 求余, 结合 spans 数组, 即可知道属于哪个 mspan 了.</p><p>结合 heapArean 的 bitmap 和每 8 个字节在 heapArean 中的偏移, 就可知道对象每 8 个字节是指针还是普通数据(这里的 bitmap 是在分配对象时根据 type 信息就设置了, type 信息来源于编译器生成)</p><h2><span id="gc-流程"><strong>GC 流程</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-e0eef1afbfa873db4b0faa21a4741c5f_720w.jpg?source=1940ef5c" alt="img"></p><p>1.5 和 1.12 的 GC 大致流程相同. 上图是 golang 官方的 ppt 里的图, 下图是我根据 1.12 源码绘制的.从最坏可能会有百 ms 的 gc 停顿到能够稳定在 1ms 以下, 这之间 GC 做了很多改进. 右边是我根据官方 issues 整理的一些比较重要的改进. 1.6 的分布式检测, 1.7 将栈收缩放到了并发扫描阶段, 1.8 的混合写屏障, 1.12 更改了 mark termination 检测算法, mcache flush 移除出 mark termination 等等.</p><h2><span id="golang-gc-pacer"><strong>Golang GC Pacer</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-e5d325ee3dbdf9b2911520651798a872_720w.jpg?source=1940ef5c" alt="img"></p><p>大家对并发 GC 除了怎么保证不漏指针有疑问外, 可能还会疑问, 并发 GC 如何保证能够跟得上应用程序的分配速度? 会不会分配太快了, GC 完全跟不上, 然后 OOM?</p><p>这个就是 Golang GC Pacer 的作用.</p><p>Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 以此类推.</p><p>假如上一次 GC 完成时, 存活对象 1000M, 默认 GOGC 100, 那么下次 GC 会在比较接近但小于 2000M 的时候(比如 1900M)开始, 争取在堆大小达到 2000M 的时候结束. 这之间留有一定的裕度, 会计算待扫描对象大小(根据历史数据计算)与可分配的裕度的比例, 应用程序分配内存根据该比例进行辅助 GC, 如果应用程序分配太快了, 导致 credit 不够, 那么会被阻塞, 直到后台的 mark 跟上来了,该比例会随着 GC 进行不断调整.</p><p>GC 结束后, 会根据这一次 GC 的情况来进行负反馈计算, 计算下一次 GC 开始的阈值.</p><p>如何保证按时完成 GC 呢? GC 完了后, 所有的 mspan 都需要 sweep, 类似于 GC 的比例, 从 GC 结束到下一次 GC 开始之间有一定的堆分配裕度, 会根据还有多少的内存需要清扫, 来计算分配内存时需要清扫的 span 数这样的一个比例.</p><p><img src="https://pic2.zhimg.com/50/v2-92218cc498cc9ae159ba9e95df29f4c9_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="实践与总结"><strong>实践与总结</strong></span></h2><h2><span id="观察调度"><strong>观察调度</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-78cd3a12e7aecf54c56eabca2c879f78_720w.jpg?source=1940ef5c" alt="img"></p><p>观察一下调度, 加一些请求. 我们可以看到虽然有 1000 个连接, 但是 go 只用了几个线程就能处理了, 表明 go 的网络的确是由 epoll 管理的. runqueue 表示的是全局队列待运行协程数量, 后面的数字表示每个 P 上的待运行协程数. 可以看到待处理的任务并没有增加, 表示虽然请求很多, 但完全能 hold 住.</p><p>同时可以看到, 不同 P 上有的时候可能任务不均衡, 但是一会后, 任务又均衡了, 表示 go 的 work stealing 是有效的.</p><h2><span id="观察-gc"><strong>观察 GC</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-596836ab3923ed21c32a4a961264d7d8_720w.jpg?source=1940ef5c" alt="img"></p><p>其中一些数据的含义, 在分享的时候没有怎么解释, 不过网上的解释几乎没有能完全解释正确. 我这里敲一下.<br>其实一般关注堆大小和两个 stw 的 wall time 即可.</p><p>gc 8913(第 8913 次 gc) @2163.341s(在程序运行的第 2163s) 1%(gc 所有 work 消耗的历史累计 CPU 比例, 所以其实这个数据没太大意义) 0.13(第一个 stw 的 wall time)+14(并发 mark 的 wall time)+0.20(第二个 stw 的 wall time) ms clock, 1.1(第一个 stw 消耗的 CPU 时间)+21(用户程序辅助扫描消耗的 cpu 时间)/22(分配用于 mark 的 P 消耗的 cpu 时间)/0(空闲的 P 用于 mark 的 cpu 时间)+1.6ms(第 2 个 stw 的 cpu 时间) cpu, 147(gc 开始时的堆大小)-&gt;149(gc 结束的堆大小)-&gt;75MB(gc 结束时的存活堆大小), 151 MB goal(本次 gc 预计结束的堆大小), 8P(8 个 P).</p><h2><span id="优化"><strong>优化</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-dd28c6e140bbcd27d737f61e980b562b_720w.jpg?source=1940ef5c" alt="img"></p><p>个人建议, 没事不要总想着优化, 好好 curd 就好.</p><p><img src="https://pica.zhimg.com/50/v2-2e0bbec8ffca844876195af2e970e8a6_720w.jpg?source=1940ef5c" alt="img"></p><p>当然还是有一些优化方法的.</p><h2><span id="一点实践"><strong>一点实践</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-827fe7197304383f74f774d3c23d8df7_720w.jpg?source=1940ef5c" alt="img"></p><p>我们将 pprof 的开启集成到模板中, 并自动选择端口, 并集成了 gops 工具, 方便查询 runtime 信息, 同时在浏览器上可直接点击生成火焰图, pprof 图, 非常的方便, 也不需要使用者关心.</p><h2><span id="问题排查的一点思路"><strong>问题排查的一点思路</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-eb8dc800c3390a55be87d142cee862f2_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="一次有意思的问题排查"><strong>一次有意思的问题排查</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-8360b4e634560ca5ac314b7b76181b98_720w.jpg?source=1940ef5c" alt="img"></p><p>负载, 依赖服务都很正常, CPU 利用率也不高, 请求也不多, 就是有很多超时.</p><p><img src="https://pic1.zhimg.com/50/v2-8a0e06b128b6f2316d8462b9dbc30e0b_720w.jpg?source=1940ef5c" alt="img"></p><p>该服务在线上打印了 debug 日志, 因为早期的服务模板开启了 gctrace, 框架把 stdout 重定向到一个文件了. 而输出 gctrace 时本来是到 console 的, 输出到文件了, 而磁盘跟不上, 导致 gctrace 日志被阻塞了.</p><p>这里更正一下 ppt 中的内容, 并不是因为 gc 没完成而导致其他协程不能运行, 而是后续 gc 无法开启, 导致实质上的 stw.<br>打印 gc trace 日志时, 已经 start the world 了, 其他协程可以开始运行了. 但是在打印 gctrace 日志时, 还保持着开启 gc 需要的锁, 所以, 打印 gc trace 日志一直没完成, 而 gc 又比较频繁, 比如 0.1s 一次, 这样会导致下一次 gc 开始时无法获取锁, 每一个进入 gc 检查的 p 阻塞, 实际上就造成了 stw.</p><h2><span id="runtime-的一点个人总结"><strong>Runtime 的一点个人总结</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-2c598eec44a5909786868950c5224a6c_720w.jpg?source=1940ef5c" alt="img"></p><p>并行, 纵向多层次, 横向多个 class, 缓存, 缓冲, 均衡.</p><h2><span id="参考文档"><strong>参考文档</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-406faead2e6957e16a50c5b42f58053a_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>本文完整 PPT 可点击下方图片获得。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>开发空间使用文档</title>
    <link href="https://smartxia.github.io/blog/2021/09/01/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>https://smartxia.github.io/blog/2021/09/01/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</id>
    <published>2021-09-01T07:44:30.000Z</published>
    <updated>2021-11-16T03:33:44.715Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="开发空间使用文档">开发空间使用文档</span></h2><h3><span id="项目设置">项目设置</span></h3><h4><span id="项目主页">项目主页</span></h4><p>项目名称：默认创建的时候的名称，可以在这里修改</p><p>封面：项目的封面，可以用来发布，图片尺寸符合页面提示内容</p><p>简介：项目的一些简单介绍</p><h4><span id="代码仓库">代码仓库</span></h4><p>代码仓库默认分为语言类型的git仓库，所带有的框架默认支持打包，和支持中台的基本框架</p><p>前端仓库：vue idg等</p><p>后端仓库：golang java php node 等 </p><p>ios,android,中台小程序，微信小程序，h5，浏览器插件，pc，跨段应用，</p><p>勤务仓库，和区块链专用仓库，并支持复制其他仓库</p><h5><span id="仓库使用">仓库使用：</span></h5><p>默认开发者为主master分支管理员</p><p>分支:</p><p>合并请求：可以合并其他用户提交的合并请求</p><p>标签：利用此标签可以用来打包集成各类型的资产包和镜像</p><p>成员：可以添加成员</p><h4><span id="镜像管理">镜像管理</span></h4><p>可以分为两大类：镜像（可以直接放在服务器运行的）包管理（可以支持其他服务引入的）</p><p>镜像根据仓库类型里的tag然后进行打包：</p><p>包括：php(5-*7)类型，golang(13-15)java 和其他类型打包 vue类型镜像</p><p>包根据仓库里的tag进行打包：</p><p>包括:npm android ios composer h5等类型dab</p><h4><span id="成员管理">成员管理</span></h4><p>此处用来添加用户，其中项目成员基本权限要有：项目负责人或者项目参与者。支持批量添加用户角色</p><h4><span id="部署设置">部署设置</span></h4><p>b部署设置放在此处比较早，需要后端或者项目负责人添加。</p><p>其中包括：对项目所需要的容器资源类型进行配置，和资源模板配置，cpu membery port 等</p><h3><span id="产品定义">产品定义</span></h3><ul><li>模块列表：默认有主模块。主模块权限属于第一个使用产品定义的人，并非创建者。</li></ul><p>可以选择新增模块，填写模块名称和描述，模块标签</p><p>模块之间支持的功能：利用密钥来实现复制（内容复制）和分享（通道分享）</p><p>模块之间可以添加用户，给用户赋予模块负责人、模块参与者（只有浏览权限）</p><ul><li><p>任务列表：</p><p>包括产品、后端、设计使用的基本工具和文档</p><p>需求定义：产品需要写的一些基本功能提供。项目创立之初的一些信息收集，和基本的作图，设计用例，数据模型等功能的支持</p><p>设计文档：一些基本的设计图片文稿，竞品分析，设计用的图片且支持图片拖动执行</p><p>技术定义：后端的一些基本api文档填写</p><p>数据定义：数据库相关的基本使用</p><p>每个分类下分为各种的类型使用，种类繁多，满足项目创立之初所有的使用</p></li></ul><h3><span id="多语言管理">多语言管理</span></h3><h4><span id="项目多语言">项目多语言</span></h4><p>支撑项目内关键词，各个国家语言的翻译使用</p><h3><span id="会议记录">会议记录</span></h3><p>记录项目成员每次开会使用的基本任务</p><h3><span id="接入管理">接入管理</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="资源管理">资源管理</span></h3><p>容器云所需的资源购买和资源配置</p><h3><span id="部署空间">部署空间</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="项目管理">项目管理</span></h3><p>项目issue配置</p><h3><span id="cicd">CICD</span></h3><p>项目自动化测试</p><h3><span id="发布管理">发布管理</span></h3><p>项目发布到市场</p><h3><span id="gui管理">GUI管理</span></h3><p>gui前端界面自动化添加</p><h3><span id="wiki">WIKI</span></h3><p>项目Wiki记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GOLGANG-笔记6-学习日志位运算符</title>
    <link href="https://smartxia.github.io/blog/2021/08/27/GOLANG/GOLGANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://smartxia.github.io/blog/2021/08/27/GOLANG/GOLGANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2021-08-27T01:55:06.000Z</published>
    <updated>2021-11-16T10:00:30.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>位运算：位运算符对整数在内存中的二进制位进行操作。</p><p> &amp;, |, 和 ^ </p><p>》》》 《《《</p><p>数组</p><p>var a 【5】string</p><p>a:=[5]string[“2”,”3”,”4”,”2”,”3”]</p><p>a:=[….]string[“2”,”3”,”4”,”2”,”3”]</p><p>空指针：指针定义后没有分配到任何变量就会错</p><p>旧的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  topocpzejlq4huin6cmhieqxxn8fep7n  263</p><p>新的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  8191a23b9783477599b9f01f53f5bab7 37</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机基础-转义字符</title>
    <link href="https://smartxia.github.io/blog/2021/06/22/Wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/06/22/Wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</id>
    <published>2021-06-22T02:54:33.000Z</published>
    <updated>2021-11-16T03:33:44.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是转义字符有什么用">什么是转义字符？有什么用？</span></h3><p>转义字符是一种特殊的字符常量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://smartxia.github.io/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="转义字符" scheme="https://smartxia.github.io/blog/tags/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    
      <category term="wiki" scheme="https://smartxia.github.io/blog/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式-修饰符</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2021-06-07T08:09:29.000Z</published>
    <updated>2021-11-16T03:33:44.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ul><li><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p></li><li><p>标记不写在正则表达式里，标记位于表达式之外</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;pattern&#x2F;flags</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h4><span id="元字符">元字符</span></h4><h4><span id="运算符优先级">运算符优先级</span></h4><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/categories/regex/"/>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式-语法</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/</id>
    <published>2021-06-07T05:40:59.000Z</published>
    <updated>2021-11-16T03:33:44.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></p><h4><span id="1普通字符1-9-a-z-a-z-标点符号和一些其他符号">1.普通字符：1-9 a-z A-Z 标点符号和一些其他符号。</span></h4><p><img src="//s2-cdn.oneitfarm.com/eab92d4dcdab496abde257a6adf121c8.png" alt></p><table><thead><tr><th>key</th><th>val</th><th>desc</th><th>exp</th></tr></thead><tbody><tr><td>/*/</td><td></td><td>基础语法区隔，转义符号</td><td></td></tr><tr><td>^</td><td></td><td>开始位置</td><td></td></tr><tr><td>$</td><td></td><td>结束位置</td><td></td></tr><tr><td>[0-9]</td><td></td><td>匹配数字</td><td></td></tr><tr><td>[a-z]</td><td></td><td>小写字母</td><td></td></tr><tr><td>[A-Z]</td><td></td><td>大写字母</td><td></td></tr><tr><td>+</td><td>runoo+b</td><td>匹配一个或多个</td><td></td></tr><tr><td>-</td><td></td><td>连接字符</td><td></td></tr><tr><td>{}</td><td>{3,5}</td><td>字符长度3-5</td><td>^[a-z0-9_-]{3,15}$</td></tr><tr><td>？</td><td>colou?r</td><td>匹配 color 或者 colour</td><td></td></tr><tr><td>…</td><td>[…]</td><td>匹配所有字符</td><td></td></tr><tr><td>( )</td><td>(  )</td><td>子表达式的开始和结束位置</td><td></td></tr></tbody></table><h4><span id="2非打印字符">2.非打印字符</span></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/categories/regex/"/>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-06-07T01:49:48.000Z</published>
    <updated>2021-11-16T03:33:44.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><!-- toc --><ul><li><a href="#10-网络协议tcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</a></li><li><a href="#11-请求头">1.1 请求头</a></li><li><a href="#12-三次握手四次挥手">1.2 三次握手四次挥手</a></li><li><a href="#13-报文抓取工具">1.3 报文抓取工具</a><ul><li><a href="#20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</a></li></ul></li><li><a href="#21-请求报文">2.1 请求报文</a></li><li><a href="#22-响应报文">2.2 响应报文</a></li><li><a href="#23-http-抓取工具">2.3 HTTP 抓取工具</a></li><li><a href="#24-session-cookie">2.4 Session Cookie</a><ul><li><a href="#30-总结">3.0 总结</a></li></ul></li></ul><!-- tocstop --><h4><span id="10-网络协议tcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</span></h4><ul><li><p>TCP 七层网络模型<br>主机层：<br>媒介层：</p><p><img src="http://s2-cdn.oneitfarm.com/767fb54c00ef41d1b15f28a8c33f3d16.png" alt></p></li></ul><h4><span id="11-请求头">1.1 请求头</span></h4><h4><span id="12-三次握手四次挥手">1.2 三次握手四次挥手</span></h4><h4><span id="13-报文抓取工具">1.3 报文抓取工具</span></h4><h3><span id="20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</span></h3><p><img src="//s2-cdn.oneitfarm.com/205566ffbffc4786af2443e348192532.png" alt></p><h4><span id="21-请求报文">2.1 请求报文</span></h4><h4><span id="22-响应报文">2.2 响应报文</span></h4><h4><span id="23-http-抓取工具">2.3 HTTP 抓取工具</span></h4><h4><span id="24-session-cookie">2.4 Session Cookie</span></h4><h3><span id="30-总结">3.0 总结</span></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://smartxia.github.io/blog/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>The MIT License</title>
    <link href="https://smartxia.github.io/blog/2021/05/27/Wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://smartxia.github.io/blog/2021/05/27/Wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-05-27T01:25:29.000Z</published>
    <updated>2021-11-16T03:33:44.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>MIT许可证（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件授权条款（如GPL、LGPL、BSD）相比，MIT是相对宽松的软件授权条款。</p></blockquote><h3><span id="1条款内容">1.条款内容</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span><br><span class="line">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br></pre></td></tr></table></figure><h3><span id="2mit与其他开源许可证的区别">2.MIT与其他开源许可证的区别</span></h3><p><img src="//s2-cdn.oneitfarm.com/2bec9f7690a945a499ebc95fd84a0cb5.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="其他" scheme="https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>孔乙己和阿Q</title>
    <link href="https://smartxia.github.io/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/"/>
    <id>https://smartxia.github.io/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/</id>
    <published>2021-05-26T02:23:14.000Z</published>
    <updated>2021-11-16T03:33:44.717Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>孔乙己原为鲁迅笔下的一个旧时代的人物，我们可以简单理解为一个臭读书的<br>阿Q我们听到的最多的是阿Q精神：自恋不自知的小人物<br>这些都是鲁迅笔下的小人物，之前不大明白鲁迅为何喜欢写这些我们现在看起来抨击小人物的短片小说，<br>包括对闰土 阿Q 孔乙己 祥林嫂 范爱农等等这些现在看起来很离谱的事情，这要是放到现在不得不说是一股奇葩的力量<br>在微博贡献，因为本人也是个冲浪的键盘侠。<br>但了解过鲁迅大大说过一句很经典的话：学医救不了中国人<br>当时是民国 想想这句话到底有几个味道大家便知道了<br>现在提起来中国人，你走到哪里都是自豪的，除了蜜汁自信呢的美帝，最起码在国外是没问题的，对于一个长时间被中央人民广播电台熏陶的年青人是这样的</p><p>当时中国是被侵略，被十几个人打，想想那画面，不敢还手，对于国家至此，何况老百姓。<br>其实鲁迅笔下任务用的最多为小小的底层任务对社会，谈不上社会，而是对自己的生活圈子里造成的影响，可有可无的那种。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>从正则表达式的iUs说说模式修正符</title>
    <link href="https://smartxia.github.io/blog/2021/05/25/PHP/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/05/25/PHP/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/</id>
    <published>2021-05-25T11:06:09.000Z</published>
    <updated>2021-11-16T03:33:44.696Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>本想做个简单的采集程序，发现被抓页面代码的规律后发现抓下来的内容没有放到一个数组中，而是放在一个元素中，无奈找遍资料发现在正则表达式后加上”/iUs”后竟然可以了。<br>hexo<br>网上关于iUs的说明多数都是抄袭的，没有做过多的解释，对于一个小学毕业证是买来的人来说是在是不好理解。不过幸亏Google让我找到答案。</p><p>“iUs” 在这里叫“模式修正符”。模式修正符其实就是几个字母，可以一次使用一个也可以一次使用多个，每一个都具有一定的意义，模式修正符是对正则表达式的扩展；“/模式修正符”，其中正斜线“/”为边界符。下表列出来有那些模式修正符：</p><p>模式修正符    说明<br>i    表示在和模式进行匹配进不区分大小写<br>m    将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束<br>s    如果没有使用这个模式修正符号，元字符中的”.”默认不能表示换行符号,将字符串视为单行<br>x    表示模式中的空白忽略不计<br>e    正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说)<br>A    以模式字符串开头，相当于元字符^<br>Z    以模式字符串结尾，相当于元字符$<br>U    正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式</p><h3><span id="1模式修正符m">1，模式修正符m。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;^abc&#x2F;m’;</span><br><span class="line">$string &#x3D; ‘bcd</span><br><span class="line">abc</span><br><span class="line">cba’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>匹配结果是成功的。注意：我们在使用模式修正符m的时候，将匹配字符串看成是多行而不是默认的单行，所以任何一行只要是以abc开头，就匹配成功。但是，如果能匹配的行前面有空格的话，就不能匹配了!除非修改正则表达式的匹配模式。</p><h3><span id="2模式修正符s">2，模式修正符s。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;a.*c&#x2F;s’;</span><br><span class="line">$string &#x3D; ‘adsadsa</span><br><span class="line">c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配记过也是成功的。如果你将上例中的模式修正符s去掉的话，匹配就会失败。因为模式修正符s将匹配字符串看作是单行的，所以这个时候，元字符中的”.”就可以表示换行符号了。</p><h3><span id="3模式修正符x">3，模式修正符x。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;a c&#x2F;x’;</span><br><span class="line">$string &#x3D; ‘a c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配结果是失败的。因为我们使用模式修正符x取消了模式中的空格。注意：我们无法使用模式修正符取消\s表示的空白。</p><h3><span id="4模式修正符a">4，模式修正符A。</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;ac&#x2F;A’;</span><br><span class="line">$string &#x3D; ‘acahgyghvbm’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正则表达式表示的含义是匹配以ac开头的字符串，结果成功。</p><p>模式修正符Z表示的是以字符串结尾的匹配，和A的用法是一样的，我们不再进行演示。</p><h3><span id="5模式修正符u">5，模式修正符U。</span></h3><p>这个模式修正符是十分重要的!在正则表达式中，其本身是“贪婪”的。那什么是贪婪模式呢?贪婪模式的意思就是说，正则表达式默认会在查找到第一个匹配后，继续尝试后面的匹配，如果能找到匹配，则匹配最大的范围字符串。但有的时候这并不是我们想要的结果，所以我们需要取消贪婪模式。</p><p>我们还是先看一个贪婪模式的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*&lt;\&#x2F;b&gt;&#x2F;’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个实例的本意是匹配welcome，但是结果却匹配了welcome to phpfuns整个字符串(注意我们的字符串’welcome to phpfuns’，其开头和结尾正好构成了正则表达式的模式匹配，所以匹配成功)，这就是正则表达式的贪婪模式。当然，这不是我们要的结果。</p><p>取消贪婪模式<br>我们可以使用模式修正符U和元字符?两种方式取消正则表达式的贪婪模式。</p><p>模式修正符U取消贪婪模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*&lt;\&#x2F;b&gt;&#x2F;U’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>元字符?取消贪婪模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern &#x3D; ‘&#x2F;&lt;b&gt;.*?&lt;\&#x2F;b&gt;&#x2F;’;</span><br><span class="line">$string &#x3D; ‘&lt;b&gt;welcome&lt;&#x2F;b&gt; &lt;b&gt;to&lt;&#x2F;b&gt; &lt;b&gt;phpfuns&lt;&#x2F;b&gt;dsadsadas’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;&#x2F;b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;&#x2F;b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color&#x3D;’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;&#x2F;font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意元字符的位置，我们必须在“”之前结束贪婪模式，才能达到我们的目的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>关于 URL 中协议的省略</title>
    <link href="https://smartxia.github.io/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/"/>
    <id>https://smartxia.github.io/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/</id>
    <published>2021-05-25T01:15:06.000Z</published>
    <updated>2021-11-16T03:33:44.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>前天看了 Google HTML/CSS 代码风格指南，里面有很多值得借鉴的地方，也学到了一些新东西，其中第一条说道，HTML 和 CSS 代码中引用的图片、媒体、CSS 和 JS 文件中的 URL 都可以去掉协议部分（http: 和 https:），比如</p><script src="http://www.google-analytics.com/ga.js" type="text/javascript"></script><script src="https://www.google-analytics.com/ga.js" type="text/javascript"></script><p>都可以换成：</p><script src="//www.google-analytics.com/ga.js" type="text/javascript"></script><p>只要是使用 http、https 这两种协议都可以省略。原因是可以节省一点文件体积（当然只是那么一点点），另外一个原因 Google 说是可以解决混合内容的问题。起初我对这个第二点不是很了解，所以特意搜索了下。最后从 Paul Irish 的一篇文章找到答案，链接在文后。文章是两三年前写的，老外研究问题总是比我们要早啊。</p><p>以 // 开头的叫做相对URL（protocol-relative URL），相关的标准可以看 RFC 3986 Section 4.2，内容不是一般的长估计大家也没耐心去看吧。总之浏览器遇到相对 URL，则会根据当前的网页协议，自动在 // 前面加上相同的协议。如当前网页是 http 访问，那么所有的相对引用 // 都会变成http://。https 同理。如果你在本地查看，协议就会变成 file://。</p><p>所以，如果省略协议，就需要保证引用的外部资源也采用和网页相同的协议，或者保证资源可以同时通过 http 和 https 访问。经过 StackOverflow 网友测试，这种用法几乎所有的浏览器都能支持，只有在 IE7/8 下会有一点小问题，就是通过相对 URL 引用的 CSS 文件（无论 <link> 或 @import）会被下载两遍。所以对性能有一点影响。</p><p>至于 Google 提到的混合内容问题，其实是指IE有时会弹出的一个警告框：</p><p>这个框想必大家也都见过。通常是在浏览 https 网页的时候出现，原因是网页里引用了 http 协议的外部资源，由于 http 被认为是不安全的，IE 才会给出提示。如果引用的时候写成相对 URL，浏览器就会自动采用 https 协议下载，这样就解决了问题。</p><p>所以，我们平时写代码还是可以放心使用相对 URL 的，写博客的大概很少开 https，当然做项目的就例外了。如果你引用的资源里有 https 协议的就特别处理一下，或者只要 http 也能访问到资源就可以。我看了下国内的站点这么用的还不多，有一次看到百度音乐这么用过。不过 Google 很多站点都已经是这样的写法了。</p><hr>> 参考资料：<p><a href="http://paulirish.com/2010/the-protocol-relative-url/">http://paulirish.com/2010/the-protocol-relative-url/</a><br><a href="http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just">http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just</a><br><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><blockquote><p>转载 自：<a href="http://pandacafe.net/post/231?huvqlc=r5eup1">http://pandacafe.net/post/231?huvqlc=r5eup1</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="前端知识" scheme="https://smartxia.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="http://" scheme="https://smartxia.github.io/blog/tags/http/"/>
    
      <category term="https://" scheme="https://smartxia.github.io/blog/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>天气晴-2021-5-20</title>
    <link href="https://smartxia.github.io/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/"/>
    <id>https://smartxia.github.io/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/</id>
    <published>2021-05-20T01:09:27.000Z</published>
    <updated>2021-11-16T03:33:44.716Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="今天是2021年5月20日是个好日子">今天是2021年5月20日，是个好日子</span></h3><p> 早上打开电脑 撇了下右下角的电脑，是2021/5/20 嗯是个吉利的数字</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>百年孤独</title>
    <link href="https://smartxia.github.io/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/"/>
    <id>https://smartxia.github.io/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/</id>
    <published>2021-05-18T01:33:24.000Z</published>
    <updated>2021-11-16T03:33:44.719Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><h3><span id="家族的第一个人被捆在树上最后一个人正被蚂蚁吃掉">家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉</span></h3></blockquote><ul><li>这本书到底讲了什么？作者想表达什么？自己有了什么样的感触<hr></li></ul><h3><span id="经典语句">经典语句</span></h3><p>1、多年以后，奥雷连诺上校站在行刑队面前，准会想起父亲带他去参观冰块的那个遥远的下午。</p><p>2、 过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂热最坚贞的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。</p><p>3、买下一张永久车票，登上一列永无终点的火车。</p><p>4、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>5、生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p><p>6、我确实一度死去，但难以忍受孤独又重返人世。</p><p>7、他渴望孤独，对整个世界的怨恨咬噬着他的内心。</p><p>8、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>9、所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。</p><p>10、这手稿上所写的事情过去不曾，将来也永远不会重复，因为命中注定要一百年处于孤独的世家决不会有出现在世上的第二次机会。</p><h3><span id="百年孤独讲述了什么">百年孤独讲述了什么</span></h3><p>《百年孤独》讲的是一个叫布恩迪亚家族百年的兴衰以及小镇马孔多的发展变迁史。</p><p>布恩迪亚家族的每一代人都在努力地摆脱孤独落后的生活状态，但是却一次又一次的失败，最终，家族的最后一个人被蚂蚁吃掉，整个屋子也被风卷走，从此消失在地球上，再未出现。</p><p>孤独会让人丧失对生活的希望。没有人喜欢孤独，布恩迪亚家族的人付出了一辈又一辈的努力，却依然是一场空，书也表现了人类的抗争，对命运的无可奈何以及天性的顽固。</p><h3><span id="百年孤独反思">百年孤独反思</span></h3><p>《百年孤独》是哥伦比亚作家加西亚·马尔克斯的一部长篇小说</p><p>百年孤独比较适合25岁以上，经历过社会的人看。这样才能读出韵味的。</p><p>说到底《百年孤独》好在它的新颖，不仅让人们看到一个不一样的故事，也让人看到了小说不一样的表现手，而且这种不一样的表现手法，被国内许多的作家所借鉴引用。这也就是《百年孤独》的好处。</p><p>可以不客气地说，《百年孤独》影响了中国当代文学的走向，国内许多的作家，正是由于看了这本小说之后，才开始写出了自己最为重要的作品，例如莫言、陈忠实、余华、阎连科等等，这些国内一线作家，那都是受到了《百年孤独》的影响，他们的作品里，都有着《百年孤独》的影子。也正是这一份影响，使得它在国人心目中，有着崇高的地位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
