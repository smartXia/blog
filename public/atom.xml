<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Some</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>https://smartxia.github.io/blog</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2022-03-16T07:20:04.925Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>darp Docs</title>
    <link href="https://smartxia.github.io/blog/2022/03/16/darp-Docs/"/>
    <id>https://smartxia.github.io/blog/2022/03/16/darp-Docs/</id>
    <published>2022-03-16T06:59:18.000Z</published>
    <updated>2022-03-16T07:20:04.925Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>dapr 文档贡献<br>dapr 文档贡献规则：<a href="https://docs.dapr.io/zh-hans/contributing/contributing-docs/">https://docs.dapr.io/zh-hans/contributing/contributing-docs/</a></p><p>dapr 文档网站使用hugo 开发工具：</p><p>Windows：安装流程<br>安装scoope<br>powerSheel ：执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br><span class="line"></span><br><span class="line">iex (new-object net.webclient).downloadstring(&#39;https:&#x2F;&#x2F;get.scoop.sh&#39;)</span><br><span class="line"></span><br><span class="line">执行scoope help 查看是否安装正常</span><br><span class="line"></span><br><span class="line">执行   scoop install hugo</span><br><span class="line">      scoop install hugo-extended</span><br><span class="line">这两部即可 完成对其安装</span><br><span class="line"></span><br><span class="line">文档：https:&#x2F;&#x2F;gohugo.io&#x2F;getting-started&#x2F;installing&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="1执行doc仓库下载和安装依赖">1.执行doc仓库下载和安装依赖</span></h3><p>仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com.cnpmjs.org&#x2F;dapr&#x2F;docs.git</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">这步可能遇到下载不下来情况，可以按照此步骤进行操作</span><br><span class="line"></span><br><span class="line">1.执行 git submodule update --init</span><br><span class="line">2.去.gitmodules文件 进行编辑将所有的https:&#x2F;&#x2F;github.com  后缀加上 cnpmjs.org</span><br><span class="line">(这个原理可以参考:谷歌插件---GitHub加速1.3.5)</span><br><span class="line">3.然后利用git submodule sync更新子项目对应的url</span><br><span class="line">4.git submodule update --init --recursive，最后执行</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;s2-cdn.oneitfarm.com&#x2F;6d3518411d074f9eae604f77da39da83.png</span><br></pre></td></tr></table></figure><p><img src="//s2-cdn.oneitfarm.com/a23f2220daff4375ba97522c7edc552c.png" alt></p><p>错误1.</p><p><img src="//s2-cdn.oneitfarm.com/c036d24abc364f00be0870faec874818.png" alt="image-20220316151455745"></p><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用git代理：</span><br><span class="line">git config *--global https.proxy*</span><br><span class="line">执行命令后取消代理</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>错误2：</p><p><img src="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png" alt="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png"></p><p>解决方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是因为没有执行git module的 下载</span><br></pre></td></tr></table></figure><h3><span id="2安装依赖">2.安装依赖</span></h3><p>此项目使用的还是npm </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="dapr" scheme="https://smartxia.github.io/blog/categories/dapr/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc-2</title>
    <link href="https://smartxia.github.io/blog/2021/12/09/GOLANG/GOLANG-grpc-2/"/>
    <id>https://smartxia.github.io/blog/2021/12/09/GOLANG/GOLANG-grpc-2/</id>
    <published>2021-12-09T07:05:54.000Z</published>
    <updated>2021-12-09T07:11:34.656Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>脑图：</p><p><a href="https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5">https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5</a></p><p>服务端的操作：</p><p>取出server</p><p>挂载方法</p><p>注册服务</p><p>创建监听</p><p>客户端：</p><p>创建链接</p><p>new 一个client</p><p>调用client方法</p><p>获取返回值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>x86和arm架构区别</title>
    <link href="https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-12-02T08:22:44.000Z</published>
    <updated>2021-12-09T07:04:57.353Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是arm架构">什么是arm架构</span></h3><p>ARM架构过去称之为进阶精简指令集机器，是一个32位的精简指令集（RISC）处理器架构，其广泛的使用在嵌入式系统设计，由于节能的特点，ARM非常适合处理移动通讯领域，符合其设计目标低消耗 电量的特性，在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.</p><p>arm架构图</p><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据/地址寄存器组成.</p><p><img src="http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg" alt></p><p>1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</p><p>2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移/右移n位、环移n位和算术右移n位等都可以一次完成。</p><p>3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1/3）。</p><p>4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</p><p>5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</p><p>6、寄存器</p><h2><span id="x86架构"><strong>x86架构</strong></span></h2><p><img src="http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg" alt></p><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><p>   1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</p><p>　2： 北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</p><p>　3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I/O总线较多，离处理器远一点有利于布线。</p><p>　4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p><p>　5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</p><p>　6：显示j接口</p><p>　7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>　8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</p><p>　9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</p><p>　10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</p><p>　11：总线</p><h2><span id="arm架构和x86架构有什么区别"><strong>arm架构和x86架构有什么区别</strong></span></h2><p><strong>一、性能</strong> </p><p>​    X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。</p><p>　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.</p><p><strong>二、扩展能力</strong></p><p>​    X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.</p><p>　　ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.</p><p> <strong>三、操作系统的兼容性</strong></p><p>​    X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。</p><p>　　ARM系统几乎都采用<strong>Linux</strong>的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的<strong>Android</strong>系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.</p><p><strong>四、软件开发的方便性及可使用工具的多样性</strong></p><p>​    X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。</p><p>　　Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。</p><p>　　对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。</p><p>　　从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：<strong>功耗.</strong></p><p><strong>五、功耗</strong> </p><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>HTTP 请求方法之CONNECT method</title>
    <link href="https://smartxia.github.io/blog/2021/11/25/HTTP/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/"/>
    <id>https://smartxia.github.io/blog/2021/11/25/HTTP/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/</id>
    <published>2021-11-25T01:36:06.000Z</published>
    <updated>2021-12-02T08:21:37.983Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>HTTP1.1 中的connect<br>1.http请求代理就是connect这个方法，connect网页开发中不会使用<br>2.connect的作用将服务器作为代理，让服务器提用户访问其他网页（翻墙），之后将数据返回用户<br>3.connect是将通过TCP代理链接服务器的，假如我想让代理服务器访问，<a href="https://baidu.com网站，首先要简历一条客户端到代理服务器的tcp的链接">https://baidu.com网站，首先要简历一条客户端到代理服务器的tcp的链接</a><br>然后给代理服务器发送一个http报文</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECT https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;f67233ce6c0c:80 HTTP&#x2F;1.1</span><br><span class="line">Host: www.web-tinker.com:80</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Proxy-Authorization: Basic *</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>在发送完这个请求之后，代理服务器会响应请求，返回一个200的信息，但这个200并不同于我们平时见到的OK，而是Connection Established</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://smartxia.github.io/blog/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>弱势文化</title>
    <link href="https://smartxia.github.io/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/"/>
    <id>https://smartxia.github.io/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/</id>
    <published>2021-11-22T05:37:08.000Z</published>
    <updated>2021-11-22T06:38:09.164Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="https://pic1.zhimg.com/v2-bb213c477bc9d02350862acc72395838_720w.jpg?source=3af55fa1" alt="preview"></p><p>知识的快餐：我们为什么要懂点哲学<br>什么是哲学，哲学可不可以理解成为人的认知的差异，哲学里的文化属性到底代表着什么</p><blockquote><p>闲暇产生思辨，思辨消解教条主义和陈腐习俗，发展出敏锐的感知，让人丧失行动的决断。</p><p>思想，在分析迷宫冒险前行，发现社会背后的个体，玻璃其正常的社会功能，转向内在，发现自我</p><p>共同的利益，和共同体的意识衰退，如今没有公民只有个人</p><p>个体通过思索意识到自己本身就是生存的目的，他要求国际从此以往加强而不是利用他的能力，以此为代价，个人将维持国家的持续</p></blockquote><p><strong>社会经济的发展带来的我们物质和生活的增长，被冠以着数十年来通过个体努力的结果，于是国家造就了弱势文化的典型思想:误以为将自己的生活水平的提高，是通过自己勤劳获取的，殊不知这是吃着国家的红利，而并非自己真的可以通过真正的努力获取的温饱</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-GPM的深入理解</title>
    <link href="https://smartxia.github.io/blog/2021/11/18/GOLANG/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>https://smartxia.github.io/blog/2021/11/18/GOLANG/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-11-18T02:08:03.000Z</published>
    <updated>2021-12-09T11:10:51.192Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>深入golang runtime的调度</p><h3><span id="理解调度器的启动">理解调度器的启动</span></h3><p>runtime：</p><p>scheduler:</p><p>TLS:</p><p>spinning:</p><p>systemstack,mcall,asmcgocall</p><p>主要源码文件:</p><p>调度基本组件：</p><p><strong>G(goroutine)</strong>：调度器的基本单位，存储的goroutine的执行stack信息，状态以及任务函数</p><p>在g的眼中只有p,p就是运行的G的“CPU”</p><p>相当于两级线程</p><blockquote><p>g的任务函数</p></blockquote><p>每个g的实例都有任务函数，如下代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userFun:&#x3D;func()&#123;fmt.Println(&quot;111&quot;)&#125;</span><br><span class="line">go userFunc();</span><br></pre></td></tr></table></figure><p>go的关键词创建了一个goroutine,此时gouroutine的任务函数userFun</p><p><strong>P（processor）</strong></p><p>p表示逻辑processor，代表M执行的上下文</p><p>p的最大作用是拥有各种G的对象队列，链表，cache,和状态</p><p>p的数量也代表go的执行并发度，即多少个goroutine可以同时执行</p><p>这里的p虽然表示逻辑处理器，但是p并不代表任何执行代码，对于g来说，p相当于cpu的核，g只有绑定p才能调度。对于M来说，p提供了执行环境（Context），如分配内存状态（mcache）,任务队列G等</p><p><strong>M(machine)</strong></p><p>M代表真正的执行计算资源，可以任务他就是os thread(系统线程)</p><p>M是真正的执行者，每个M就像一个勤劳的工作者，总是从各种队列找到可运行的G,而且这样的M的可以同时存在多个</p><p>M在绑定有效P，可以进行调度循环，而且M并不保留G状态，这个是g可以跨M调度的基础</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-纯纯的语法仔的没落</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/</id>
    <published>2021-11-17T03:57:39.000Z</published>
    <updated>2021-11-18T09:58:21.894Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="基础">基础</span></h2><h3><span id="1-对于已经关闭的channel的处理">1. 对于已经关闭的channel的处理</span></h3><p>读已经关闭的channel，一直能读到东西，但是读到的东西根据通道内关闭前是否有元素而不同，</p><ul><li>关闭前，buffer有还未读取的，会读取到chan内的值，且返回是否读取成功的bool值为true</li><li>关闭前，buffer的值读完，channel元素值为0，bool值为false</li></ul><p>写入：直接panic</p><h3><span id="2-make和new区别">2. Make和new区别</span></h3><p>make：返回特定类型channel，slice,map</p><p>new: 开辟新内存和指针，泛化类型</p><h3><span id="3-nil-切片和空切片一不一样">3. nil 切片和空切片一不一样</span></h3><p>指向的地址不一样。nill引用指针地址为0，空切片执行数组指针地址，且为一个固定值</p><p>数据结构：data,len,cap</p><h3><span id="4-字符串转byte数组会发生内存拷贝吗">4. 字符串转byte数组，会发生内存拷贝吗</span></h3><p>严格来说，只要发生类型强转，都会发生内存拷贝。</p><p>那么go有个很强的包叫 <code>unsafe</code> 。先获取变量地址，字符串转成底层结构，通过unsafe包，转为切片数组,再通过指针指向实际内容</p><p>string 数据结构 {data,len} </p><h3><span id="5-json包变量不加tag会怎么样">5. json包变量不加tag会怎么样</span></h3><p>和key的大小写有关</p><h3><span id="6-gpm">6. GPM</span></h3><p>指向另一篇详细（）</p><h3><span id="7docker-的网络通信模式">7.Docker 的网络通信模式。</span></h3><p>四种：</p><p>1.host模式：和宿主机公用一个network NameSpace 。容器不会配置任何自己网卡，而是使用自己宿主机的IP和端口</p><p>2.container模式：指定和其他容器共享network nameSpace,而不是和宿主机共享</p><p>3.none模式：告诉容器放到自己网站堆里，但是不要配置他的网络</p><p>4.brideg模式：docker默认的网络模式，此模式会将主机docker链接到虚拟网桥上</p><h3><span id="8访问私有成员">8.访问私有成员</span></h3><blockquote><p>调用其他包共有结构的私有成员变<strong>量</strong></p></blockquote><p><strong>绕过小写不公开</strong></p><p>用unsafe包中的unsafe.Pointer获取到结构体对象的首地址，然后加上想访问的私有变量的偏移地址就是私有变量的地址</p><h3><span id="9-数组和切片的区别">9、数组和切片的区别</span></h3><p>长度，容量，数组指针</p><p>切片是指针类型，数组是是值类型</p><p>数据长度固定，切片不固定</p><p>切片比数组多个属性（cap）,切片底层是数组</p><ul><li>扩容：小于1024 每次cap翻倍，超过变成1.25</li><li>扩容后没触及原数组容量，那么切片指针指向的位置，还是原数组，扩容后，超过原数组容量，会开辟一块新内存，原来的值拷贝过来，也不会影响原来数组</li><li>append:</li></ul><h3><span id="10介绍-rune-类型">10.介绍 rune 类型</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var str &#x3D; &quot;hello 你好&quot;</span><br><span class="line">    fmt.Println(&quot;len(str):&quot;, len(str))</span><br><span class="line">    &#x2F;&#x2F;12个 </span><br><span class="line">    &#x2F;&#x2F;中文字符在unicode下占2个字节，在utf-8编码下占3个字节 go默认utf-8 5+1+3*2</span><br><span class="line">    &#x2F;&#x2F;通过rune类型处理unicode字符</span><br><span class="line">    fmt.Println(&quot;rune:&quot;, len([]rune(str))) &#x2F;&#x2F;8个</span><br><span class="line">    fmt.Println(&quot;RuneCountInString:&quot;, utf8.RuneCountInString(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>byte等同于uint8，而不是int8</p><p>rune 等同于int32,常用来处理unicode或utf-8字符</p><h3><span id="11-panic-defer-recover">11 panic defer recover</span></h3><p>panic() 函数</p><p>函数中遇到panic语句，会立即终止当前函数的执行，在panic所在函数内如果存在要执行的defer函数列表，按照defer的逆序执行</p><p>recover() 函数</p><p>recover函数的返回值报告协程是否正在遭遇panic</p><p>有异常时，recover()只能调用一次，后面再次调用则捕获不到任何异常</p><p>通常办法：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理，从而恢复正常代码的执行</p><h3><span id="12-读写锁和互斥锁">12 读写锁和互斥锁</span></h3><p>总结：</p><ol><li>1.在单纯的只是获取锁和释放锁时，互斥锁的用时要少一些，这主要是因为多个线程同时获取读写锁的情况比较少出现。</li><li>golang底层实现上，互斥锁确实要比读写锁的性能要好一些，这主要是因为读写锁的底层实现其实是互斥锁加上计数器</li><li>在 增 强 协 程 互 相 冲 突 的 效 果 后 ， 读 写 锁 的 性 能 要 明 显 高 于 互 斥 锁 </li></ol><h3><span id="13结构体是否可以比较">13.结构体是否可以比较</span></h3><p>回到上面的划重点部分，在总结中我们可以知道，golang中 <em>Slice<em>，</em>Map<em>，</em>Function</em> 这三种数据类型是不可以直接比较的。我们再看看S结构体，该结构体并没有包含不可比较的成员变量，所以该结构体是可以直接比较的。</p><p> <em>reflect.DeepEqual 函数</em> 来对两个变量进行比较。</p><h3><span id="14golang-channel是线程安全的吗">14.golang channel是线程安全的吗</span></h3><p>如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的。不需要在并发读写同一个channe时加锁。</p><h3><span id="15channel数据结构">15.channel数据结构</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="keyword">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="keyword">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="keyword">uint16</span></span><br><span class="line">    closed   <span class="keyword">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="keyword">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="keyword">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-grpc/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-grpc/</id>
    <published>2021-11-17T02:28:40.000Z</published>
    <updated>2021-11-17T03:57:26.598Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>grpc 官网：<a href="https://grpc.io/docs/languages/go/basics/">https://grpc.io/docs/languages/go/basics/</a> 中文翻译版本：<a href="http://doc.oschina.net/grpc?t=56831">http://doc.oschina.net/grpc?t=56831</a></p></blockquote><p>1、下载protobuf的编译器protoc</p><p>地址：</p><p>1、<code>https://github.com/google/protobuf/releases</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window：</span><br><span class="line">  下载: protoc-3.3.0-win32.zip</span><br><span class="line">  解压，把bin目录下的protoc.exe复制到GOPATH&#x2F;bin下，GOPATH&#x2F;bin加入环境变量。</span><br><span class="line">当然也可放在其他目录，需加入环境变量，能让系统找到protoc.exe</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">    下载：protoc-3.3.0-linux-x86_64.zip 或 protoc-3.3.0-linux-x86_32.zip</span><br><span class="line">解压，把bin目录下的protoc复制到GOPATH&#x2F;bin下，GOPATH&#x2F;bin加入环境变量。</span><br><span class="line">如果喜欢编译安装的，也可下载源码自行安装，最后将可执行文件加入环境变量。</span><br></pre></td></tr></table></figure><p>2、获取protobuf的编译器插件<code>protoc-gen-go</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  进入GOPATH目录</span><br><span class="line">  运行</span><br><span class="line">&gt; go get -u github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br><span class="line">  如果成功，会在GOPATH&#x2F;bin下生成protoc-gen-go.exe文件</span><br></pre></td></tr></table></figure><p>3、创建一个<code>test.proto</code>文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;指定版本</span><br><span class="line">&#x2F;&#x2F;注意proto3与proto2的写法有些不同</span><br><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;包名，通过protoc生成时go文件时</span><br><span class="line">package test;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;手机类型</span><br><span class="line">&#x2F;&#x2F;枚举类型第一个字段必须为0</span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    HOME &#x3D; 0;</span><br><span class="line">    WORK &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;手机</span><br><span class="line">message Phone &#123;</span><br><span class="line">    PhoneType type &#x3D; 1;</span><br><span class="line">    string number &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;人</span><br><span class="line">message Person &#123;</span><br><span class="line">    &#x2F;&#x2F;后面的数字表示标识号</span><br><span class="line">    int32 id &#x3D; 1;</span><br><span class="line">    string name &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F;repeated表示可重复</span><br><span class="line">    &#x2F;&#x2F;可以有多个手机</span><br><span class="line">    repeated Phone phones &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;联系簿</span><br><span class="line">message ContactBook &#123;</span><br><span class="line">    repeated Person persons &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行如下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; protoc --go_out&#x3D;. *.proto</span><br><span class="line">会生成一个test.pb.go的文件，具体的文件内容我就不截图了。</span><br></pre></td></tr></table></figure><p>5、在go语言中使用protobuf</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;github.com&#x2F;golang&#x2F;protobuf&#x2F;proto&quot;</span><br><span class="line">    &quot;protobuf&#x2F;test&quot;</span><br><span class="line">    &quot;io&#x2F;ioutil&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func write() &#123;</span><br><span class="line">    p1 :&#x3D; &amp;test.Person&#123;</span><br><span class="line">        Id:   1,</span><br><span class="line">        Name: &quot;小张&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;111111111&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;222222222&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    p2 :&#x3D; &amp;test.Person&#123;</span><br><span class="line">        Id:   2,</span><br><span class="line">        Name: &quot;小王&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;333333333&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;444444444&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;创建地址簿</span><br><span class="line">    book :&#x3D; &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    book.Persons &#x3D; append(book.Persons, p1);</span><br><span class="line">    book.Persons &#x3D; append(book.Persons, p2);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;编码数据</span><br><span class="line">    data, _ :&#x3D; proto.Marshal(book);</span><br><span class="line">    &#x2F;&#x2F;把数据写入文件</span><br><span class="line">    ioutil.WriteFile(&quot;.&#x2F;test.txt&quot;, data, os.ModePerm);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func read() &#123;</span><br><span class="line">    &#x2F;&#x2F;读取文件数据</span><br><span class="line">    data, _ :&#x3D; ioutil.ReadFile(&quot;.&#x2F;test.txt&quot;);</span><br><span class="line">    book :&#x3D; &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    &#x2F;&#x2F;解码数据</span><br><span class="line">    proto.Unmarshal(data, book);</span><br><span class="line">    for _, v :&#x3D; range book.Persons &#123;</span><br><span class="line">        fmt.Println(v.Id, v.Name);</span><br><span class="line">        for _, vv :&#x3D; range v.Phones &#123;</span><br><span class="line">            fmt.Println(vv.Type, vv.Number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    write();</span><br><span class="line">    read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5367714-2eb580ad8e2e7a93.png" alt="img"></p><p>image.png</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;go:generate protoc -I ..&#x2F;routeguide --go_out&#x3D;plugins&#x3D;grpc:..&#x2F;routeguide ..&#x2F;routeguide&#x2F;route_guide.proto protoc</span><br></pre></td></tr></table></figure><p><code>-I</code> 参数：指定import路径，可以指定多个-I参数，编译时按顺序查找，不指定时默认查找当前目录</p><p><code>--go_out</code> ：golang编译支持，支持以下参数<br>plugins=plugin1+plugin2 - 指定插件，目前只支持grpc，即：plugins=grpc</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>PHP-析构函数-destruct</title>
    <link href="https://smartxia.github.io/blog/2021/11/16/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
    <id>https://smartxia.github.io/blog/2021/11/16/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</id>
    <published>2021-11-16T03:33:44.698Z</published>
    <updated>2021-11-16T03:33:44.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3><span id="析构函数destruct">析构函数destruct</span></h3><p><img src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：<strong>construct()在初始化对象的时候默认执行的<br>析构函数：</strong>destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data &#x3D; [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#39;appkey&#39;] &#x3D; getAppkey();</span><br><span class="line">        $data[&#39;channel&#39;] &#x3D; getChannel();</span><br><span class="line">        $this-&gt;data[] &#x3D; $data;</span><br><span class="line">        &#x2F;&#x2F;这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id &#x3D; $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#39;id &lt;&#39; &#x3D;&gt; $id - 50000</span><br><span class="line">            ], &#39;&#39;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend&#x3D;new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="php" scheme="https://smartxia.github.io/blog/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2021/11/16/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
    <id>https://smartxia.github.io/blog/2021/11/16/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</id>
    <published>2021-11-16T03:33:44.686Z</published>
    <updated>2021-11-16T10:01:25.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. :&#x3D; &#x3D; &#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">:&#x3D; 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">&#x3D; 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 :&#x3D; make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val :&#x3D; make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">ch :&#x3D; make(chan int, 100) &#x2F;&#x2F; make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据</span><br><span class="line">&#x2F;&#x2F; 并把值赋给 v</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>golang Context上下文</title>
    <link href="https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://smartxia.github.io/blog/2021/11/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2021-11-15T10:56:27.000Z</published>
    <updated>2021-11-16T10:01:25.929Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>数据四层七层</title>
    <link href="https://smartxia.github.io/blog/2021/11/10/REDIS/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/"/>
    <id>https://smartxia.github.io/blog/2021/11/10/REDIS/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/</id>
    <published>2021-11-10T07:08:25.000Z</published>
    <updated>2021-11-16T03:33:44.703Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="reids" scheme="https://smartxia.github.io/blog/categories/reids/"/>
    
    
  </entry>
  
  <entry>
    <title>golang里的进程线程携程的调度方式</title>
    <link href="https://smartxia.github.io/blog/2021/10/10/GOLANG/golang%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/"/>
    <id>https://smartxia.github.io/blog/2021/10/10/GOLANG/golang%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-10T10:56:27.000Z</published>
    <updated>2021-11-17T04:00:59.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>找工作本来想靠实力和经验，奈何仍需背面试题，刷算法，可以说是可恶了<br>作者：腾讯技术工程<br>链接：<a href="https://www.zhihu.com/question/20862617/answer/921061289">https://www.zhihu.com/question/20862617/answer/921061289</a><br>来源：知乎</p><h2><span id="goroutine-实现">goroutine 实现:</span></h2><p><img src="https://pic1.zhimg.com/50/v2-5f7f337c089077babfbe296e8a82c88a_720w.jpg?source=1940ef5c" alt="img"></p><p>我们去看调度的一个进化, 从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程. go 实现的协程为有栈协程, go 协程的用法和线程的用法基本类似. 很多人会疑问, 协程到底是个什么东西? 用户态的调度感觉很陌生, 很抽象, 到底是个什么东西?</p><p>我觉得要理解调度, 要理解两个概念: 运行和阻塞. 特别是在协程中, 这两个概念不容易被正确理解. 我们理解概念时往往会代入自身感受, 觉得线程或协程运行就是像我们吭哧吭哧的处理事情, 线程或协程阻塞就是做事情时我们需要等待其他人. 然后就在这等着了. 要是其他人搞好了, 那我们就继续做当前的事.</p><p>其实主体对象搞错了.正确的理解应该是我们处理事情时就像 CPU, 而不是像线程或者协程. 假如我当前在写某个服务, 发现依赖别人的函数还没有 ready, 那就把写服务这件事放一边. 点开企业微信, 我去和产品沟通一些问题了. 我和产品沟通了一会后, 检查一下, 发现别人已经把依赖的函数提交了, 然后我就最小化企业微信, 切到 IDE, 继续写服务 A 了.</p><p>对操作系统有过一些了解, 知道 linux 下的线程其实是 task_struct 结构, 线程其实并不是真正运行的实体, 线程只是代表一个执行流和其状态.真正运行驱动流程往前的其实是 CPU. CPU 在时钟的驱动下, 根据 PC 寄存器从程序中取指令和操作数, 从 RAM 中取数据, 进行计算, 处理, 跳转, 驱动执行流往前. CPU 并不关注处理的是线程还是协程, 只需要设置 PC 寄存器, 设置栈指针等(这些称为上下文), 那么 CPU 就可以欢快的运行这个线程或者这个协程了.</p><p>线程的运行, 其实是被运行.其阻塞, 其实是切换出调度队列, 不再去调度执行这个执行流. 其他执行流满足其条件, 便会把被移出调度队列的执行流重新放回调度队列.协程同理, 协程其实也是一个数据结构, 记录了要运行什么函数, 运行到哪里了.<br>go 在用户态实现调度, 所以 go 要有代表协程这种执行流的结构体, 也要有保存和恢复上下文的函数, 运行队列. 理解了阻塞的真正含义, 也就知道能够比较容易理解, 为什么 go 的锁, channel 这些不阻塞线程.</p><p>对于实现的同步执行流效果, 又不阻塞线程的网络, 接下来也会介绍.</p><h3><span id="协程结构体和切换函数"><strong>协程结构体和切换函数</strong></span></h3><p><img src="https://pic1.zhimg.com/50/v2-85a56b6e215d2b427ac4f5252ce3c619_720w.jpg?source=1940ef5c" alt="img"></p><p>我们 go 一个 func 时一般这样写</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func1(arg1 type1,arg2 type2)&#123;....&#125;(a1,a2)</span><br></pre></td></tr></table></figure><p>一个协程代表了一个执行流, 执行流有需要执行的函数(对应上面的 func1), 有函数的入参(a1, a2), 有当前执行流的状态和进度(对应 CPU 的 PC 寄存器和 SP 寄存器), 当然也需要有保存状态的地方, 用于执行流恢复.</p><p>真正代表协程的是 runtime.g 结构体. 每个 go func 都会编译成 runtime.newproc 函数, 最终有一个 runtime.g 对象放入调度队列. 上面的 func1 函数的指针设置在 runtime.g 的 startfunc 字段, 参数会在 newproc 函数里拷贝到 stack 中, sched 用于保存协程切换时的 pc 位置和栈位置.</p><p>协程切换出去和恢复回来需要保存上下文, 恢复上下文, 这些由以下两个汇编函数实现. 以上就能实现协程这种执行流, 并能进行切换和恢复.(下图中的 struct 和函数都做了精简)</p><h3><span id="gm-模型及-gpm-模型"><strong>GM 模型及 GPM 模型</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-836e26770ed9489f835605529e608c37_720w.jpg?source=1940ef5c" alt="img"></p><p>有了协程的这种执行流形式, 那待运行的协程放在哪呢?<br>在 Go1.0 的时候:</p><ol><li>调度队列 schedt 是全局的, 对该队列的操作均需要竞争同一把锁, 导致伸缩性不好.</li><li>新生成的协程也会放入全局的队列, 大概率是被其他 m(可以理解为底层线程的一个表示)运行了, 内存亲和性不好. 当前协程 A 新生成了协程 B, 然后协程 A 比较大概率会结束或者阻塞, 这样 m 直接去执行协程 B, 内存的亲和性也会好很多.</li><li>因为 mcache 与 m 绑定, 在一些应用中(比如文件操作或其他可能会阻塞线程的系统调用比较多), m 的个数可能会远超过活跃的 m 个数, 导致比较大的内存浪费.</li></ol><p>那是不是可以给 m 分配一个队列, 把阻塞的 m 的 mcache 给执行 go 代码的 m 使用? Go 1.1 及以后就是这样做的.</p><p><img src="https://pic1.zhimg.com/50/v2-a06db1f245421b17c64d7bc4f338b71e_720w.jpg?source=1940ef5c" alt="img"></p><p>再 1.1 中调度模型更改为 GPM 模型, 引入逻辑 Process 的概念, 表示执行 Go 代码所需要的资源, 同时也是执行 Go 代码的最大的并行度.</p><p>这个概念可能很多人不知道怎么理解. P 涉及到几点, 队列和 mcache, 还有 P 的个数的选取.</p><p>首先为什么把全局队列打散, 以及 mcache 为什么跟随 P, 这个在 GM 模型那一页就讲的比较清楚了.然后为什么 P 的个数默认是 CPU 核数: Go 尽量提升性能, 那么在一个 n 核机器上, 如何能够最大利用 CPU 性能呢? 当然是同时有 n 个线程在并行运行中, 把 CPU 喂饱, 即所有核上一直都有代码在运行.</p><p>在 go 里面, 一个协程运行到阻塞系统调用, 那么这个协程和运行它的线程 m, 自然是不再需要 CPU 的, 也不需要分配 go 层面的内存. 只有一直在并行运行的 go 代码才需要这些资源, 即同时有 n 个 go 协程在并行执行, 那么就能最大的利用 CPU, 这个时候需要的 P 的个数就是 CPU 核数. (注意并行和并发的区别)</p><h2><span id="协程状态及流转"><strong>协程状态及流转</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-95c62d2ff20b8a75e0ec2eddddaf4bd2_720w.jpg?source=1940ef5c" alt="img"></p><p>协程的状态其实和线程状态类似,状态转换和发生状态转换的时机如图所示. 还是需要注意: 协程只是一个执行流, 并不是运行实体.</p><h2><span id="调度"><strong>调度</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-0328b09cc3dd5537bd463e10ef17db6e_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有一个一直在运行调度的调度器实体. 当一个协程切换出去或新生成的 m, go 的运行时从 stw 中恢复等情况时, 那么接下来就需要发生调度. go 的调度是通过线程(m)执行 runtime.schedule 函数来完成的.</p><h2><span id="sysmon-协程"><strong>sysmon 协程</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-28f751cb1c56fcc275bc545d7f82d869_720w.jpg?source=1940ef5c" alt="img"></p><p>在 linux 内核中有一些执行定时任务的线程, 比如定时写回脏页的 pdflush, 定期回收内存的 kswapd0, 以及每个 cpu 上都有一个负责负载均衡的 migration 线程等.在 go 运行时中也有类似的协程, sysmon.功能比较多: 定时从 netpoll 中获取 ready 的协程, 进行抢占, 定时 GC,打印调度信息,归还内存等定时任务.</p><h2><span id="协作式抢占"><strong>协作式抢占</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-d8baadb9a783032443d3d2fd6b0b5227_720w.jpg?source=1940ef5c" alt="img"></p><p>go 目前(1.12)还没有实现非协作的抢占. 基本流程是 sysmon 协程标记某个协程运行过久, 需要切换出去, 该协程在运行函数时会检查栈标记, 然后进行切换.</p><h2><span id="同步执行流不阻塞线程的网络的实现"><strong>同步执行流不阻塞线程的网络的实现</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-7bed4181eb6bbcba7be4a6b43a604c3e_720w.jpg?source=1940ef5c" alt="img"></p><p>go 写后台最舒服的就是能够以同步写代码的方式操作网络, 但是网络操作不阻塞线程.主要是结合了非阻塞的 fd, epoll 以及协程的切换和恢复.linux 提供了网络 fd 的非阻塞模式, 对于没有 ready 的非阻塞 fd 执行网络操作时, linux 内核不阻塞线程, 会直接返回 EAGAIN, 这个时候将协程状态设置为 wait, 然后 m 去调度其他协程.</p><p>go 在初始化一个网络 fd 的时候, 就会把这个 fd 使用 epollctl 加入到全局的 epoll 节点中. 同时放入 epoll 中的还有 polldesc 的指针.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func netpollopen(fd uintptr, pd *pollDesc) int32 &#123;</span><br><span class="line">    var ev epollevent</span><br><span class="line">    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sysmon 中, schedule 函数中, start the world 中等情况下, 会执行 netpoll 调用 epollwait 系统调用, 把 ready 的网络事件从 epoll 中取出来, 每个网络事件可以通过前面传入的 polldesc 获取到阻塞在其上的协程, 以此恢复协程为 runnable.</p><h2><span id="调度相关结构体"><strong>调度相关结构体</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-85359486219d4ce31b93fa450b592083_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="调度综述"><strong>调度综述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7f7ea37737a8e4ac2809a8122ba62c1c_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic1.zhimg.com/50/v2-8d5f447993ab105b88eac9fb827b2a3c_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="内存分配"><strong>内存分配</strong></span></h2><h2><span id="内存分配简介"><strong>内存分配简介</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-eb6d4ba5968ebe8a0a86318c2ef35ca6_720w.jpg?source=1940ef5c" alt="img"></p><p>Go 的分配采用了类似 tcmalloc 的结构.特点: 使用一小块一小块的连续内存页, 进行分配某个范围大小的内存需求. 比如某个连续 8KB 专门用于分配 17-24 字节,以此减少内存碎片. 线程拥有一定的 cache, 可用于无锁分配.</p><p>同时 Go 对于 GC 后回收的内存页, 并不是马上归还给操作系统, 而是会延迟归还, 用于满足未来的内存需求.</p><h2><span id="内存空间结构"><strong>内存空间结构</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-c1b2977bf1d33669bb9c2774c7b6d8d8_720w.jpg?source=1940ef5c" alt="img"></p><p>在 1.10 以前 go 的堆地址空间是线性连续扩展的, 比如在 1.10(linux amd64)中, 最大可扩展到 512GB. 因为 go 在 gc 的时候会根据拿到的指针地址来判断是否位于 go 的 heap 的, 以及找到其对应的 span, 其判断机制需要 gc heap 是连续的. 但是连续扩展有个问题, cgo 中的代码(尤其是 32 位系统上)可能会占用未来会用于 go heap 的内存. 这样在扩展 go heap 时, mmap 出现不连续的地址, 导致运行时 throw.</p><p>在 1.11 中, 改用了稀疏索引的方式来管理整体的内存. 可以超过 512G 内存, 也可以允许内存空间扩展时不连续.在全局的 mheap struct 中有个 arenas 二阶数组, 在 linux amd64 上,一阶只有一个 slot, 二阶有 4M 个 slot, 每个 slot 指向一个 heapArena 结构, 每个 heapArena 结构可以管理 64M 内存, 所以在新的版本中, go 可以管理 4M*64M=256TB 内存, 即目前 64 位机器中 48bit 的寻址总线全部 256TB 内存.</p><h2><span id="span-机制"><strong>span 机制</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-84e72feda2d2cd49aaad59bb6f72837c_720w.jpg?source=1940ef5c" alt="img"></p><p>前面提到了 go 的内存分配类似于 tcmalloc, 采用了 span 机制来减少内存碎片. 每个 span 管理 8KB 整数倍的内存, 用于分配一定范围的内存需求.</p><h2><span id="内存分配全景"><strong>内存分配全景</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-11756712c78ee841873eb9aa22198f3c_720w.jpg?source=1940ef5c" alt="img"></p><p>多层次的分配 Cache, 每个 P 上有一个 mcache, mcache 会为每个 size 最多缓存一个 span, 用于无锁分配. 全局每个 size 的 span 都有一个 mcentral, 锁的粒度相对于全局的 heap 小很多, 每个 mcentral 可以看成是每个 size 的 span 的一个全局后备 cache.</p><p>在 gc 完成后, 会把 P 中的 span 都 flush 到 mcentral 中, 用于清扫后再分配. P 有需要 span 时, 从对应 size 的 mcentral 获取. 获取不到再上升到全局的 heap.</p><h2><span id="几种特殊的分配器"><strong>几种特殊的分配器</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-e35ffea692133cbe86898cdf3eb55352_720w.jpg?source=1940ef5c" alt="img"></p><p>对于很小的对象分配, go 做了个优化, 把小对象合并, 以移动指针的方式分配.对于栈内存有 stackcache 分配, 也有多个层次的分配, 同时 stack 也有多个不同 size. 用于分配 stack 的内存也是位于 go gc heap, 用 mspan 管理, 不过这个 span 的状态和用于分配对象的 mspan 状态不太一样, 为 mSpanManual.</p><p>我们可以思考一个问题, go 的对象是分配在 go gc heap 中, 并由 mcache, mspan, mcentral 这些结构管理, 那么 mcache, mspan, mcentral 这些结构又是哪里管理和分配的呢? 肯定不是自己管理自己. 这些都是由特殊的分配 fixalloc 分配的, 每种类型有一个 fixalloc, 大致原理就是通过 mmap 从进程空间获取一小块内存(百 KB 的样子), 然后用来分配这个固定大小的结构.</p><h2><span id="内存分配综合"><strong>内存分配综合</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-1a3d04db061c92d10bed0e5ab0df1c16_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc"><strong>GC</strong></span></h2><h2><span id="golang-gc-简述"><strong>Golang GC 简述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7eb346f748153072b454b9b78759e067_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc-简介"><strong>GC 简介</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-ecebbf99b365d076f7076b31a30fc3e8_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 并不是个新事物, 使得 GC 大放光彩的是 Java 语言.</p><p><img src="https://pica.zhimg.com/50/v2-05266f76d410fe9d90fd1dbd23570953_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic3.zhimg.com/50/v2-291b501f005c3958111daf30bcec1a2b_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="golang-gc-发展"><strong>Golang GC 发展</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-558037836bb253c0777a4a822516d27e_720w.jpg?source=1940ef5c" alt="img"></p><p>上面是几个比较重要的版本.左图是根据 twitter 工程师的数据绘制的(堆比较大), 从 1.4 的百 ms 级别的停顿到 1.8 以后的小于 1ms.右图是我对线上服务(Go 1.11 编译)测试的一个结果, 是一个批量拉取数据的服务, 大概 3000qps, 服务中发起的 rpc 调用大概在 2w/s. 可以看到大部分情况下 GC 停顿小于 1ms, 偶尔超过一点点.</p><p>整体来说 golang gc 用起来是很舒心的, 几乎不用你关心.</p><h2><span id="三色标记"><strong>三色标记</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-652acc8ca5d0f04c455c68d1084cd309_720w.jpg?source=1940ef5c" alt="img"></p><p>go 采用的是并发三色标记清除法. 图展示的是一个简单的原理.有几个问题可以思考一下:</p><ul><li>并发情况下, 会不会漏标记对象?</li><li>对象的三色状态存放在哪?</li><li>如何根据一个对象来找到它引用的对象?</li></ul><h3><span id="写屏障"><strong>写屏障</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-8c43a67a0eba214a81f56c873504c884_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 最基本的就是正确性: 不漏标记对象, 程序还在用的对象都被清除了, 那程序就错误了. 有一点浮动垃圾是允许的.<br>在并发情况下, 如果没有一些措施来保障, 那可能会有什么问题呢?</p><p>看左边的代码和图示, 第 2 步标记完 A 对象, A 又没有引用对象, 那 A 变成黑色对象. 在第 3 步的时候, muator(程序)运行, 把对象 C 从 B 转到了 A, 第 4 步, GC 继续标记, 扫描 B, 此时 B 没有引用对象, 变成了黑色对象. 我们会发现 C 对象被漏标记了.</p><p>如何解决这个问题? go 使用了写屏障, 这里的写屏障是指由编译器生成的一小段代码. 在 gc 时对指针操作前执行的一小段代码, 和 CPU 中维护内存一致性的写屏障不太一样哈.所以有了写屏障后, 第 3 步, A.obj=C 时, 会把 C 加入写屏障 buf. 最终还是会被扫描的.</p><p><img src="https://pic3.zhimg.com/50/v2-69b05d315557f599251e091a0d4a00d9_720w.jpg?source=1940ef5c" alt="img"></p><p>这里感受一下写屏障具体生成的代码. 我们可以看到在写入指针 slot 时, 对写屏障是否开启做了判断, 如果开启了, 会跳转到写屏障函数, 执行加入写屏障 buf 的逻辑. 1.8 中写屏障由 Dijkstra 写屏障改成了混合式写屏障, 使得 GC 停顿达到了 1ms 以下.</p><h3><span id="三色状态"><strong>三色状态</strong></span></h3><p><img src="https://pic2.zhimg.com/50/v2-4dd9c75a72c82eaf3690386dcf286cdb_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有这样一个集合把不同状态对象放到对应集合中. 只是一个逻辑上的意义.</p><h3><span id="扫描和元信息"><strong>扫描和元信息</strong></span></h3><p><img src="https://pica.zhimg.com/50/v2-ee14e9737cbb929bc95ec3af883e5474_720w.jpg?source=1940ef5c" alt="img"></p><p>gc 拿到一个指针, 如何把这个指针指向的对象其引用的子对象都加到扫描队列呢? 而且 go 还允许内部指针, 似乎更麻烦了. 我们分析一下, 要知道对象引用的子对象, 从对象开始到对象结尾, 把对象那一块内存上是指针的放到扫描队列就好了. 那我们是不是得知道对象有多大, 从哪开始到哪结束, 同时要知道内存上的 8 个字节, 哪里是指针, 哪里是普通的数据.</p><p>首先 go 的对象是 mspan 管理的, 我们如果能知道对象属于哪个 mspan, 就知道对象多大, 从哪开始, 到哪结束了. 前面我们讲到了 areans 结构, 可以通过指针加上一定得偏移量, 就知道属于哪个 heap arean 64M 块. 再通过对 64M 求余, 结合 spans 数组, 即可知道属于哪个 mspan 了.</p><p>结合 heapArean 的 bitmap 和每 8 个字节在 heapArean 中的偏移, 就可知道对象每 8 个字节是指针还是普通数据(这里的 bitmap 是在分配对象时根据 type 信息就设置了, type 信息来源于编译器生成)</p><h2><span id="gc-流程"><strong>GC 流程</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-e0eef1afbfa873db4b0faa21a4741c5f_720w.jpg?source=1940ef5c" alt="img"></p><p>1.5 和 1.12 的 GC 大致流程相同. 上图是 golang 官方的 ppt 里的图, 下图是我根据 1.12 源码绘制的.从最坏可能会有百 ms 的 gc 停顿到能够稳定在 1ms 以下, 这之间 GC 做了很多改进. 右边是我根据官方 issues 整理的一些比较重要的改进. 1.6 的分布式检测, 1.7 将栈收缩放到了并发扫描阶段, 1.8 的混合写屏障, 1.12 更改了 mark termination 检测算法, mcache flush 移除出 mark termination 等等.</p><h2><span id="golang-gc-pacer"><strong>Golang GC Pacer</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-e5d325ee3dbdf9b2911520651798a872_720w.jpg?source=1940ef5c" alt="img"></p><p>大家对并发 GC 除了怎么保证不漏指针有疑问外, 可能还会疑问, 并发 GC 如何保证能够跟得上应用程序的分配速度? 会不会分配太快了, GC 完全跟不上, 然后 OOM?</p><p>这个就是 Golang GC Pacer 的作用.</p><p>Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 以此类推.</p><p>假如上一次 GC 完成时, 存活对象 1000M, 默认 GOGC 100, 那么下次 GC 会在比较接近但小于 2000M 的时候(比如 1900M)开始, 争取在堆大小达到 2000M 的时候结束. 这之间留有一定的裕度, 会计算待扫描对象大小(根据历史数据计算)与可分配的裕度的比例, 应用程序分配内存根据该比例进行辅助 GC, 如果应用程序分配太快了, 导致 credit 不够, 那么会被阻塞, 直到后台的 mark 跟上来了,该比例会随着 GC 进行不断调整.</p><p>GC 结束后, 会根据这一次 GC 的情况来进行负反馈计算, 计算下一次 GC 开始的阈值.</p><p>如何保证按时完成 GC 呢? GC 完了后, 所有的 mspan 都需要 sweep, 类似于 GC 的比例, 从 GC 结束到下一次 GC 开始之间有一定的堆分配裕度, 会根据还有多少的内存需要清扫, 来计算分配内存时需要清扫的 span 数这样的一个比例.</p><p><img src="https://pic2.zhimg.com/50/v2-92218cc498cc9ae159ba9e95df29f4c9_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="实践与总结"><strong>实践与总结</strong></span></h2><h2><span id="观察调度"><strong>观察调度</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-78cd3a12e7aecf54c56eabca2c879f78_720w.jpg?source=1940ef5c" alt="img"></p><p>观察一下调度, 加一些请求. 我们可以看到虽然有 1000 个连接, 但是 go 只用了几个线程就能处理了, 表明 go 的网络的确是由 epoll 管理的. runqueue 表示的是全局队列待运行协程数量, 后面的数字表示每个 P 上的待运行协程数. 可以看到待处理的任务并没有增加, 表示虽然请求很多, 但完全能 hold 住.</p><p>同时可以看到, 不同 P 上有的时候可能任务不均衡, 但是一会后, 任务又均衡了, 表示 go 的 work stealing 是有效的.</p><h2><span id="观察-gc"><strong>观察 GC</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-596836ab3923ed21c32a4a961264d7d8_720w.jpg?source=1940ef5c" alt="img"></p><p>其中一些数据的含义, 在分享的时候没有怎么解释, 不过网上的解释几乎没有能完全解释正确. 我这里敲一下.<br>其实一般关注堆大小和两个 stw 的 wall time 即可.</p><p>gc 8913(第 8913 次 gc) @2163.341s(在程序运行的第 2163s) 1%(gc 所有 work 消耗的历史累计 CPU 比例, 所以其实这个数据没太大意义) 0.13(第一个 stw 的 wall time)+14(并发 mark 的 wall time)+0.20(第二个 stw 的 wall time) ms clock, 1.1(第一个 stw 消耗的 CPU 时间)+21(用户程序辅助扫描消耗的 cpu 时间)/22(分配用于 mark 的 P 消耗的 cpu 时间)/0(空闲的 P 用于 mark 的 cpu 时间)+1.6ms(第 2 个 stw 的 cpu 时间) cpu, 147(gc 开始时的堆大小)-&gt;149(gc 结束的堆大小)-&gt;75MB(gc 结束时的存活堆大小), 151 MB goal(本次 gc 预计结束的堆大小), 8P(8 个 P).</p><h2><span id="优化"><strong>优化</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-dd28c6e140bbcd27d737f61e980b562b_720w.jpg?source=1940ef5c" alt="img"></p><p>个人建议, 没事不要总想着优化, 好好 curd 就好.</p><p><img src="https://pica.zhimg.com/50/v2-2e0bbec8ffca844876195af2e970e8a6_720w.jpg?source=1940ef5c" alt="img"></p><p>当然还是有一些优化方法的.</p><h2><span id="一点实践"><strong>一点实践</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-827fe7197304383f74f774d3c23d8df7_720w.jpg?source=1940ef5c" alt="img"></p><p>我们将 pprof 的开启集成到模板中, 并自动选择端口, 并集成了 gops 工具, 方便查询 runtime 信息, 同时在浏览器上可直接点击生成火焰图, pprof 图, 非常的方便, 也不需要使用者关心.</p><h2><span id="问题排查的一点思路"><strong>问题排查的一点思路</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-eb8dc800c3390a55be87d142cee862f2_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="一次有意思的问题排查"><strong>一次有意思的问题排查</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-8360b4e634560ca5ac314b7b76181b98_720w.jpg?source=1940ef5c" alt="img"></p><p>负载, 依赖服务都很正常, CPU 利用率也不高, 请求也不多, 就是有很多超时.</p><p><img src="https://pic1.zhimg.com/50/v2-8a0e06b128b6f2316d8462b9dbc30e0b_720w.jpg?source=1940ef5c" alt="img"></p><p>该服务在线上打印了 debug 日志, 因为早期的服务模板开启了 gctrace, 框架把 stdout 重定向到一个文件了. 而输出 gctrace 时本来是到 console 的, 输出到文件了, 而磁盘跟不上, 导致 gctrace 日志被阻塞了.</p><p>这里更正一下 ppt 中的内容, 并不是因为 gc 没完成而导致其他协程不能运行, 而是后续 gc 无法开启, 导致实质上的 stw.<br>打印 gc trace 日志时, 已经 start the world 了, 其他协程可以开始运行了. 但是在打印 gctrace 日志时, 还保持着开启 gc 需要的锁, 所以, 打印 gc trace 日志一直没完成, 而 gc 又比较频繁, 比如 0.1s 一次, 这样会导致下一次 gc 开始时无法获取锁, 每一个进入 gc 检查的 p 阻塞, 实际上就造成了 stw.</p><h2><span id="runtime-的一点个人总结"><strong>Runtime 的一点个人总结</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-2c598eec44a5909786868950c5224a6c_720w.jpg?source=1940ef5c" alt="img"></p><p>并行, 纵向多层次, 横向多个 class, 缓存, 缓冲, 均衡.</p><h2><span id="参考文档"><strong>参考文档</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-406faead2e6957e16a50c5b42f58053a_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>本文完整 PPT 可点击下方图片获得。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>开发空间使用文档</title>
    <link href="https://smartxia.github.io/blog/2021/09/01/Wiki/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
    <id>https://smartxia.github.io/blog/2021/09/01/Wiki/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</id>
    <published>2021-09-01T07:44:30.000Z</published>
    <updated>2021-12-02T08:21:58.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="开发空间使用文档">开发空间使用文档</span></h2><h3><span id="项目设置">项目设置</span></h3><h4><span id="项目主页">项目主页</span></h4><p>项目名称：默认创建的时候的名称，可以在这里修改</p><p>封面：项目的封面，可以用来发布，图片尺寸符合页面提示内容</p><p>简介：项目的一些简单介绍</p><h4><span id="代码仓库">代码仓库</span></h4><p>代码仓库默认分为语言类型的git仓库，所带有的框架默认支持打包，和支持中台的基本框架</p><p>前端仓库：vue idg等</p><p>后端仓库：golang java php node 等 </p><p>ios,android,中台小程序，微信小程序，h5，浏览器插件，pc，跨段应用，</p><p>勤务仓库，和区块链专用仓库，并支持复制其他仓库</p><h5><span id="仓库使用">仓库使用：</span></h5><p>默认开发者为主master分支管理员</p><p>分支:</p><p>合并请求：可以合并其他用户提交的合并请求</p><p>标签：利用此标签可以用来打包集成各类型的资产包和镜像</p><p>成员：可以添加成员</p><h4><span id="镜像管理">镜像管理</span></h4><p>可以分为两大类：镜像（可以直接放在服务器运行的）包管理（可以支持其他服务引入的）</p><p>镜像根据仓库类型里的tag然后进行打包：</p><p>包括：php(5-*7)类型，golang(13-15)java 和其他类型打包 vue类型镜像</p><p>包根据仓库里的tag进行打包：</p><p>包括:npm android ios composer h5等类型dab</p><h4><span id="成员管理">成员管理</span></h4><p>此处用来添加用户，其中项目成员基本权限要有：项目负责人或者项目参与者。支持批量添加用户角色</p><h4><span id="部署设置">部署设置</span></h4><p>b部署设置放在此处比较早，需要后端或者项目负责人添加。</p><p>其中包括：对项目所需要的容器资源类型进行配置，和资源模板配置，cpu membery port 等</p><h3><span id="产品定义">产品定义</span></h3><ul><li>模块列表：默认有主模块。主模块权限属于第一个使用产品定义的人，并非创建者。</li></ul><p>可以选择新增模块，填写模块名称和描述，模块标签</p><p>模块之间支持的功能：利用密钥来实现复制（内容复制）和分享（通道分享）</p><p>模块之间可以添加用户，给用户赋予模块负责人、模块参与者（只有浏览权限）</p><ul><li><p>任务列表：</p><p>包括产品、后端、设计使用的基本工具和文档</p><p>需求定义：产品需要写的一些基本功能提供。项目创立之初的一些信息收集，和基本的作图，设计用例，数据模型等功能的支持</p><p>设计文档：一些基本的设计图片文稿，竞品分析，设计用的图片且支持图片拖动执行</p><p>技术定义：后端的一些基本api文档填写</p><p>数据定义：数据库相关的基本使用</p><p>每个分类下分为各种的类型使用，种类繁多，满足项目创立之初所有的使用</p></li></ul><h3><span id="多语言管理">多语言管理</span></h3><h4><span id="项目多语言">项目多语言</span></h4><p>支撑项目内关键词，各个国家语言的翻译使用</p><h3><span id="会议记录">会议记录</span></h3><p>记录项目成员每次开会使用的基本任务</p><h3><span id="接入管理">接入管理</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="资源管理">资源管理</span></h3><p>容器云所需的资源购买和资源配置</p><h3><span id="部署空间">部署空间</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="项目管理">项目管理</span></h3><p>项目issue配置</p><h3><span id="cicd">CICD</span></h3><p>项目自动化测试</p><h3><span id="发布管理">发布管理</span></h3><p>项目发布到市场</p><h3><span id="gui管理">GUI管理</span></h3><p>gui前端界面自动化添加</p><h3><span id="wiki">WIKI</span></h3><p>项目Wiki记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>GOLGANG-笔记6-学习日志位运算符</title>
    <link href="https://smartxia.github.io/blog/2021/08/27/GOLANG/GOLGANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    <id>https://smartxia.github.io/blog/2021/08/27/GOLANG/GOLGANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</id>
    <published>2021-08-27T01:55:06.000Z</published>
    <updated>2021-11-16T10:00:30.882Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>位运算：位运算符对整数在内存中的二进制位进行操作。</p><p> &amp;, |, 和 ^ </p><p>》》》 《《《</p><p>数组</p><p>var a 【5】string</p><p>a:=[5]string[“2”,”3”,”4”,”2”,”3”]</p><p>a:=[….]string[“2”,”3”,”4”,”2”,”3”]</p><p>空指针：指针定义后没有分配到任何变量就会错</p><p>旧的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  topocpzejlq4huin6cmhieqxxn8fep7n  263</p><p>新的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  8191a23b9783477599b9f01f53f5bab7 37</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机基础-转义字符</title>
    <link href="https://smartxia.github.io/blog/2021/06/22/Wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/06/22/Wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</id>
    <published>2021-06-22T02:54:33.000Z</published>
    <updated>2021-11-16T03:33:44.708Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是转义字符有什么用">什么是转义字符？有什么用？</span></h3><p>转义字符是一种特殊的字符常量</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="计算机基础知识" scheme="https://smartxia.github.io/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="转义字符" scheme="https://smartxia.github.io/blog/tags/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
    
      <category term="wiki" scheme="https://smartxia.github.io/blog/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式-修饰符</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</id>
    <published>2021-06-07T08:09:29.000Z</published>
    <updated>2021-11-16T03:33:44.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ul><li><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p></li><li><p>标记不写在正则表达式里，标记位于表达式之外</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;pattern&#x2F;flags</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h4><span id="元字符">元字符</span></h4><h4><span id="运算符优先级">运算符优先级</span></h4><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?=), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/categories/regex/"/>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式-语法</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/</id>
    <published>2021-06-07T05:40:59.000Z</published>
    <updated>2021-11-16T03:33:44.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></p><h4><span id="1普通字符1-9-a-z-a-z-标点符号和一些其他符号">1.普通字符：1-9 a-z A-Z 标点符号和一些其他符号。</span></h4><p><img src="//s2-cdn.oneitfarm.com/eab92d4dcdab496abde257a6adf121c8.png" alt></p><table><thead><tr><th>key</th><th>val</th><th>desc</th><th>exp</th></tr></thead><tbody><tr><td>/*/</td><td></td><td>基础语法区隔，转义符号</td><td></td></tr><tr><td>^</td><td></td><td>开始位置</td><td></td></tr><tr><td>$</td><td></td><td>结束位置</td><td></td></tr><tr><td>[0-9]</td><td></td><td>匹配数字</td><td></td></tr><tr><td>[a-z]</td><td></td><td>小写字母</td><td></td></tr><tr><td>[A-Z]</td><td></td><td>大写字母</td><td></td></tr><tr><td>+</td><td>runoo+b</td><td>匹配一个或多个</td><td></td></tr><tr><td>-</td><td></td><td>连接字符</td><td></td></tr><tr><td>{}</td><td>{3,5}</td><td>字符长度3-5</td><td>^[a-z0-9_-]{3,15}$</td></tr><tr><td>？</td><td>colou?r</td><td>匹配 color 或者 colour</td><td></td></tr><tr><td>…</td><td>[…]</td><td>匹配所有字符</td><td></td></tr><tr><td>( )</td><td>(  )</td><td>子表达式的开始和结束位置</td><td></td></tr></tbody></table><h4><span id="2非打印字符">2.非打印字符</span></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/categories/regex/"/>
    
    
      <category term="regex" scheme="https://smartxia.github.io/blog/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://smartxia.github.io/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://smartxia.github.io/blog/2021/06/07/HTTP/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-06-07T01:49:48.000Z</published>
    <updated>2021-11-16T03:33:44.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><!-- toc --><ul><li><a href="#10-网络协议tcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</a></li><li><a href="#11-请求头">1.1 请求头</a></li><li><a href="#12-三次握手四次挥手">1.2 三次握手四次挥手</a></li><li><a href="#13-报文抓取工具">1.3 报文抓取工具</a><ul><li><a href="#20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</a></li></ul></li><li><a href="#21-请求报文">2.1 请求报文</a></li><li><a href="#22-响应报文">2.2 响应报文</a></li><li><a href="#23-http-抓取工具">2.3 HTTP 抓取工具</a></li><li><a href="#24-session-cookie">2.4 Session Cookie</a><ul><li><a href="#30-总结">3.0 总结</a></li></ul></li></ul><!-- tocstop --><h4><span id="10-网络协议tcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</span></h4><ul><li><p>TCP 七层网络模型<br>主机层：<br>媒介层：</p><p><img src="http://s2-cdn.oneitfarm.com/767fb54c00ef41d1b15f28a8c33f3d16.png" alt></p></li></ul><h4><span id="11-请求头">1.1 请求头</span></h4><h4><span id="12-三次握手四次挥手">1.2 三次握手四次挥手</span></h4><h4><span id="13-报文抓取工具">1.3 报文抓取工具</span></h4><h3><span id="20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</span></h3><p><img src="//s2-cdn.oneitfarm.com/205566ffbffc4786af2443e348192532.png" alt></p><h4><span id="21-请求报文">2.1 请求报文</span></h4><h4><span id="22-响应报文">2.2 响应报文</span></h4><h4><span id="23-http-抓取工具">2.3 HTTP 抓取工具</span></h4><h4><span id="24-session-cookie">2.4 Session Cookie</span></h4><h3><span id="30-总结">3.0 总结</span></h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="HTTP" scheme="https://smartxia.github.io/blog/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>The MIT License</title>
    <link href="https://smartxia.github.io/blog/2021/05/27/Wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
    <id>https://smartxia.github.io/blog/2021/05/27/Wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/</id>
    <published>2021-05-27T01:25:29.000Z</published>
    <updated>2021-11-16T03:33:44.705Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>MIT许可证（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件授权条款（如GPL、LGPL、BSD）相比，MIT是相对宽松的软件授权条款。</p></blockquote><h3><span id="1条款内容">1.条款内容</span></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and&#x2F;or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span><br><span class="line">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br></pre></td></tr></table></figure><h3><span id="2mit与其他开源许可证的区别">2.MIT与其他开源许可证的区别</span></h3><p><img src="//s2-cdn.oneitfarm.com/2bec9f7690a945a499ebc95fd84a0cb5.png" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="其他" scheme="https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
</feed>
