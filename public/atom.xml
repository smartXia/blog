<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Some</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>https://smartxia.github.io/blog</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2021-05-17T06:48:08.791Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git 使用 connot stat</title>
    <link href="https://smartxia.github.io/blog/2021/05/17/GIT/cannot%20stat/"/>
    <id>https://smartxia.github.io/blog/2021/05/17/GIT/cannot%20stat/</id>
    <published>2021-05-17T06:12:35.000Z</published>
    <updated>2021-05-17T06:48:08.791Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>1.记一次使用bug<br><img src= "/blog/img/loading.gif" data-lazy-src="http://s2-cdn.oneitfarm.com/c71c1444ef7b472fbad9c71ba803fa95.png" alt=""><br>git error: cannot stat<br>原因是因为，在某个编辑器打开了master分支的一个文件，然后切换到feat分支，文件并不消失，拉取时候出现问题，</p><p>解决办法：关掉编辑器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="git" scheme="https://smartxia.github.io/blog/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP-析构函数-destruct</title>
    <link href="https://smartxia.github.io/blog/2021/05/17/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
    <id>https://smartxia.github.io/blog/2021/05/17/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</id>
    <published>2021-05-17T06:04:51.777Z</published>
    <updated>2021-05-17T06:39:56.790Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3 id="析构函数destruct"><a href="#析构函数destruct" class="headerlink" title="析构函数destruct"></a>析构函数destruct</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：<strong>construct()在初始化对象的时候默认执行的<br>析构函数：</strong>destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data &#x3D; [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#39;appkey&#39;] &#x3D; getAppkey();</span><br><span class="line">        $data[&#39;channel&#39;] &#x3D; getChannel();</span><br><span class="line">        $this-&gt;data[] &#x3D; $data;</span><br><span class="line">        &#x2F;&#x2F;这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id &#x3D; $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#39;id &lt;&#39; &#x3D;&gt; $id - 50000</span><br><span class="line">            ], &#39;&#39;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend&#x3D;new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="php" scheme="https://smartxia.github.io/blog/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2021/05/17/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
    <id>https://smartxia.github.io/blog/2021/05/17/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</id>
    <published>2021-05-17T06:04:51.650Z</published>
    <updated>2021-05-17T06:04:51.651Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. :&#x3D; &#x3D; &#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">:&#x3D; 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">&#x3D; 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D; 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 :&#x3D; make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val :&#x3D; make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">ch :&#x3D; make(chan int, 100) &#x2F;&#x2F; make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    &#x2F;&#x2F; 把 v 发送到通道 ch</span><br><span class="line">v :&#x3D; &lt;-ch  &#x2F;&#x2F; 从 ch 接收数据</span><br><span class="line">&#x2F;&#x2F; 并把值赋给 v</span><br><span class="line">​&#96;&#96;&#96;</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-改善golang50个有效实践</title>
    <link href="https://smartxia.github.io/blog/2021/05/14/GOLANG/GOLANG-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
    <id>https://smartxia.github.io/blog/2021/05/14/GOLANG/GOLANG-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/</id>
    <published>2021-05-14T05:24:11.000Z</published>
    <updated>2021-05-17T06:27:15.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>闲逛好久go论坛，找到一本适合看的教程，花了点时间将这个文章搬运过来，自己慢慢研读</p></blockquote><h4 id="1-语言的前生今世"><a href="#1-语言的前生今世" class="headerlink" title="1 语言的前生今世"></a>1 <a href="https://smartxia.github.io/blog/book/01Go语言的前生今世慕课专栏.html">语言的前生今世</a></h4><h4 id="2-语言的设计哲学之一简单"><a href="#2-语言的设计哲学之一简单" class="headerlink" title="2 语言的设计哲学之一简单"></a>2 <a href="https://smartxia.github.io/blog/book/02Go语言的设计哲学之一简单慕课专栏.html">语言的设计哲学之一简单</a></h4><h4 id="3-语言的设计哲学之二组合"><a href="#3-语言的设计哲学之二组合" class="headerlink" title="3  语言的设计哲学之二组合"></a>3  <a href="https://smartxia.github.io/blog/book/03Go语言的设计哲学之二组合慕课专栏.html">语言的设计哲学之二组合</a></h4><h4 id="4-Go语言的设计哲学之三并发"><a href="#4-Go语言的设计哲学之三并发" class="headerlink" title="4  Go语言的设计哲学之三并发"></a>4  <a href="https://smartxia.github.io/blog/book/04Go语言的设计哲学之三并发慕课专栏.html">Go语言的设计哲学之三并发</a></h4><h4 id="5-Go-语言的设计哲学之四面向工程"><a href="#5-Go-语言的设计哲学之四面向工程" class="headerlink" title="5  Go 语言的设计哲学之四面向工程"></a>5  <a href="https://smartxia.github.io/blog/book/05Go语言的设计哲学之四面向工程慕课专栏.html">Go 语言的设计哲学之四面向工程</a></h4><h4 id="6-参考-Go-项目布局设计你的项目结构"><a href="#6-参考-Go-项目布局设计你的项目结构" class="headerlink" title="6  参考 Go 项目布局设计你的项目结构"></a>6  <a href="https://smartxia.github.io/blog/book/06参考Go项目布局设计你的项目结构慕课专栏.html">参考 Go 项目布局设计你的项目结构</a></h4><h4 id="7-gofmtGo代码风格的唯一标准"><a href="#7-gofmtGo代码风格的唯一标准" class="headerlink" title="7  gofmtGo代码风格的唯一标准"></a>7  <a href="https://smartxia.github.io/blog/book/07gofmtGo代码风格的唯一标准慕课专栏.html">gofmtGo代码风格的唯一标准</a></h4><h4 id="8-Go-标识符的命名惯例"><a href="#8-Go-标识符的命名惯例" class="headerlink" title="8  Go 标识符的命名惯例"></a>8  <a href="https://smartxia.github.io/blog/book/08Go标识符的命名惯例慕课专栏.html">Go 标识符的命名惯例</a></h4><h4 id="9-变量声明形式尽量保持一致"><a href="#9-变量声明形式尽量保持一致" class="headerlink" title="9  变量声明形式尽量保持一致"></a>9  <a href="https://smartxia.github.io/blog/book/09变量声明形式尽量保持一致慕课专栏.html">变量声明形式尽量保持一致</a></h4><h4 id="10-无类型常量让代码更简化"><a href="#10-无类型常量让代码更简化" class="headerlink" title="10  无类型常量让代码更简化"></a>10  <a href="https://smartxia.github.io/blog/book/10无类型常量让代码更简化慕课专栏.html">无类型常量让代码更简化</a></h4><h4 id="11-Go“枚举常量”的惯用实现方法"><a href="#11-Go“枚举常量”的惯用实现方法" class="headerlink" title="11  Go“枚举常量”的惯用实现方法"></a>11  <a href="https://smartxia.github.io/blog/book/11Go“枚举常量”的惯用实现方法慕课专栏.html">Go“枚举常量”的惯用实现方法</a></h4><h4 id="12-定义“零值可用”的类型"><a href="#12-定义“零值可用”的类型" class="headerlink" title="12  定义“零值可用”的类型"></a>12  <a href="https://smartxia.github.io/blog/book/12定义"零值可用"的类型慕课专栏.html">定义“零值可用”的类型</a></h4><h4 id="13-用复合字面值作初值构造器"><a href="#13-用复合字面值作初值构造器" class="headerlink" title="13  用复合字面值作初值构造器"></a>13  <a href="https://smartxia.github.io/blog/book/13用复合字面值作初值构造器慕课专栏.html">用复合字面值作初值构造器</a></h4><h4 id="14-深入理解和高效运用切片-slice"><a href="#14-深入理解和高效运用切片-slice" class="headerlink" title="14  深入理解和高效运用切片(slice)"></a>14  <a href="https://smartxia.github.io/blog/book/14深入理解和高效运用切片(slice)慕课专栏.html">深入理解和高效运用切片(slice)</a></h4><h4 id="15-注意Go-字符串是原生类型"><a href="#15-注意Go-字符串是原生类型" class="headerlink" title="15  注意Go 字符串是原生类型"></a>15  <a href="https://smartxia.github.io/blog/book/15注意Go字符串是原生类型慕课专栏.html">注意Go 字符串是原生类型</a></h4><h4 id="16-理解包导入路径的含义"><a href="#16-理解包导入路径的含义" class="headerlink" title="16  理解包导入路径的含义"></a>16  <a href="https://smartxia.github.io/blog/book/16理解包导入路径的含义慕课专栏.html">理解包导入路径的含义</a></h4><h4 id="17-init-函数的妙用"><a href="#17-init-函数的妙用" class="headerlink" title="17  init 函数的妙用"></a>17  <a href="https://smartxia.github.io/blog/book/17init函数的妙用慕课专栏.html">init 函数的妙用</a></h4><h4 id="18-Go-函数是“一等公民”"><a href="#18-Go-函数是“一等公民”" class="headerlink" title="18  Go 函数是“一等公民”"></a>18  <a href="https://smartxia.github.io/blog/book/18Go函数是“一等公民”慕课专栏.html">Go 函数是“一等公民”</a></h4><h4 id="19-defer-让你的代码更清"><a href="#19-defer-让你的代码更清" class="headerlink" title="19  defer 让你的代码更清"></a>19  <a href="https://smartxia.github.io/blog/book/19defer让你的代码更清晰慕课专栏.html">defer 让你的代码更清</a></h4><h4 id="20-方法的本质"><a href="#20-方法的本质" class="headerlink" title="20  方法的本质"></a>20  <a href="https://smartxia.github.io/blog/book/20Go方法的本质慕课专栏.html">方法的本质</a></h4><h4 id="21-方法集合决定接口实现"><a href="#21-方法集合决定接口实现" class="headerlink" title="21  方法集合决定接口实现"></a>21  <a href="https://smartxia.github.io/blog/book/21方法集合决定接口实现慕课专栏.html">方法集合决定接口实现</a></h4><h4 id="22-变长参数函数的妙用"><a href="#22-变长参数函数的妙用" class="headerlink" title="22  变长参数函数的妙用"></a>22  <a href="https://smartxia.github.io/blog/book/22变长参数函数的妙用慕课专栏.html">变长参数函数的妙用</a></h4><hr>转载自慕课资源，仅供学习使用，如有侵权联系自行删除]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
      <category term="书籍" scheme="https://smartxia.github.io/blog/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="推荐" scheme="https://smartxia.github.io/blog/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>其他-软件行业高频单词</title>
    <link href="https://smartxia.github.io/blog/2021/05/14/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/"/>
    <id>https://smartxia.github.io/blog/2021/05/14/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</id>
    <published>2021-05-14T02:20:48.000Z</published>
    <updated>2021-05-17T06:37:36.682Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="1-golang高频英语"><a href="#1-golang高频英语" class="headerlink" title="1.golang高频英语"></a>1.golang高频英语</h3><p><strong>并发</strong>：(Concurrency) [kənˈkʌrənsɪ] </p><p><strong>并行</strong>：(Parallelism) [ˈpærəlelɪzəm]  </p><p><strong>摩尔定律</strong>：(Moore’s Law):集成电路上可以容纳的晶体管数目在大约每经过18个月便会增加一倍。换言之，处理器的性能每隔两年翻一倍</p><p><strong>cup主频</strong>：（CPU Clock Speed）:主频即CPU的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了CPU速度的快慢</p><p><strong>时钟频率</strong>：(clock rate):是指同步电路中时钟的基础频率，它以“若干次周期每秒”来度量，量度单位采用SI单位赫兹（Hz）。它是评定CPU性能的重要指标。一般来说主频数字值越大越好。外频，是CPU外部的工作频率，是由主板提供的基准时钟频率。FSB频率，是连接CPU和主板芯片组中的北桥芯片的前端总线（Front Side Bus）上的数据传输频率。CPU的主频和外频间存在这样的关系：主频=外频×倍频。</p><p><strong>pthread</strong>： (线程)<br><strong>kernel</strong> ：（核心）</p><p>好的命名就像一个好笑话。如果你必须解释它，那就不好笑了</p><p><strong>在 Go 语言中 interface 名字仍然以单个词为优先。对于拥有唯一方法 (method) 或通过多个拥有唯一方法的接口组合而成的接口，Go 语言的惯例是一般用 “方法名 + er” 的方式为 interface 命名</strong></p><p>Go 设计者认为隐式转换带来的便利性不足以抵消其带来的诸多问题 1，因此要解决上面的编译错误，我们必须进行显式地转型：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="其他" scheme="https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>设计模式-概述，为什么要使用设计模式</title>
    <link href="https://smartxia.github.io/blog/2021/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartxia.github.io/blog/2021/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-13T05:39:46.000Z</published>
    <updated>2021-05-17T06:20:26.902Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="设计模式（Design-pattern）"><a href="#设计模式（Design-pattern）" class="headerlink" title="设计模式（Design pattern）"></a>设计模式（Design pattern）</h3><blockquote><p>GOF(gong of for)可复用面向对象软件元素</p></blockquote><ul><li>对接口编程而不是对实现编程</li><li>优先使用对象组合而不是继承</li></ul><h3 id="设计模式的类型（23种）"><a href="#设计模式的类型（23种）" class="headerlink" title="设计模式的类型（23种）"></a>设计模式的类型（23种）</h3><p>基本可以分为四大类：</p><ul><li>创建型模式（Creational Patterns）<br>提供一种在创建对象的时候隐藏逻辑方法的形式，而不是直接new一个对象，这使得程序在判断针对某个特定的实例需要创建哪些对象的时候更加灵活。</li><li>结构型模式 (Structural Patterns)<br>关注类和对象组合，集成的概念用来组合接口和定义组合对象 获取新的功能方式</li><li>行为型模式 (Behavioral Patterns)<br>关注对象之间的通信</li><li>j2EE模式<br>这些模式主要由java 中的设计模式提供（Sun Java Center）</li></ul><table><thead><tr><th align="left"></th><th>模式描述</th><th align="center">包括</th></tr></thead><tbody><tr><td align="left">1</td><td>创建型模式</td><td align="center">工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern）</td></tr><tr><td align="left">2</td><td>结构型模式</td><td align="center">适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern）</td></tr><tr><td align="left">3</td><td>行为型模式</td><td align="center">责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern）</td></tr><tr><td align="left">4</td><td>J2ee型模式</td><td align="center">MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h3 id="设计模式-之间关系"><a href="#设计模式-之间关系" class="headerlink" title="设计模式 之间关系"></a>设计模式 之间关系</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg" alt=""></p><h3 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h3><ol><li><p>开闭原则（Open Close Principle）:<br> <strong>对扩展开放，对修改关闭</strong> ，在程序需要进行扩展的时候，不能去修改原代码，实现一个热拔插的效果。为了的是使程序的扩展性更好，易于维护和升级，我们需要使用接口和抽象类来实现</p></li><li><p>里氏代换原则（Liskow Substitution Priciple）</p><p> 任何基类出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位不受影响的时候，基类才能真正的被附中，而派生类可以在基类中增加新的行为，LSP是对开闭原则的补充。开闭原则关键步骤就是抽象化，基类与子类的继承关系就是抽象化的具体实现，即：对实现抽象化具体步骤的规范</p></li><li><p>依赖倒转原则（Dependence Inversion Priciple）</p><p> 针对接口变成，依赖于抽象而不依赖于具体</p></li><li><p>接口隔离原则（Interface Segregation Priciple）</p><p> 多实用隔离的接口，比使用单个接口更好。降低类之间的耦合度。</p></li><li><p>迪米特法则（Demeter Priciple）</p><p> 最少知道的原则：一个实体应当尽量少跟其他实体之间发生相互的作用，是得系统模块相对</p></li><li><p>合成复用原则（composite Reuse Priciple）</p><p> 尽量使用合成/聚合方式，而不是使用继承</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="设计模式" scheme="https://smartxia.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://smartxia.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>PHP-Phpfpm进程管理的三种模式</title>
    <link href="https://smartxia.github.io/blog/2021/05/10/PHP/PHP-Phpfpm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartxia.github.io/blog/2021/05/10/PHP/PHP-Phpfpm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-05-10T03:44:49.000Z</published>
    <updated>2021-05-17T06:52:13.747Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP-Phpfmp-如何分配任务到子进程的</title>
    <link href="https://smartxia.github.io/blog/2021/05/10/PHP/PHP-Phpfmp-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84/"/>
    <id>https://smartxia.github.io/blog/2021/05/10/PHP/PHP-Phpfmp-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84/</id>
    <published>2021-05-10T03:43:54.000Z</published>
    <updated>2021-05-17T06:52:13.710Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://blog.csdn.net/liuqun0319/article/details/92573976?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest">https://blog.csdn.net/liuqun0319/article/details/92573976?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记5-gin开发规范</title>
    <link href="https://smartxia.github.io/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B05-gin%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://smartxia.github.io/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B05-gin%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2021-04-29T09:32:51.000Z</published>
    <updated>2021-05-17T06:04:51.670Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2 id="Go语言Web框架基线版本"><a href="#Go语言Web框架基线版本" class="headerlink" title="Go语言Web框架基线版本"></a>Go语言Web框架基线版本</h2><h3 id="一-框架简介"><a href="#一-框架简介" class="headerlink" title="一.框架简介"></a>一.框架简介</h3><p>此web框架已gin为核心，包含了mysq、redis、rabbitmq、log、es等基础组件。<br>此框架内dockerfile和makefile已适配中台的打镜像流程，一般情况下不需要对这两个文件进行修改。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── controller &#x2F;&#x2F;控制器</span><br><span class="line">│   └── v1</span><br><span class="line">├── dao &#x2F;&#x2F;dao层</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   └── redis</span><br><span class="line">├── db &#x2F;&#x2F;mysql文件初始化</span><br><span class="line">├── docs &#x2F;&#x2F;swagger 接口文档</span><br><span class="line">├── middleware &#x2F;&#x2F;中间件</span><br><span class="line">├── model &#x2F;&#x2F;model层</span><br><span class="line">│   ├── mapi</span><br><span class="line">│   ├── mdb</span><br><span class="line">│   ├── mmysql</span><br><span class="line">│   └── mparam</span><br><span class="line">├── pconst &#x2F;&#x2F;常量定义</span><br><span class="line">├── route &#x2F;&#x2F;路由层</span><br><span class="line">│   └── v1</span><br><span class="line">├── script &#x2F;&#x2F;脚本层</span><br><span class="line">│   └── logic</span><br><span class="line">├── server &#x2F;&#x2F;服务启动</span><br><span class="line">├── service &#x2F;&#x2F;业务层</span><br><span class="line">├── tgo &#x2F;&#x2F;基础组件</span><br><span class="line">└── util &#x2F;&#x2F;工具包</span><br><span class="line">    ├── curl</span><br><span class="line">    └── ip</span><br></pre></td></tr></table></figure><h3 id="二-框架分层"><a href="#二-框架分层" class="headerlink" title="二.框架分层"></a>二.框架分层</h3><h4 id="2-1-路由层"><a href="#2-1-路由层" class="headerlink" title="2.1.路由层"></a>2.1.路由层</h4><p>框架采用强路由模式，支持路由群组、中间件模式，自带跨域组件并默认开启，路由文件存放在 route 目录下</p><h4 id="2-2-控制器层"><a href="#2-2-控制器层" class="headerlink" title="2.2.控制器层"></a>2.2.控制器层</h4><p>控制器存放在controller目录下，并区分版本，此层仅针对参数进行过滤处理，不处理相关业务。已集成swagger自动生成接口文档</p><h4 id="2-3-业务层"><a href="#2-3-业务层" class="headerlink" title="2.3.业务层"></a>2.3.业务层</h4><p>业务层存放在service目录下，用来处理业务相关的逻辑</p><h4 id="2-4-数据处理层"><a href="#2-4-数据处理层" class="headerlink" title="2.4.数据处理层"></a>2.4.数据处理层</h4><p>业务层存放在dao目录下，并根据下游不同服务放入不同目录下，此层仅处理数据，不处理业务相关逻辑</p><h4 id="2-5-对象层"><a href="#2-5-对象层" class="headerlink" title="2.5.对象层"></a>2.5.对象层</h4><p>对象层存放在mode目录下，并根据对象的不同类型存放下级不同目录</p><h4 id="2-6-中间件层"><a href="#2-6-中间件层" class="headerlink" title="2.6.中间件层"></a>2.6.中间件层</h4><p>中间件层存放在middleware目录下，用以对同一分组或具有相同特征的路由进行全局业务处理</p><h4 id="2-7-脚本层"><a href="#2-7-脚本层" class="headerlink" title="2.7.脚本层"></a>2.7.脚本层</h4><p>脚本层存放在script目录下，用以处理非http类型的业务类型</p><h4 id="2-8-常量层"><a href="#2-8-常量层" class="headerlink" title="2.8.常量层"></a>2.8.常量层</h4><p>常量定义存放在pconst目录下</p><h3 id="三-整体流程"><a href="#三-整体流程" class="headerlink" title="三.整体流程"></a>三.整体流程</h3><p>框架整体请求请求流程为route - middleware - controller - service - dao，控制器、业务、数据处理禁止逆向调用</p><h3 id="四-请求示例"><a href="#四-请求示例" class="headerlink" title="四.请求示例"></a>四.请求示例</h3><p>参考控制器下 log_platform.go 文件</p><h3 id="五-中台服务间调用"><a href="#五-中台服务间调用" class="headerlink" title="五.中台服务间调用"></a>五.中台服务间调用</h3><blockquote><p>gosdk使用和服务间调用有问题和建议可以联系联系基础架构部：张超</p></blockquote><p>中台服务间调用通过<a href="https://gitlab.oneitfarm.com/bifrost/gosdk">gosdk</a>进行调用，gosdk如何使用可以参考服务内的readme文档。 </p><p>为了降低使用成本，我们对gosdk进行了一次封装<a href="https://gitlab.oneitfarm.com/ci123sdk/requester">requester</a>包，并提供了一个案例<a href="https://gitlab.oneitfarm.com/ci123sdk/account">account</a>服务的接口封装。</p><p>【强烈建议】：对子服务（比如A）的调用封装成单独的包，并在gitlab.oneitfarm.com/ci123sdk group下创建项目A，将服务A的接口调用封装。这样其他项目（人）在接入A项目时，不需要再重复封装此部分内容。<br>简单来说就是每个服务在ci123sdk的group下创建项目，后续所有对此服务调用的封装都在此项目中，所有引用此服务的服务或应用，只需要引用此包进行开发，如果支持接口不全就在此项目中完善并打新的tag增加版本。</p><h3 id="六-关于PR"><a href="#六-关于PR" class="headerlink" title="六.关于PR"></a>六.关于PR</h3><p>有任何疑问或者建议，欢迎随时联系基础架构部：陶圣，也欢迎各位提交有价值的PR，也将纳入年终绩效考核一部分</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
      <category term="farmworker" scheme="https://smartxia.github.io/blog/tags/farmworker/"/>
    
      <category term="gin" scheme="https://smartxia.github.io/blog/tags/gin/"/>
    
  </entry>
  
  <entry>
    <title>高性能库zap gox</title>
    <link href="https://smartxia.github.io/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B04-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%93zap/"/>
    <id>https://smartxia.github.io/blog/2021/04/29/GOLANG/GOLANG-%E7%AC%94%E8%AE%B04-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%93zap/</id>
    <published>2021-04-29T09:31:41.000Z</published>
    <updated>2021-05-17T06:04:51.664Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2 id="zap"><a href="#zap" class="headerlink" title="zap"></a>zap</h2><p>高性能日志库分析</p><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><p>##GOX<br>交叉编译工具可以编译各种的环境<br>go get github.com/mitchellh/gox<br>gox -build-toolchain</p><p>直接运行gox。程序会一口气生成17个文件<br>横跨windows,linux,mac,freebsd,netbsd五大操作系统<br>#####固定平台<br>gox -osarch “windows/amd64 linux/amd64” 或<br>        gox -os “windows linux” -arch amd64</p><h4 id="go-mod-init-命令"><a href="#go-mod-init-命令" class="headerlink" title="go mod init 命令"></a>go mod init 命令</h4><p>go.sum是一个模块版本内容的校验值，用来验证当前缓存的模块。go.sum包含了直接依赖和间接依赖的包的信息，比go.mod要多一些。</p><h4 id="查看依赖包"><a href="#查看依赖包" class="headerlink" title="查看依赖包"></a>查看依赖包</h4><p>go list -m all</p><h4 id="模块配置文本格式化"><a href="#模块配置文本格式化" class="headerlink" title="模块配置文本格式化"></a>模块配置文本格式化</h4><p>go mod edit -fmt</p><h4 id="Windows-下开启-GO111MODULE-的命令为："><a href="#Windows-下开启-GO111MODULE-的命令为：" class="headerlink" title="Windows 下开启 GO111MODULE 的命令为："></a>Windows 下开启 GO111MODULE 的命令为：</h4><p>set GO111MODULE=on 或者 set GO111MODULE=auto</p><h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>GOPROXY=<a href="https://goproxy.cn,direct">https://goproxy.cn,direct</a></p><h4 id="以索引整个-GOPATH"><a href="#以索引整个-GOPATH" class="headerlink" title="以索引整个 GOPATH"></a>以索引整个 GOPATH</h4><p>.Preferences -&gt; Go -&gt; GOPATH，勾选上 Index entire GOPATH</p><hr><h4 id="基础命令关于module的"><a href="#基础命令关于module的" class="headerlink" title="基础命令关于module的"></a>基础命令关于module的</h4><p>go mod download<br>go mod download -json 参数会以JSON的格式打印下载的模块对象<br /><br>go mod tidy<br>go mod tidy -v  可以将执行的信息<br>可以使用go mod tidy命令来清除它<br /><br>go mod vendor<br>go mod vendor -v会将添加到vendor中的模块打印到标准输出。<br>go mod graph<br /><br>打印模块依赖图</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/categories/golang/"/>
    
    
      <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
      <category term="zap" scheme="https://smartxia.github.io/blog/tags/zap/"/>
    
      <category term="gox" scheme="https://smartxia.github.io/blog/tags/gox/"/>
    
      <category term="module" scheme="https://smartxia.github.io/blog/tags/module/"/>
    
  </entry>
  
  <entry>
    <title>最近太懒了</title>
    <link href="https://smartxia.github.io/blog/2021/04/29/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B6%E4%BB%96-%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/"/>
    <id>https://smartxia.github.io/blog/2021/04/29/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B6%E4%BB%96-%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/</id>
    <published>2021-04-29T09:22:49.000Z</published>
    <updated>2021-05-17T08:06:38.228Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p> 自定义支持markdown只会让我的VsCode越来越卡</p><p>#<br>技术性不强但是打字还慢无语了，这个打字的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br></pre></td></tr></table></figure> <hr><p><br>强行换行</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP-解决循环内存占用溢出-缓冲查询</title>
    <link href="https://smartxia.github.io/blog/2020/09/02/PHP/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/"/>
    <id>https://smartxia.github.io/blog/2020/09/02/PHP/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-09-02T06:50:51.000Z</published>
    <updated>2021-05-17T06:39:38.783Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP-深拷贝浅拷贝-_clone</title>
    <link href="https://smartxia.github.io/blog/2020/09/02/PHP/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://smartxia.github.io/blog/2020/09/02/PHP/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-09-02T06:50:07.000Z</published>
    <updated>2021-05-17T06:39:53.748Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ul><li>深拷贝//变量复制了一份传递给另一个变量就是深拷贝,一个值改变了,另一个值不会变（直接复制）</li></ul><ul><li>浅拷贝//变量之间的值是地址*|&amp;传递,这就是浅拷贝.值如果改变了两个变量的值都会改变 （引用复制，可变）</li></ul><blockquote><p>关键次 _clone</p></blockquote><ul><li>对象赋值：浅拷贝</li><li>普通类型的变量是深拷贝</li></ul><h4 id="php默认浅拷贝即普通赋值"><a href="#php默认浅拷贝即普通赋值" class="headerlink" title="php默认浅拷贝即普通赋值"></a>php默认浅拷贝即普通赋值</h4><blockquote><p>例1：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Persion</span><br><span class="line">&#123;</span><br><span class="line">public $age &#x3D; 0;</span><br><span class="line">public $name &#x3D; &#39;xiapeifus&#39;;</span><br><span class="line">public $obj &#x3D; null;</span><br><span class="line">&#125;</span><br><span class="line">$persion &#x3D; new Persion();</span><br><span class="line">$xiaoming &#x3D; clone $persion; &#x2F;&#x2F;使用clone关键字复制一份$a的值,进行深拷贝.拷贝之后不会改变$a之前的值</span><br><span class="line">$xiaoming-&gt;age &#x3D; 1;</span><br><span class="line">var_dump($persion-&gt;age);&#x2F;&#x2F; 0</span><br><span class="line">var_dump($xiaoming-&gt;age);&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure><blockquote><p>//例2：增加__clone对象的赋值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class doclone&#123;</span><br><span class="line">    private $id,$name,$address;</span><br><span class="line">    public function __construct($id&#x3D;0,$name&#x3D;&#39;&#39;,$address&#x3D;&#39;&#39;)&#123;</span><br><span class="line">        $this-&gt;name&#x3D;$name;</span><br><span class="line">        $this-&gt;id&#x3D;$id;</span><br><span class="line">        $this-&gt;address&#x3D;$address;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_id()&#123;</span><br><span class="line">        return $this-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_name()&#123;</span><br><span class="line">        return $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_address()&#123;</span><br><span class="line">        return $this-&gt;address;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __clone()&#123;</span><br><span class="line">        $this-&gt;id&#x3D;$this-&gt;id+1;</span><br><span class="line">        $this-&gt;name&#x3D;&#39;wqw&#39;;</span><br><span class="line">        $this-&gt;address&#x3D;&#39;USA&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$A &#x3D; new doclone(1,&#39;xiapeifu&#39;,&#39;UK&#39;);</span><br><span class="line">echo &#39;克隆之前的对象:&#39;;</span><br><span class="line">echo &#39;id&#x3D;&#39;.$A-&gt;get_id();</span><br><span class="line">echo &#39;name&#x3D;&#39;.$A-&gt;get_name();</span><br><span class="line">echo &#39;address&#x3D;&#39;.$A-&gt;get_address();</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$B &#x3D; clone $A;</span><br><span class="line">echo &#39;克隆过后的对象：&#39;;</span><br><span class="line">echo &#39;id&#x3D;&#39;.$A-&gt;get_id();</span><br><span class="line">echo &#39;name&#x3D;&#39;.$A-&gt;get_name();</span><br><span class="line">echo &#39;address&#x3D;&#39;.$A-&gt;get_address();</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">echo &#39;克隆过后的对象属性:&#39;;</span><br><span class="line">echo &#39;id&#x3D;&#39;.$B-&gt;get_id();</span><br><span class="line">echo &#39;name&#x3D;&#39;.$B-&gt;get_name();</span><br><span class="line">echo &#39;address&#x3D;&#39;.$B-&gt;get_address();</span><br><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">&#x2F;&#x2F;克隆之前的对象:id&#x3D;1name&#x3D;xiapeifuaddress&#x3D;UK</span><br><span class="line">&#x2F;&#x2F;克隆过后的对象：id&#x3D;1name&#x3D;xiapeifuaddress&#x3D;UK</span><br><span class="line">&#x2F;&#x2F;克隆过后的对象属性:id&#x3D;2name&#x3D;wqwaddress&#x3D;USA</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>思考：colne 关键词 当对象没<strong>colne 方法时候类似于new 一个对象出来没区别<br>        当对象有</strong>clone时候会在clone里面的重新赋值新的属性，类似于重新new 一个对象 ，只不过把重新new的对象进行一些默认操作，其实重新new一个对象重新赋值也一样，clone可能就是单纯炫技吧</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>Git-代码提交规范</title>
    <link href="https://smartxia.github.io/blog/2020/09/02/GIT/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
    <id>https://smartxia.github.io/blog/2020/09/02/GIT/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</id>
    <published>2020-09-02T06:13:27.000Z</published>
    <updated>2021-05-17T06:29:09.665Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Git commit message 是Git提交的必要信息，message的信息完整度也反映了工程师对于代码提交的重视程度，不清晰的git message信息甚至会让工程师完全回忆不起自己当初做了什么调整，导致后续代码维护成本特别大。因此为了提高线上代码库的管理程度，特此制定GIT commit message规范。</p><p>一、commit message格式<br>1、Type(必须)<br>用于说明 git commit 的类别，只允许使用下面的标识。<br>feat：新功能（feature）。<br>fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。<br>fix：产⽣diff并自动修复此问题。适合于一次提交直接修复问题<br>to：只产⽣diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix<br>docs：文档（documentation）。<br>style：格式（不影响代码运行的变动）。<br>refactor：重构（即不是新增功能，也不是修改bug的代码变动）。<br>perf：优化相关，比如提升性能、体验。<br>test：增加测试。<br>chore：构建过程或辅助工具的变动。<br>revert：回滚到上一个版本。<br>merge：代码合并。<br>sync：同步主线或分⽀的Bug</p><p>2、scope(可选)<br>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。<br>例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。<br>如果你的修改影响了不止一个scope，你可以使用*代替。</p><p>3、subject(必须)<br>subject是commit目的的简短描述，不超过50个字符。<br>1.建议使用中文。<br>2.结尾不加句号或其他标点符号。<br>根据以上规范 git commit message 将是如下的格式：<br>fix(DAO): 用户查询缺少username属性<br>feat(Controller): 用户查询接口开发</p><p>二、规范的好处<br>我们这样规范git commit到底有哪些好处呢？<br>1.便于程序员对提交历史进行追溯，了解发⽣了什么情况。<br>2.一旦约束了commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个git commit里面，这样一来整个代码改动的历史也将更加清晰。<br>3.格式化的commit message才可以用于自动化输出Change log。</p><p>三、标准执行监管<br>为了更好的执行标准，公司针对git提交会进行相关监管功能的研发，当工程师提了不合规的commit，会收到相关的邮件警告。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="git" scheme="https://smartxia.github.io/blog/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>前端-npm私有源加载平台</title>
    <link href="https://smartxia.github.io/blog/2020/09/01/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
    <id>https://smartxia.github.io/blog/2020/09/01/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/</id>
    <published>2020-09-01T09:30:06.000Z</published>
    <updated>2021-05-17T06:37:25.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3 id="调研平台：sinopia，Verdaccio"><a href="#调研平台：sinopia，Verdaccio" class="headerlink" title="调研平台：sinopia，Verdaccio"></a>调研平台：sinopia，Verdaccio</h3><h4 id="Verdaccio"><a href="#Verdaccio" class="headerlink" title="Verdaccio"></a>Verdaccio</h4><h5 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h5><p><a href="https://verdaccio.org/docs/en/configuration">https://verdaccio.org/docs/en/configuration</a></p><p>搭建：</p><h5 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h5><p>身份验证与您正在使用的auth <a href="https://verdaccio.org/docs/en/plugins">插件相关</a>。软件包限制也由<a href="https://verdaccio.org/docs/en/packages">Package Access</a>处理。</p><p>客户端：基于npm客户端登录后会生成一个配置令牌，在.npmrc中</p><p><a href="https://docs.npmjs.com/files/npmrc">https://docs.npmjs.com/files/npmrc</a></p><p>且允许匿名发布包</p><p>包发布的时候允许阻止访问和下载</p><p>服务端关于组的验证:</p><p>​    access: $all-&gt;<br>​    publish: $all<br>​    proxy: npmjs</p><p><img src= "/blog/img/loading.gif" data-lazy-src="//s2-cdn.oneitfarm.com/186bdf368bd54a57b12eb71ba2e10636.png" alt="image-20200901175328057"></p><p> 不同的包读取权限限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">packages:</span><br><span class="line">  <span class="string">&#x27;jquery&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $all</span><br><span class="line">  <span class="string">&#x27;my-company-*&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">  <span class="string">&#x27;@my-local-scope/*&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    access: $all</span><br><span class="line">    publish: $authenticated</span><br><span class="line">    proxy: npmjs</span><br></pre></td></tr></table></figure><p>组 定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;company-*&#39;:</span><br><span class="line">  access: admin internal</span><br><span class="line">  publish: admin</span><br><span class="line">  proxy: server1</span><br><span class="line">&#39;supersecret-*&#39;:</span><br><span class="line">  access: secret super-secret-area ultra-secret-area</span><br><span class="line">  publish: secret ultra-secret-area</span><br><span class="line">  proxy: server1</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="前端知识" scheme="https://smartxia.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/"/>
    
    
  </entry>
  
  <entry>
    <title>其他-CRLF、CR、LF详解</title>
    <link href="https://smartxia.github.io/blog/2020/09/01/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/"/>
    <id>https://smartxia.github.io/blog/2020/09/01/%E5%85%B6%E4%BB%96/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-09-01T06:42:31.000Z</published>
    <updated>2021-05-17T06:37:49.552Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>很长一段时间里，对于CRLF、CR、LF的理解仅限于不同操作系统下对换行符的定义。所谓知其然需知其所以然，从学习中找到乐趣，对知识的记忆才会更加深刻。</p><p>名词解释<br>CR：Carriage Return，对应ASCII中转义字符\r，表示回车<br>LF：Linefeed，对应ASCII中转义字符\n，表示换行<br>CRLF：Carriage Return &amp; Linefeed，\r\n，表示回车并换行<br>众所周知，Windows操作系统采用两个字符来进行换行，即CRLF；Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行；另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。</p><p>野史<br>老式机械打字机（来源：视觉中国）<br>据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。</p><p>当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。</p><p>随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。</p><p>结论<br>许多现代的文本编辑器和命令行工具都提供了可选择的换行符配置，方便用户按照自己的意愿来改变换行符的表现形式，所以我们只需要知道CRLF、CR、LF的作用即可。</p><p>参考文献<br><a href="http://en.wikipedia.org/wiki/Newline">http://en.wikipedia.org/wiki/Newline</a><br><a href="https://en.wikipedia.org/wiki/Control_character">https://en.wikipedia.org/wiki/Control_character</a><br><a href="https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types">https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types</a></p><p>作者：JSoon<br>链接：<a href="https://www.jianshu.com/p/b03ad01acd69">https://www.jianshu.com/p/b03ad01acd69</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="其他" scheme="https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"/>
    
    
  </entry>
  
  <entry>
    <title>关于blog更新周期</title>
    <link href="https://smartxia.github.io/blog/2020/08/31/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/"/>
    <id>https://smartxia.github.io/blog/2020/08/31/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/</id>
    <published>2020-08-31T02:22:54.000Z</published>
    <updated>2021-05-17T08:01:35.525Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>每周 三篇基础知识文档编写</p><p>每两周一次总结工作情况</p><p>每月一次的软件使用教程记录</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP-辅助函数</title>
    <link href="https://smartxia.github.io/blog/2020/08/28/PHP/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"/>
    <id>https://smartxia.github.io/blog/2020/08/28/PHP/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</id>
    <published>2020-08-28T05:33:20.000Z</published>
    <updated>2021-05-17T06:39:34.399Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
  </entry>
  
  <entry>
    <title>PHP-匿名类匿名函数（闭包）</title>
    <link href="https://smartxia.github.io/blog/2020/08/28/PHP/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/"/>
    <id>https://smartxia.github.io/blog/2020/08/28/PHP/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/</id>
    <published>2020-08-28T03:31:08.000Z</published>
    <updated>2021-05-17T06:17:42.049Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4 id="1-写一个匿名函数"><a href="#1-写一个匿名函数" class="headerlink" title="1.写一个匿名函数"></a>1.写一个匿名函数</h4><blockquote><p>类中 的写法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = array_reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$result</span>, <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array_merge(<span class="variable">$result</span>, array_values(<span class="variable">$value</span>));</span><br><span class="line">        &#125;, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将匿名函数交个一个变量</span></span><br><span class="line">        <span class="variable">$a</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$result</span>, <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> array_merge(<span class="variable">$result</span>, array_values(<span class="variable">$value</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable">$result</span> = array_reduce([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], <span class="variable">$a</span>, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="2-理解一个闭包（匿名函数）"><a href="#2-理解一个闭包（匿名函数）" class="headerlink" title="2.理解一个闭包（匿名函数）"></a>2.理解一个闭包（匿名函数）</h4><p>目前php用到闭包的数组函数包括：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">array_map — 为数组的每个元素应用回调函数</span><br><span class="line">array_walk — 使用用户自定义函数对数组中的每个元素做回调处理</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">array_filter — 用回调函数过滤数组中的单元</span><br><span class="line">该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回结果数组中。数组键名保持不变。</span><br><span class="line">array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引</span><br><span class="line">array_intersect_ukey — 用回调函数比较键名来计算数组的交集</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">拼接成类似 (1,2,3,4,5) </span><br><span class="line"></span><br><span class="line">array_walk_recursive — 对数组中的每个成员递归地应用用户函数</span><br><span class="line">----等等</span><br><span class="line">常用的就是: array_map array_walk</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-临时总结"><a href="#3-临时总结" class="headerlink" title="3.临时总结"></a>3.临时总结</h4><p><strong>异同点</strong><br> array_filter() 重点在于过滤（而不是新增）某个元素，当你处理到一个元素时，返回过滤后的数组<br> array_map() 重点在于遍历一个数组或多个数组的元素，返回一个新的数组<br> array_walk() 重点在于遍历数组进行某种操作</p><p> array_filter() 和 array_walk()对一个数组进行操作，数组参数在前，函数参数在后<br> array_map() 可以处理多个数组，因此函数参数在前，数组参数在后，可以根据实际情况放入多个数组参数</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="Closure" scheme="https://smartxia.github.io/blog/tags/Closure/"/>
    
      <category term="匿名函数" scheme="https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
      <category term="匿名类" scheme="https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>PHP-运行模式cli fastcgi</title>
    <link href="https://smartxia.github.io/blog/2020/08/28/PHP/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
    <id>https://smartxia.github.io/blog/2020/08/28/PHP/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-08-28T03:31:08.000Z</published>
    <updated>2021-05-17T06:17:42.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>　　<strong>1.cgi全称“通用网关接口”(Common Gateway Interface)， 它可以让一个客户端，从浏览器向Web服务器上的程序请求数据，是客户端和程序之间传输数据的一种标准，另外CGI独立于任何语言，所以可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。CGI针对每个用户请求都要开单独的子进程去维护，执行结束处理掉这个进程。典型的fork-and-execute方式</strong></p><p>　　<strong>2.fastcgi，根据1中cgi的特性，可以知道消耗很大，如果很多用户请求，则会申请很多个子进程。。这时候出现了FastCGI。FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。这个是当下用的最多的了。。linux+nginx+php+mysql</strong></p><p>　FastCGI的工作原理是：</p><p><em>(1)、Web Server启动时载入FastCGI进程管理器【PHP的FastCGI进程管理器是PHP-FPM(php-FastCGI Process Manager)】（nginx);</em><br><em>(2)、FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自WebServer的连接。</em><br><em>(3)、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</em><br><em>(4)、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。在正常的CGI模式中，php-cgi或 .exe在此便退出了。</em><br><em>在CGI模式中，你可以想象 CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</em><br>　　<em>3.module形式一般用于apache，模块模式是以mod_php5模块的形式集成，此时mod_php5模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求，然后将处理后的结果返回给Apache。</em><br>　　<em>4.cli模式。命令行执行php，一般不用。我们在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式；也可以直接命令行执行php xxx.php</em></p><h4 id="1-php一共分为五大运行模式：包括ducgi-、fast-cgi、cli、isapi、apache-模块的-DLLCGI"><a href="#1-php一共分为五大运行模式：包括ducgi-、fast-cgi、cli、isapi、apache-模块的-DLLCGI" class="headerlink" title="1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI"></a>1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI</h4><p>  关于PHP目前比较常见的五大运行模式：</p><p>1）CGI（通用网关接口/ Common Gateway Interface）<br>2）FastCGI（常驻型CGI / Long-Live CGI）<br>3）CLI（命令行运行 / Command Line Interface）<br>4）LoadModule（Apache独有）：<br>在Apache配置文件httpd.conf里，通常加的LoadModule php7_module “D:/…/php71/php7apache2_4.dll”起到的作用就是这个<br>5）ISAPI（Internet Server Application Program Interface）<br>IIS独有：<br>备注：在PHP5.3以后，PHP不再有ISAPI模式，安装后也不再有php5isapi.dll这个文件。要在IIS6上使用高版本PHP，必须安装FastCGI 扩展，然后使IIS6支持FastCGI。  </p><h3 id="2、php-cli-与php-fpm（fastcgi-process-manager）"><a href="#2、php-cli-与php-fpm（fastcgi-process-manager）" class="headerlink" title="2、php-cli 与php-fpm（fastcgi process manager）"></a>2、php-cli 与php-fpm（fastcgi process manager）</h3><p><img src= "/blog/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20190420173441325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbnFpYW45OTk=,size_16,color_FFFFFF,t_70" alt="[**CGI、FastCGI和PHP-FPM关系图解**](https://www.awaimai.com/371.html)"></p><p>cli 模式就是常见的命令使用的php命令，其实他也可以提供http请求服务，内置了http服务器<br>fpm 是一个多进程架构的FastCgi 服务，内置PHP解释器进程常驻后台，自带进程管理支持进程池配置和配置Nginx使用</p><p>cli 和fpm 是两个运行方式 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\blog\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\blog\assets\js\APlayer.m
      
    
    </summary>
    
    
      <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
      <category term="cgi" scheme="https://smartxia.github.io/blog/tags/cgi/"/>
    
      <category term="fastcgi" scheme="https://smartxia.github.io/blog/tags/fastcgi/"/>
    
      <category term="cli" scheme="https://smartxia.github.io/blog/tags/cli/"/>
    
  </entry>
  
</feed>
