{"meta":{"title":"Some","subtitle":"https://smartxia.github.io/blog","description":"以地事秦 犹抱薪救火 薪不尽 火不灭","author":"夏夏天","url":"https://smartxia.github.io/blog","root":"/blog/"},"pages":[{"title":"about","date":"2019-12-17T08:04:45.000Z","updated":"2021-04-26T03:47:04.611Z","comments":false,"path":"about/index.html","permalink":"https://smartxia.github.io/blog/about/index.html","excerpt":"","text":"关于我自己"},{"title":"友情链接","date":"2019-12-25T07:28:57.000Z","updated":"2021-04-26T03:47:04.617Z","comments":true,"path":"link/index.html","permalink":"https://smartxia.github.io/blog/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2019-12-25T07:28:57.000Z","updated":"2021-04-26T03:47:04.620Z","comments":true,"path":"messageboard/index.html","permalink":"https://smartxia.github.io/blog/messageboard/index.html","excerpt":"","text":"有什麽想説的？ 有什麽想問的？ 有什麽想吐槽的？ 可以在下面留言..."},{"title":"music","date":"2019-12-19T11:18:41.000Z","updated":"2021-04-26T03:47:04.622Z","comments":false,"path":"music/index.html","permalink":"https://smartxia.github.io/blog/music/index.html","excerpt":"","text":"聆听这个世界 OH MY GIRL"},{"title":"记录这个世界","date":"2019-12-25T07:29:38.000Z","updated":"2021-04-26T03:47:04.625Z","comments":false,"path":"photos/index.html","permalink":"https://smartxia.github.io/blog/photos/index.html","excerpt":"","text":"IMG_0556.jpg67580923_163885094733558_2732488031818814501_n.jpgIMG_0472.jpgIMG_0453.jpgIMG_0931.jpgIMG_0523.jpgIMG_0264.jpgIMG_0337.jpgIMG_0515.jpgIMG_0393.jpgIMG_0501.jpgIMG_0328.jpgIMG_0262.jpgIMG_0338.jpgIMG_0915.jpgIMG_0414.jpgIMG_0911.jpgIMG_0906.jpgIMG_0354.jpgIMG_0251.jpgIMG_0925.jpgIMG_0406.jpgIMG_0908.jpgIMG_0415.jpgIMG_0521.jpgIMG_0910.jpgIMG_0060.jpgIMG_0054.jpgIMG_0491.jpgIMG_0913.jpgIMG_0164.jpgIMG_9924.jpgIMG_0398.jpgIMG_0920.jpgIMG_0409.jpgIMG_0451.jpgIMG_9919.jpgIMG_0052.jpgIMG_0191.JPGIMG_9911.jpgIMG_9909.jpgIMG_0937.jpgIMG_9915.jpgIMG_0159.jpgIMG_9912.jpgIMG_0156.jpgIMG_0043.jpgIMG_0917.jpgIMG_0048.jpgIMG_0916.jpg"},{"title":"schedule","date":"2019-12-17T09:13:54.000Z","updated":"2021-04-26T03:47:04.628Z","comments":true,"path":"schedule/index.html","permalink":"https://smartxia.github.io/blog/schedule/index.html","excerpt":"","text":"http://help.bj.cn/这个网站用于生成站点地图"},{"title":"sitemap","date":"2019-12-17T09:12:43.000Z","updated":"2021-04-26T03:47:04.631Z","comments":true,"path":"sitemap/index.html","permalink":"https://smartxia.github.io/blog/sitemap/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-12-17T08:05:10.000Z","updated":"2021-04-26T03:47:04.634Z","comments":false,"path":"tags/index.html","permalink":"https://smartxia.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"GOLANG-笔记-ArrayMapSlice","slug":"GOLANG-笔记3","date":"2021-04-26T03:47:04.546Z","updated":"2021-04-29T06:33:17.919Z","comments":true,"path":"2021/04/26/GOLANG-笔记3/","link":"","permalink":"https://smartxia.github.io/blog/2021/04/26/GOLANG-%E7%AC%94%E8%AE%B03/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253### 1. :&#x3D; &#x3D; &#x3D;&#x3D;:&#x3D; 给某变量的第一次赋值，初始化&#x3D; 变量的非第一次赋值&#x3D;&#x3D; 等于操作符### 2. go中nil的使用指针、切片、映射、通道、函数和接口的零值则是 nil。- nil 标识符是不能比较的- nil 不是关键字或保留字- nil 没有默认类型- 不同类型 nil 的指针是一样的- 不同类型的 nil 是不能比较的- 两个相同类型的 nil 值也可能无法比较- nil 是 map、slice、pointer、channel、func、interface 的零值- 不同类型的 nil 值占用的内存大小可能是不一样的### 3.切片 slice类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:slice1 :&#x3D; make([]type, len)len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)### 4.集合 mapmap 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type- 使用 make 函数 map_val :&#x3D; make(map[key_data_type]value_data_type)### 并发goroutine go sync()### 通道 channel既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。使用 make 创建 channel，如下：​&#96;&#96;&#96;ch :&#x3D; make(chan int, 100) &#x2F;&#x2F; make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道ch &lt;- v &#x2F;&#x2F; 把 v 发送到通道 chv :&#x3D; &lt;-ch &#x2F;&#x2F; 从 ch 接收数据&#x2F;&#x2F; 并把值赋给 v​&#96;&#96;&#96;通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。","categories":[{"name":"golang","slug":"golang","permalink":"https://smartxia.github.io/blog/categories/golang/"}],"tags":[{"name":"Slice","slug":"Slice","permalink":"https://smartxia.github.io/blog/tags/Slice/"}]},{"title":"PHP-解决循环内存占用溢出-缓冲查询","slug":"PHP-解决循环内存占用溢出-缓冲查询","date":"2020-09-02T06:50:51.000Z","updated":"2021-04-29T09:15:32.152Z","comments":true,"path":"2020/09/02/PHP-解决循环内存占用溢出-缓冲查询/","link":"","permalink":"https://smartxia.github.io/blog/2020/09/02/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"PHP-深拷贝浅拷贝","slug":"PHP-深拷贝浅拷贝","date":"2020-09-02T06:50:07.000Z","updated":"2021-04-29T09:15:32.152Z","comments":true,"path":"2020/09/02/PHP-深拷贝浅拷贝/","link":"","permalink":"https://smartxia.github.io/blog/2020/09/02/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Git-代码提交规范","slug":"Git-代码提交规范","date":"2020-09-02T06:13:27.000Z","updated":"2021-04-29T09:15:35.782Z","comments":true,"path":"2020/09/02/Git-代码提交规范/","link":"","permalink":"https://smartxia.github.io/blog/2020/09/02/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/","excerpt":"","text":"Git commit message 是Git提交的必要信息，message的信息完整度也反映了工程师对于代码提交的重视程度，不清晰的git message信息甚至会让工程师完全回忆不起自己当初做了什么调整，导致后续代码维护成本特别大。因此为了提高线上代码库的管理程度，特此制定GIT commit message规范。 一、commit message格式1、Type(必须)用于说明 git commit 的类别，只允许使用下面的标识。feat：新功能（feature）。fix/to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。fix：产⽣diff并自动修复此问题。适合于一次提交直接修复问题to：只产⽣diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fixdocs：文档（documentation）。style：格式（不影响代码运行的变动）。refactor：重构（即不是新增功能，也不是修改bug的代码变动）。perf：优化相关，比如提升性能、体验。test：增加测试。chore：构建过程或辅助工具的变动。revert：回滚到上一个版本。merge：代码合并。sync：同步主线或分⽀的Bug 2、scope(可选)scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。如果你的修改影响了不止一个scope，你可以使用*代替。 3、subject(必须)subject是commit目的的简短描述，不超过50个字符。1.建议使用中文。2.结尾不加句号或其他标点符号。根据以上规范 git commit message 将是如下的格式：fix(DAO): 用户查询缺少username属性feat(Controller): 用户查询接口开发 二、规范的好处我们这样规范git commit到底有哪些好处呢？1.便于程序员对提交历史进行追溯，了解发⽣了什么情况。2.一旦约束了commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个git commit里面，这样一来整个代码改动的历史也将更加清晰。3.格式化的commit message才可以用于自动化输出Change log。 三、标准执行监管为了更好的执行标准，公司针对git提交会进行相关监管功能的研发，当工程师提了不合规的commit，会收到相关的邮件警告。","categories":[],"tags":[]},{"title":"前端-npm私有源加载平台","slug":"前端-npm私有源加载平台","date":"2020-09-01T09:30:06.000Z","updated":"2021-04-29T06:32:47.989Z","comments":true,"path":"2020/09/01/前端-npm私有源加载平台/","link":"","permalink":"https://smartxia.github.io/blog/2020/09/01/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/","excerpt":"","text":"调研平台：sinopia，VerdaccioVerdaccio官方文档https://verdaccio.org/docs/en/configuration 搭建： 认证方式身份验证与您正在使用的auth 插件相关。软件包限制也由Package Access处理。 客户端：基于npm客户端登录后会生成一个配置令牌，在.npmrc中 https://docs.npmjs.com/files/npmrc 且允许匿名发布包 包发布的时候允许阻止访问和下载 服务端关于组的验证: ​ access: $all-&gt;​ publish: $all​ proxy: npmjs 不同的包读取权限限制： 1234567891011121314packages: &#x27;jquery&#x27;: access: $all publish: $all &#x27;my-company-*&#x27;: access: $all publish: $authenticated &#x27;@my-local-scope/*&#x27;: access: $all publish: $authenticated &#x27;**&#x27;: access: $all publish: $authenticated proxy: npmjs 组 定义： 12345678&#39;company-*&#39;: access: admin internal publish: admin proxy: server1&#39;supersecret-*&#39;: access: secret super-secret-area ultra-secret-area publish: secret ultra-secret-area proxy: server1","categories":[],"tags":[]},{"title":"其他-CRLF、CR、LF详解","slug":"其他-CRLF、CR、LF详解","date":"2020-09-01T06:42:31.000Z","updated":"2021-04-26T03:47:04.586Z","comments":true,"path":"2020/09/01/其他-CRLF、CR、LF详解/","link":"","permalink":"https://smartxia.github.io/blog/2020/09/01/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"很长一段时间里，对于CRLF、CR、LF的理解仅限于不同操作系统下对换行符的定义。所谓知其然需知其所以然，从学习中找到乐趣，对知识的记忆才会更加深刻。 名词解释CR：Carriage Return，对应ASCII中转义字符\\r，表示回车LF：Linefeed，对应ASCII中转义字符\\n，表示换行CRLF：Carriage Return &amp; Linefeed，\\r\\n，表示回车并换行众所周知，Windows操作系统采用两个字符来进行换行，即CRLF；Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行；另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。 野史老式机械打字机（来源：视觉中国）据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。 当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。 随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。 结论许多现代的文本编辑器和命令行工具都提供了可选择的换行符配置，方便用户按照自己的意愿来改变换行符的表现形式，所以我们只需要知道CRLF、CR、LF的作用即可。 参考文献http://en.wikipedia.org/wiki/Newlinehttps://en.wikipedia.org/wiki/Control_characterhttps://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types 作者：JSoon链接：https://www.jianshu.com/p/b03ad01acd69来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[]},{"title":"关于blog更新周期","slug":"关于blog更新周期","date":"2020-08-31T02:22:54.000Z","updated":"2021-04-26T03:47:04.583Z","comments":true,"path":"2020/08/31/关于blog更新周期/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/31/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/","excerpt":"","text":"每周 三篇基础知识文档编写 每两周一次总结工作情况 每月一次的软件使用教程记录","categories":[],"tags":[]},{"title":"PHP-辅助函数","slug":"PHP-辅助函数","date":"2020-08-28T05:33:20.000Z","updated":"2021-04-29T09:15:32.134Z","comments":true,"path":"2020/08/28/PHP-辅助函数/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/28/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"PHP-匿名类匿名函数（闭包）","slug":"PHP-匿名类匿名函数（闭包）","date":"2020-08-28T03:31:08.000Z","updated":"2021-04-29T09:15:32.134Z","comments":true,"path":"2020/08/28/PHP-匿名类匿名函数（闭包）/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/28/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/","excerpt":"","text":"1.写一个匿名函数 类中 的写法 123456789101112131415161718//第一种写法 public function qq() &#123; $result = array_reduce([1, 2, 3, 4, 1], function ($result, $value) &#123; return array_merge($result, array_values($value)); &#125;, array()); return $result; &#125;//第二种写法 public function qq2() &#123; //将匿名函数交个一个变量 $a = function ($result, $value) &#123; return array_merge($result, array_values($value)); &#125;; $result = array_reduce([1, 2, 3, 4, 1], $a, array()); return $result; &#125; 2.理解一个闭包（匿名函数）目前php用到闭包的数组函数包括： 1234567891011121314array_map — 为数组的每个元素应用回调函数array_walk — 使用用户自定义函数对数组中的每个元素做回调处理array_reduce — 用回调函数迭代地将数组简化为单一的值array_filter — 用回调函数过滤数组中的单元该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回结果数组中。数组键名保持不变。array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引array_intersect_ukey — 用回调函数比较键名来计算数组的交集array_reduce — 用回调函数迭代地将数组简化为单一的值拼接成类似 (1,2,3,4,5) array_walk_recursive — 对数组中的每个成员递归地应用用户函数----等等常用的就是: array_map array_walk 3.临时总结异同点 array_filter() 重点在于过滤（而不是新增）某个元素，当你处理到一个元素时，返回过滤后的数组 array_map() 重点在于遍历一个数组或多个数组的元素，返回一个新的数组 array_walk() 重点在于遍历数组进行某种操作 array_filter() 和 array_walk()对一个数组进行操作，数组参数在前，函数参数在后 array_map() 可以处理多个数组，因此函数参数在前，数组参数在后，可以根据实际情况放入多个数组参数","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"Closure","slug":"Closure","permalink":"https://smartxia.github.io/blog/tags/Closure/"},{"name":"匿名函数","slug":"匿名函数","permalink":"https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"name":"匿名类","slug":"匿名类","permalink":"https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E7%B1%BB/"}]},{"title":"PHP-运行模式cli fastcgi","slug":"PHP-运行模式","date":"2020-08-28T03:31:08.000Z","updated":"2021-04-29T06:35:10.368Z","comments":true,"path":"2020/08/28/PHP-运行模式/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/28/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"1.cgi全称“通用网关接口”(Common Gateway Interface)， 它可以让一个客户端，从浏览器向Web服务器上的程序请求数据，是客户端和程序之间传输数据的一种标准，另外CGI独立于任何语言，所以可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。CGI针对每个用户请求都要开单独的子进程去维护，执行结束处理掉这个进程。典型的fork-and-execute方式 2.fastcgi，根据1中cgi的特性，可以知道消耗很大，如果很多用户请求，则会申请很多个子进程。。这时候出现了FastCGI。FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。这个是当下用的最多的了。。linux+nginx+php+mysql FastCGI的工作原理是： (1)、Web Server启动时载入FastCGI进程管理器【PHP的FastCGI进程管理器是PHP-FPM(php-FastCGI Process Manager)】（nginx);(2)、FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自WebServer的连接。(3)、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。(4)、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。在正常的CGI模式中，php-cgi或 .exe在此便退出了。在CGI模式中，你可以想象 CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。 3.module形式一般用于apache，模块模式是以mod_php5模块的形式集成，此时mod_php5模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求，然后将处理后的结果返回给Apache。 4.cli模式。命令行执行php，一般不用。我们在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式；也可以直接命令行执行php xxx.php 1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI 关于PHP目前比较常见的五大运行模式： 1）CGI（通用网关接口/ Common Gateway Interface）2）FastCGI（常驻型CGI / Long-Live CGI）3）CLI（命令行运行 / Command Line Interface）4）LoadModule（Apache独有）：在Apache配置文件httpd.conf里，通常加的LoadModule php7_module “D:/…/php71/php7apache2_4.dll”起到的作用就是这个5）ISAPI（Internet Server Application Program Interface）IIS独有：备注：在PHP5.3以后，PHP不再有ISAPI模式，安装后也不再有php5isapi.dll这个文件。要在IIS6上使用高版本PHP，必须安装FastCGI 扩展，然后使IIS6支持FastCGI。 2、php-cli 与php-fpm（fastcgi process manager） cli 模式就是常见的命令使用的php命令，其实他也可以提供http请求服务，内置了http服务器fpm 是一个多进程架构的FastCgi 服务，内置PHP解释器进程常驻后台，自带进程管理支持进程池配置和配置Nginx使用 cli 和fpm 是两个运行方式","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"cgi","slug":"cgi","permalink":"https://smartxia.github.io/blog/tags/cgi/"},{"name":"fastcgi","slug":"fastcgi","permalink":"https://smartxia.github.io/blog/tags/fastcgi/"},{"name":"cli","slug":"cli","permalink":"https://smartxia.github.io/blog/tags/cli/"}]},{"title":"PHP-理解php的Generator,yield,Iterator接口","slug":"PHP-理解php的Generator,yield,Iterator接口","date":"2020-08-28T03:21:32.000Z","updated":"2021-04-29T09:15:32.134Z","comments":true,"path":"2020/08/28/PHP-理解php的Generator,yield,Iterator接口/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/28/PHP-%E7%90%86%E8%A7%A3php%E7%9A%84Generator,yield,Iterator%E6%8E%A5%E5%8F%A3/","excerpt":"","text":"等待更新yield解决读取大文","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"Generator","slug":"Generator","permalink":"https://smartxia.github.io/blog/tags/Generator/"},{"name":"yield","slug":"yield","permalink":"https://smartxia.github.io/blog/tags/yield/"},{"name":"Iterator - 等待更新","slug":"Iterator-等待更新","permalink":"https://smartxia.github.io/blog/tags/Iterator-%E7%AD%89%E5%BE%85%E6%9B%B4%E6%96%B0/"}]},{"title":"其他-server酱打卡网易云","slug":"其他-Server酱打卡网易云 小技巧","date":"2020-08-26T01:57:49.000Z","updated":"2021-04-29T06:32:44.168Z","comments":true,"path":"2020/08/26/其他-Server酱打卡网易云 小技巧/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/26/%E5%85%B6%E4%BB%96-Server%E9%85%B1%E6%89%93%E5%8D%A1%E7%BD%91%E6%98%93%E4%BA%91%20%E5%B0%8F%E6%8A%80%E5%B7%A7/","excerpt":"","text":"等待更新","categories":[{"name":"其他","slug":"其他","permalink":"https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"网易云 server酱 py 云函数  待更新","slug":"网易云-server酱-py-云函数-待更新","permalink":"https://smartxia.github.io/blog/tags/%E7%BD%91%E6%98%93%E4%BA%91-server%E9%85%B1-py-%E4%BA%91%E5%87%BD%E6%95%B0-%E5%BE%85%E6%9B%B4%E6%96%B0/"}]},{"title":"Docker-info","slug":"Docker-制作-1","date":"2020-08-20T09:18:43.000Z","updated":"2021-04-26T03:47:04.541Z","comments":true,"path":"2020/08/20/Docker-制作-1/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/20/Docker-%E5%88%B6%E4%BD%9C-1/","excerpt":"","text":"注册登录https://hub.docker.com/ Docker快捷键 常用： start restart stop images ps-a 带有参数的使用docker ps -a ：查看最近使用的容器id docker rm 容器id:删除某个容器 docker images docker rmi 镜像id:删除某个镜像 docker run : docker run -d -p 9200:9200 -p 5601:5601 nshou/elasticsearch-kibana -d 后台运行，-p 内部端口/宿主机端口 容器id docker exec -it /bash :进入容器 docker login -u xx -p xxx：登录 配置加速源1.阿里云：百度如何通过阿里云加速docker拉取和推送速度 2.DaoCloud ：大公司，国内的。网站：https://www.daocloud.io/mirror 加速url 1Linux:curl -sSL https:&#x2F;&#x2F;get.daocloud.io&#x2F;daotools&#x2F;set_mirror.sh | sh -s http:&#x2F;&#x2F;f1361db2.m.daocloud.io 原理：编辑 /etc/docker/daemon.json 这个文件夹 1&#123;&quot;registry-mirrors&quot;: [&quot;http:&#x2F;&#x2F;f1361db2.m.daocloud.io&quot;,&quot;https:&#x2F;&#x2F;vbw6t0eb.mirror.aliyuncs.com&quot;]&#125; 查看当前docker配置文件docker info :可以查看是否配置成功加速 版本信息等各种信息 打包镜像源和推送到docker.io1.docker pull xxx镜像:tag 2.docker images 查看镜像 3.docker run -d -p 8080:8081 xxx镜像:version 4.docker ps -a 查看是不是启动了，然后stop start restart 找找感觉 5.docker exec -it 镜像id bash :进入镜像进行修改：拉代码，查bug ,增加mysql实例等 6.docker commit -m “php71-daemon:xhprof-graphviz” -a “some” f69187b4375e “18260356308/php71-daemon:xhprof” ​ docker commit -m “提交log” -a “作者” 容器id “docker账户名/自定义镜像名：tag” 就会制作成一个新的image了 7.执行docker push xxx镜像的id： tips: 前提是得登录，还有 注意一个问题,给自己镜像命名的时候格式应该是: docker注册用户名/镜像名,比如我的docker用户名为 test123,那么我的镜像tag就为 test123/whalesay,不然是push不上去的","categories":[{"name":"DOCKER","slug":"DOCKER","permalink":"https://smartxia.github.io/blog/categories/DOCKER/"}],"tags":[{"name":"docekr images","slug":"docekr-images","permalink":"https://smartxia.github.io/blog/tags/docekr-images/"}]},{"title":"PHP-xhprof-性能优化","slug":"PHP-xhprof-性能优化","date":"2020-08-20T09:16:14.000Z","updated":"2021-04-29T06:35:33.831Z","comments":true,"path":"2020/08/20/PHP-xhprof-性能优化/","link":"","permalink":"https://smartxia.github.io/blog/2020/08/20/PHP-xhprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/","excerpt":"","text":"简介 安装 嵌入代码 查看分析报告 总结 名词解释Function Name：方法名称。 Calls：方法被调用的次数。 Calls%：方法调用次数在同级方法总数调用次数中所占的百分比。 Incl.Wall Time(microsec)：方法执行花费的时间，包括子方法的执行时间。（单位：微秒） IWall%：方法执行花费的时间百分比。 Excl. Wall Time(microsec)：方法本身执行花费的时间，不包括子方法的执行时间。（单位：微秒） EWall%：方法本身执行花费的时间百分比。 Incl. CPU(microsecs)：方法执行花费的CPU时间，包括子方法的执行时间。（单位：微秒） ICpu%：方法执行花费的CPU时间百分比。 Excl. CPU(microsec)：方法本身执行花费的CPU时间，不包括子方法的执行时间。（单位：微秒） ECPU%：方法本身执行花费的CPU时间百分比。 Incl.MemUse(bytes)：方法执行占用的内存，包括子方法执行占用的内存。（单位：字节） IMemUse%：方法执行占用的内存百分比。 Excl.MemUse(bytes)：方法本身执行占用的内存，不包括子方法执行占用的内存。（单位：字节） EMemUse%：方法本身执行占用的内存百分比。 Incl.PeakMemUse(bytes)：Incl.MemUse峰值。（单位：字节） IPeakMemUse%：Incl.MemUse峰值百分比。 Excl.PeakMemUse(bytes)：Excl.MemUse峰值。单位：（字节） EPeakMemUse%：Excl.MemUse峰值百分比。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"xhprof docker push","slug":"xhprof-docker-push","permalink":"https://smartxia.github.io/blog/tags/xhprof-docker-push/"}]},{"title":"GOLANG-笔记-ArrayMapSlice","slug":"GOLANG-笔记2-ArrayMapSlice","date":"2020-06-29T11:17:32.000Z","updated":"2021-04-29T06:33:14.220Z","comments":true,"path":"2020/06/29/GOLANG-笔记2-ArrayMapSlice/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/29/GOLANG-%E7%AC%94%E8%AE%B02-ArrayMapSlice/","excerpt":"","text":"Array(数组)内部机制在 Go 语言中数组是固定长度的数据类型，它包含相同类型的连续的元素，这些元素可以是内建类型，像数字和字符串，也可以是结构类型，元素可以通过唯一的索引值访问，从 0 开始。 数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。 总结数组是 slice 和 map 的底层结构。slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。slice 有容量的约束，不过可以通过内建函数 append 来增加元素。map 没有容量一说，所以也没有任何增长限制。内建函数 len 可以用来获得 slice 和 map 的长度。内建函数 cap 只能作用在 slice 上。可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。","categories":[{"name":"golang","slug":"golang","permalink":"https://smartxia.github.io/blog/categories/golang/"}],"tags":[{"name":"Slice","slug":"Slice","permalink":"https://smartxia.github.io/blog/tags/Slice/"}]},{"title":"PHP-SPL(数据结构)","slug":"PHP-SPL(数据结构)","date":"2020-06-23T10:04:39.000Z","updated":"2021-04-29T06:35:14.462Z","comments":true,"path":"2020/06/23/PHP-SPL(数据结构)/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/23/PHP-SPL(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/","excerpt":"","text":"php SPL四种常用的数据结构1.栈【先进后出】 123456789&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$stack &#x3D; new SplStack();$stack-&gt;push(&#39;data1&#39;);$stack-&gt;push(&#39;data2&#39;);$stack-&gt;push(&#39;data3&#39;);echo $stack-&gt;pop(); &#x2F;&#x2F;输出结果为&#x2F;&#x2F;data3&lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;font-size:24px;font-weight: bold;&quot;&gt;&lt;&#x2F;span&gt; 2.队列【先进先出 后进后出】 1234567&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$queue &#x3D; new SplQueue();$queue-&gt;enqueue(&quot;data1&quot;);$queue-&gt;enqueue(&quot;data2&quot;);$queue-&gt;enqueue(&quot;data3&quot;);echo $queue-&gt;dequeue();&#x2F;&#x2F;输出结果为&#x2F;&#x2F;data1&lt;&#x2F;span&gt; 3.堆 123456&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$heap &#x3D; new SplMinHeap();$heap-&gt;insert(&quot;data1&quot;);$heap-&gt;insert(&quot;data2&quot;);echo $heap-&gt;extract();&#x2F;&#x2F;输出结果为&#x2F;&#x2F;data1&lt;&#x2F;span&gt; 4.固定尺寸数组 1234567891011&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$array &#x3D; new SplFixedArray(5);$array[0]&#x3D;1;$array[3]&#x3D;3;$array[2]&#x3D;2;var_dump($array);&#x2F;&#x2F;输出结果为&#x2F;&#x2F; object(SplFixedArray)[1]&#x2F;&#x2F; public 0 &#x3D;&gt; int 1&#x2F;&#x2F; public 1 &#x3D;&gt; null&#x2F;&#x2F; public 2 &#x3D;&gt; int 2&#x2F;&#x2F; public 3 &#x3D;&gt; int 3 ————————————————推荐学习：http://www.imooc.com/video/4849原文链接：https://blog.csdn.net/zhengwish/article/details/51742264","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/tags/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://smartxia.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"PHP-SPL(数据结构)","slug":"PHP-Use-使用场景","date":"2020-06-23T10:04:39.000Z","updated":"2021-04-29T06:35:21.691Z","comments":true,"path":"2020/06/23/PHP-Use-使用场景/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/23/PHP-Use-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/","excerpt":"","text":"php SPL四种常用的数据结构1.栈【先进后出】PHP-Use-使用场景 123456789&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$stack &#x3D; new SplStack();$stack-&gt;push(&#39;data1&#39;);$stack-&gt;push(&#39;data2&#39;);$stack-&gt;push(&#39;data3&#39;);echo $stack-&gt;pop(); &#x2F;&#x2F;输出结果为&#x2F;&#x2F;data3&lt;&#x2F;span&gt;&lt;span style&#x3D;&quot;font-size:24px;font-weight: bold;&quot;&gt;&lt;&#x2F;span&gt; 2.队列【先进先出 后进后出】 1234567&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$queue &#x3D; new SplQueue();$queue-&gt;enqueue(&quot;data1&quot;);$queue-&gt;enqueue(&quot;data2&quot;);$queue-&gt;enqueue(&quot;data3&quot;);echo $queue-&gt;dequeue();&#x2F;&#x2F;输出结果为&#x2F;&#x2F;data1&lt;&#x2F;span&gt; 3.堆 123456&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$heap &#x3D; new SplMinHeap();$heap-&gt;insert(&quot;data1&quot;);$heap-&gt;insert(&quot;data2&quot;);echo $heap-&gt;extract();&#x2F;&#x2F;输出结果为&#x2F;&#x2F;data1&lt;&#x2F;span&gt; 4.固定尺寸数组 1234567891011&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;$array &#x3D; new SplFixedArray(5);$array[0]&#x3D;1;$array[3]&#x3D;3;$array[2]&#x3D;2;var_dump($array);&#x2F;&#x2F;输出结果为&#x2F;&#x2F; object(SplFixedArray)[1]&#x2F;&#x2F; public 0 &#x3D;&gt; int 1&#x2F;&#x2F; public 1 &#x3D;&gt; null&#x2F;&#x2F; public 2 &#x3D;&gt; int 2&#x2F;&#x2F; public 3 &#x3D;&gt; int 3 ————————————————推荐学习：http://www.imooc.com/video/4849原文链接：https://blog.csdn.net/zhengwish/article/details/51742264","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/tags/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://smartxia.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"PHP-use","slug":"PHP-use","date":"2020-06-23T10:04:39.000Z","updated":"2021-04-29T06:35:28.661Z","comments":true,"path":"2020/06/23/PHP-use/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/23/PHP-use/","excerpt":"","text":"php use用法 1、user namespace2、use 一个trait针对于trait的即多继承 12345678910trait A&#123; eat()&#125; trait B&#123; drink()&#125; class C &#123; use A; use B; &#125;public Class D&#123;d=new Class C()d-&gt;eat();&#125; 当不同的trait中，却有着同名的方法或属性，会产生冲突，可以使用insteadof或 as进行解决，insteadof 是进行替代，而as是给它取别名 123456use trait1,trait2&#123; trait1::eat insteadof trait2; trait1::drive insteadof trait2; trait2::eat as eaten; trait2::drive as driven; &#125; 3.闭包-&gt;匿名函数好处：节省内存 适合做回调函数 匿名函数：定义时未定义函数的名称闭包： 创建时封装周围状态的函数，及时周围的环境不存在了，闭包中的状态还会存在 使用法则：","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/tags/PHP/"},{"name":"USE","slug":"USE","permalink":"https://smartxia.github.io/blog/tags/USE/"}]},{"title":"PHP-strlen与mb_strlen","slug":"PHP-strlen与mb-strlen","date":"2020-06-22T11:11:39.000Z","updated":"2021-04-29T06:35:17.919Z","comments":true,"path":"2020/06/22/PHP-strlen与mb-strlen/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/22/PHP-strlen%E4%B8%8Emb-strlen/","excerpt":"","text":"在PHP中，strlen与mb_strlen是求字符串长度的函数PHP内置的字符串长度函数strlen无法正确处理中文字符串，它得到的只是字符串所占的字节数。对于GB2312的中文编码，strlen得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍（在 UTF-8编码下，一个汉字占3个字节）。 采用mb_strlen函数可以较好地解决这个问题。mb_strlen的用法和strlen类似，只不过它有第二个可选参数用于指定字符编码。例如得到UTF-8的字符串str长度，可以用mbstrlen(str长度，可以用mbstrlen(str,‘UTF-8’)。如果省略第二个参数，则会使用PHP的内部编码。内部编码可以通过 mb_internal_encoding()函数得到。 需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即确保“extension=php_mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。 在strlen计算中，对待一个UTF8的中文字符，处理为3个字节长度，所以为3+1+2+1+9=16个 当mb_strlen的内码选择为UTF-8的时候，则会将中文字符当成一个字符,所以为3+1+2+1+3=10; 当mb_strlen的内码选择为gbk的时候，一个中文字符当成1.5个字符来处理来处理,最后就是:3+1+2+1+4.5=11.5 函数：mb_internal_encoding()会得到当前PHP使用的内部编码 strlen,得到的是字符串所占的字节数，所以在查看一个字符串的长度的时候，strlen并不能得到我们需要的真实值 mb_strlen 函数可以很好的处理这一点 注意：mb_strlen函数并不是php的核心函数，只是PHP的一个扩展函数，使用之前要判断是否加在的mbstring扩展模块，在Php.ini文件中可以查看相关配置 strlen结果为什么是4strlen在遇到第一个\\0时结束，后面的字符无视。","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/tags/PHP/"},{"name":"strlen","slug":"strlen","permalink":"https://smartxia.github.io/blog/tags/strlen/"}]},{"title":"其他-科学上网","slug":"其他-科学上网","date":"2020-06-22T07:57:49.000Z","updated":"2021-04-29T06:32:34.454Z","comments":true,"path":"2020/06/22/其他-科学上网/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/22/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/","excerpt":"","text":"解决System.Reflection.TargetInvocationException: 调用的目标发生了异常。 windows7系统运行没有问题，但是放到Windows10 上面就出现连接不上的问题，试了很多种方法还是这种解决了。 问题： System.Reflection.TargetInvocationException: 调用的目标发生了异常。 —&gt; System.Reflection.TargetInvocationException: 调用的目标发生了异常。 —&gt; System.InvalidOperationException: 此实现不是 Windows 平台 FIPS 验证的加密算法的一部分 解决办法：需要修改注册表,cmd命令，输入regedit打开注册表然后找到以下路径 KEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\FipsAlgorithmPolicy 修改此路径下的Enable值为1，然后重新打开shadowsocks，大功告成！记得重启ssr （如果1不行那就切换成0） ————————————————原文链接：https://blog.csdn.net/qq_27536941/article/details/103300646","categories":[{"name":"其他","slug":"其他","permalink":"https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"ssr","slug":"ssr","permalink":"https://smartxia.github.io/blog/tags/ssr/"}]},{"title":"PHP-异常类","slug":"PHP-异常类","date":"2020-06-22T03:27:10.000Z","updated":"2021-04-29T06:35:03.439Z","comments":true,"path":"2020/06/22/PHP-异常类/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/22/PHP-%E5%BC%82%E5%B8%B8%E7%B1%BB/","excerpt":"","text":"PHP 异常与错误 —— ThrowableThrowable 官方文档地址： http://php.net/manual/en/class.throwable.php PHP 支持版本： 7 PHP7 异常与错误处理机制 Exception, Error, ThrowableThrowable 是 PHP 7 中可以用作任何对象抛出声明的基本接口，包括 Expection （异常）和 Error （错误）。 1234567891011121314151617181920Throwable &#123; &#x2F;* 抽象方法 *&#x2F; abstract public string getMessage ( void ) &#x2F;&#x2F; 获取抛出的消息内容 abstract public int getCode ( void ) &#x2F;&#x2F; 获取抛出的错误代码 abstract public string getFile ( void ) &#x2F;&#x2F; 获取产生异常的文件名 abstract public int getLine ( void ) &#x2F;&#x2F; 获取相关行号 abstract public array getTrace ( void ) &#x2F;&#x2F; 获取追踪信息，返回数组形式 abstract public string getTraceAsString ( void ) &#x2F;&#x2F; 获取追踪信息，返回字符串形式 abstract public Throwable getPrevious ( void ) &#x2F;&#x2F; 返回上一个 Throwable abstract public string __toString ( void ) &#x2F;&#x2F; 抛出的对象以字符串形式返回，可以用 echo 打印相应结果&#125; 请一定要注意，没有特殊说明：本例 PHP Version &lt; 7 说起 PHP 异常处理，大家首先会想到 try-catch，那好，我们先看一段程序吧：有一个 test.php 文件，有一段简单的 PHP 程序，内容如下，然后命令行执行：php test.php 1234567891 &lt;?php2 $num &#x3D; 0;3 try &#123;4 echo 1&#x2F;$num;56 &#125; catch (Exception $e)&#123;7 echo $e-&gt;getMessage();8 &#125;9 ?&gt; 我的问题是：这段程序能正确的捕捉到除 0 的错误信息吗？ 如果你回答能，那你就把这篇文章看完吧！应该能学点东西。 本文章分 5 个部分介绍我的异常处理的理解： 一、异常与错误的概述 二、ERROR 的级别 三、PHP 异常处理中的黑科技 四、巧妙的捕获错误和异常 五、自定义异常处理和异常嵌套 六、PHP7 中的异常处理 一、异常与错误的概述 PHP 中什么是异常： 程序在运行中出现不符合预期的情况，允许发生（你也不想让他出现不正常的情况）但他是一种不正常的情况，按照我们的正常逻辑本不该出的错误，但仍然会出现的错误，属于逻辑和业务流程的错误，而不是编译或者语法上的错误。 PHP 中什么是错误： 属于 php 脚本自身的问题，大部分情况是由错误的语法，服务器环境导致，使得编译器无法通过检查，甚至无法运行的情况。warning、notice 都是错误，只是他们的级别不同而已，并且错误是不能被 try-catch 捕获的。 上面的说法是有前提条件的： 在 PHP 中，因为在其他语言中就不能这样下结论了，也就是说异常和错误的说法在不同的语言有不同的说法。在 PHP 中任何自身的错误或者是非正常的代码都会当做错误对待，并不会以异常的形式抛出，但是也有一些情况会当做异常和错误同时抛出(据说是，我没有找到合适的例子)。也就是说，你想在数据库连接失败的时候自动捕获异常是行不通的，因为这就不是异常，是错误。但是在 java 中就不一样了，他会把很多和预期不一致的行为当做异常来进行捕获。 PHP 异常处理很鸡肋？ 在上面的分析中我们可以看出，PHP 并不能主动的抛出异常，但是你可以手动抛出异常，这就很无语了，如果你知道哪里会出问题，你添加 if else 解决不就行了吗，为啥还要手动抛出异常，既然能手动抛出就证明这个不是异常，而是意料之中。以我的理解，这就是 PHP 异常处理鸡肋的地方（不一定对啊）。所以 PHP 的异常机制不是那么的完美，但是使用过框架的同学都知道有这个情况：你在框架中直接写开头那段 php“自动”捕获异常的代码是可以的，这是为什么？看过源码的同学都知道框架中都会涉及三个函数：register_shutdown_function，set_error_handler，set_exception_handler 后面我会重点讲解着三个黑科技，通过这几个函数我们可以实现 PHP 假自动捕获异常和错误。 二、ERROR 的级别 只有熟悉错误级别才能对错误捕捉有更好的认识。 ERROR 有不同的错误级别，我之前的一篇文章中有写到：http://www.cnblogs.com/zyf-zhaoyafei/p/3649434.html 下面我再总结性的给出这几类错误级别： 1234567891011121314151617181 Fatal Error:致命错误（脚本终止运行）2 E_ERROR &#x2F;&#x2F; 致命的运行错误，错误无法恢复，暂停执行脚本3 E_CORE_ERROR &#x2F;&#x2F; PHP 启动时初始化过程中的致命错误4 E_COMPILE_ERROR &#x2F;&#x2F; 编译时致命性错，就像由 Zend 脚本引擎生成了一个 E_ERROR5 E_USER_ERROR &#x2F;&#x2F; 自定义错误消息。像用 PHP 函数 trigger_error（错误类型设置为：E_USER_ERROR）67 Parse Error：编译时解析错误，语法错误（脚本终止运行）8 E_PARSE &#x2F;&#x2F;编译时的语法解析错误910 Warning Error：警告错误（仅给出提示信息，脚本不终止运行）11 E_WARNING &#x2F;&#x2F; 运行时警告 (非致命错误)。12 E_CORE_WARNING &#x2F;&#x2F; PHP 初始化启动过程中发生的警告 (非致命错误) 。13 E_COMPILE_WARNING &#x2F;&#x2F; 编译警告14 E_USER_WARNING &#x2F;&#x2F; 用户产生的警告信息1516 Notice Error：通知错误（仅给出通知信息，脚本不终止运行）17 E_NOTICE &#x2F;&#x2F; 运行时通知。表示脚本遇到可能会表现为错误的情况.18 E_USER_NOTICE &#x2F;&#x2F; 用户产生的通知信息。 由此可知有 5 类是产生 ERROR 级别的错误，这种错误直接导致 PHP 程序退出。 可以定义成： 1 ERROR = E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_PARSE三、PHP 异常处理中的黑科技 前面提到框架中是可以捕获所有的错误和异常的，之所以能实现应该是使用了黑科技，哈哈！其实也不是什么黑科技，主要是三个重要的函数： 1：set_error_handler() 看到这个名字估计就知道什么意思了，这个函数用于捕获错误，设置一个用户自定义的错误处理函数。 12345671 &lt;?php2 set_error_handler(&#39;zyferror&#39;);3 function zyferror($type, $message, $file, $line)4 &#123;5 var_dump(&#39;&lt;b&gt;set_error_handler: &#39; . $type . &#39;:&#39; . $message . &#39; in &#39; . $file . &#39; on &#39; . $line . &#39; line .&lt;&#x2F;b&gt;&lt;br &#x2F;&gt;&#39;);6 &#125;7 ?&gt; 当程序出现错误的时候自动调用此方法，不过需要注意一下两点：第一，如果存在该方法，相应的 error_reporting()就不能在使用了。所有的错误都会交给自定义的函数处理。第二，此方法不能处理以下级别的错误：E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，set_error_handler() 函数所在文件中产生的 E_STRICT，该函数只能捕获系统产生的一些 Warning、Notice 级别的错误。 并且他有多种调用的方法： 12345671 &lt;?php2 &#x2F;&#x2F; 直接传函数名 NonClassFunction3 set_error_handler(&#39;function_name&#39;);45 &#x2F;&#x2F; 传 class_name &amp;&amp; function_name6 set_error_handler(array(&#39;class_name&#39;, &#39;function_name&#39;));7 ?&gt; 2：register_shutdown_function() 捕获 PHP 的错误：Fatal Error、Parse Error 等，这个方法是 PHP 脚本执行结束前最后一个调用的函数，比如脚本错误、die()、exit、异常、正常结束都会调用，多么牛逼的一个函数啊！通过这个函数就可以在脚本结束前判断这次执行是否有错误产生，这时就要借助于一个函数：error_get_last()；这个函数可以拿到本次执行产生的所有错误。error_get_last();返回的信息： [type] - 错误类型 [message] - 错误消息 [file] - 发生错误所在的文件 [line] - 发生错误所在的行 1234567891 &lt;?php2 register_shutdown_function(&#39;zyfshutdownfunc&#39;);3 function zyfshutdownfunc()4 &#123;5 if ($error &#x3D; error_get_last()) &#123;6 var_dump(&#39;&lt;b&gt;register_shutdown_function: Type:&#39; . $error[&#39;type&#39;] . &#39; Msg: &#39; . $error[&#39;message&#39;] . &#39; in &#39; . $error[&#39;file&#39;] . &#39; on line &#39; . \\$error[&#39;line&#39;] . &#39;&lt;&#x2F;b&gt;&#39;);7 &#125;8 &#125;9 ?&gt; 通过这种方法就可以巧妙的打印出程序结束前所有的错误信息。但是我在测试的时候我发现并不是所有的错误终止后都会调用这个函数，可以看下面的一个测试文件，内容是： 123456789101112131415161718191 &lt;?php2 register_shutdown_function(&#39;zyfshutdownfunc&#39;);3 function zyfshutdownfunc()4 &#123;5 if ($error &#x3D; error_get_last()) &#123; 6 var_dump(&#39;&lt;b&gt;register_shutdown_function: Type:&#39; . $error[&#39;type&#39;] . &#39; Msg: &#39; . $error[&#39;message&#39;] . &#39; in &#39; . $error[&#39;file&#39;] . &#39; on line &#39; . \\$error[&#39;line&#39;] . &#39;&lt;&#x2F;b&gt;&#39;);7 &#125;8 &#125;9 var_dump(23+-+); &#x2F;&#x2F;此处语法错误10 ?&gt; 自己可以试一下，你可以看到根本就不会触发 zyfshutdownfunc()函数，其实这是一个语法错误，直接报了一个：1 &lt;?php2 Parse error: syntax error, unexpected &#39;)&#39; in &#x2F;www&#x2F;mytest&#x2F;exception&#x2F;try-catch.php on line 713 ?&gt; 由此引出一个奇葩的问题：问什么不能触发，为什么框架中是可以的？其实原因很简单，只在 parse-time 出错时是不会调用本函数的。只有在 run-time 出错的时候，才会调用本函数，我的理解是语法检查器前没有执行 register_shutdown_function()去把需要注册的函数放到调用的堆栈中，所以就根本不会运行。那框架中为什么任何错误都能进入到 register_shutdown_function()中呢，其实在框架中一般会有统一的入口 index.php，然后每个类库文件都会通过 include \\*\\* 的方式加载到 index.php 中，相当与所有的程序都会在 index.php 中聚集，同样，你写的具有语法错误的文件也会被引入到入口文件中，这样的话，调用框架，执行 index.php，index.php 本身并没有语法错误，也就不会产生 parse-time 错误，而是 include 文件出错了，是 run-time 的时候出错了，所以框架执行完之后就会触发 register_shutdown_function(); 所以现在可是试一下这个写法，这样就会触发 zyfshutdownfunc()回调了： 1 a.php 文件2 67 b.php 文件8 123 3：set_exception_handler() 设置默认的异常处理程序，用在没有用 try&#x2F;catch 块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。看一下用法： 1 getMessage() . ''); 6 } 7 throw new Exception(\"zyf exception\"); 8 ?> 1234四、巧妙的捕获错误和异常 1：把错误以异常的形式抛出(不能完全抛出) 由上面的讲解我们知道，php 中的错误是不能以异常的像是捕获的，但是我们需要让他们抛出，已达到扩展 try-catch 的影响范围，我们前面讲到过 set_error_handler() 方法，他是干嘛用的，他是捕获错误的，所以我们就可以借助他来吧错误捕获，然后再以异常的形式抛出，ok，试试下面的写法： 1 getMessage(); 14 } 15 ?> 123456789 好了，试一下，会打印出：1 Division by zero zyf123 流程：本来是除 0 错误，然后触发 set_error_handler()，在 set_error_handler()中相当与杀了个回马枪，再把错误信息以异常的形式抛出来，这样就可以实现错误以异常的形式抛出。大家要注意：这样做是有缺点的，会受到 set_error_handler()函数捕获级别的限制。 2：捕获所有的错误 由set_error_handler()可知，他能够捕获一部分错误，不能捕获系统级E_ERROR、E_PARSE等错误，但是这部分可以由register_shutdown_function()捕获。所以两者结合能出现很好的功能。 看下面的程序： 1 a.php 内容：2 21 b.php 内容：22 12345678 到此就可以解释开头的那个程序了吧，test.php 如果是单文件执行是不能捕获到错误的，如果你在框架中执行就是可以的，当然你按照我上面介绍的来扩展也是可以的。五、自定义异常处理和异常嵌套1：自定义异常处理在复杂的系统中，我们往往需要自己捕获我们需要特殊处理的异常，这些异常可能是特殊情况下抛出的。所以我们就自己定义一个异常捕获类，该类必须是 exception 类的一个扩展，该类继承了 PHP 的 exception 类的所有属性，并且我们可以添加自定义的函数，使用的时候其实和之前的一样，大致写法如下： 1 getLine().' in ' . $this->getFile() 7 .': ' . $this->getMessage() . ' Must in (0 - 60)'; 8 } 9 } 10 11 $age = 10; 12 try { 13 $age = intval($age); 14 if($age > 60) { 15 throw new zyfException($age); 16 } 17 18 } catch (zyfException $e) { 19 echo $e->errorzyfMessage(); 20 21 } 22 ?> 1234 2：异常嵌套异常嵌套是比较常见的写法，在自定义的异常处理中，try 块中可以定义多个异常捕获，然后分层传递异常，理解和冒泡差不多，看下面的实现： 1 60) { 6 throw new zyfException($age); 7 } 8 9 if ($age errorzyfMessage(); 15 16 } catch(Exception $e) { 17 echo \\$e->getMessage(); 18 } 19 ?> 12 当然也可以在 catch 中再抛出异常给上层： 1 60) { 7 throw new Exception($age); 8 } 9 10 } catch (Exception $e) { 11 throw new zyfException($age); 12 13 } 14 15 } catch (zyfException $e) { 16 echo \\$e->errorzyfMessage(); 17 } 18 ?> 123六、PHP7 中的异常处理 现在写 PHP 必须考虑版本情况，上面的写法在 PHP7 中大部分都能实现，但是也会有不同点，在 PHP7 更新中有一条：更多的 Error 变为可捕获的 Exception，现在的 PHP7 实现了一个全局的 throwable 接口，原来老的 Exception 和其中一部分 Error 实现了这个接口(interface)，PHP7 中更多的 Error 变为可捕获的 Exception 返回给捕捉器，这样其实和前面提到的扩展 try-catch 影响范围一样，但是如果不捕获则还是按照 Error 对待，看下面两个： 1 getMessage() . ' zyf'; 7 } 8 9 try { 10 test(); 11 12 } catch(Error $e) { 13 echo $e->getMessage() . ' zyf'; 14 } 15 ?> ```因为 PHP7 实现了 throwable 接口，那么就可以使用第一个这种方式来捕获异常。又因为部分 Error 实现了接口，并且更多的 Error 变为可捕获的 Exception，那么就可以使用第二种方式来捕获异常。下面是在网上找的 PHP7 的异常层次树：Throwable Exception 异常 … Error 错误 ArithmeticError 算数错误 DivisionByZeroError 除数为 0 的错误 AssertionError 声明错误 ParseError 解析错误 TypeError 类型错误转载：http://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html","categories":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/tags/PHP/"},{"name":"异常","slug":"异常","permalink":"https://smartxia.github.io/blog/tags/%E5%BC%82%E5%B8%B8/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-抽象工厂模式","date":"2020-06-19T02:57:29.000Z","updated":"2021-04-29T06:32:51.852Z","comments":true,"path":"2020/06/19/设计模式-抽象工厂模式/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"等待更新","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://smartxia.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"待更新","slug":"待更新","permalink":"https://smartxia.github.io/blog/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/"}]},{"title":"设计模式-工厂模式","slug":"设计模式-简单工厂模式","date":"2020-06-19T02:57:29.000Z","updated":"2021-04-29T06:32:56.088Z","comments":true,"path":"2020/06/19/设计模式-简单工厂模式/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"等待更新","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://smartxia.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"待更新","slug":"待更新","permalink":"https://smartxia.github.io/blog/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/"}]},{"title":"http与rpc区别，以及如何使用rpc","slug":"微服务-http与rpc区别，以及如何使用rpc","date":"2020-06-19T02:55:30.000Z","updated":"2021-04-29T06:32:59.749Z","comments":true,"path":"2020/06/19/微服务-http与rpc区别，以及如何使用rpc/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/19/%E5%BE%AE%E6%9C%8D%E5%8A%A1-http%E4%B8%8Erpc%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8rpc/","excerpt":"","text":"HTTP就是一种RPC(Remote Procedure Call) ,http是七层iso模型，转换步骤多，且基于http有更多的报文 http好比普通话，rpc好比团伙内部黑话。只要是远程调用都可以叫RPC()，和是不是通过http没什么关系讲普通话，好处就是谁都听得懂，谁都会讲。讲黑话，好处是可以更精简、更加保密、更加可定制，坏处就是要求“说”黑话的那一方（client端）也要懂，而且一旦大家都说一种黑话了，换黑话就困难了。 首先 http 和 rpc 并不是一个并行概念。 rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。 传输协议包含: 如著名的 [gRPC](grpc / grpc.io) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。 序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。 因此我理解的问题应该是：为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？ 解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。 首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于连接的建立与断开。http协议是支持连接池复用的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。 通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下： 12345678910HTTP/1.0 200 OK Content-Type: text/plainContent-Length: 137582Expires: Thu, 05 Dec 1997 16:00:00 GMTLast-Modified: Wed, 5 August 1996 15:55:28 GMTServer: Apache 0.84&lt;html&gt; &lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt; 即使编码协议也就是body是使用二进制编码协议，报文元数据也就是header头的键值对却用了文本编码，非常占字节数。如上图所使用的报文中有效字节数仅仅占约 30%，也就是70%的时间用于传输元数据废编码。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。 那么假如我们使用自定义tcp协议的报文如下 报头占用的字节数也就只有16个byte，极大地精简了传输内容。 这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因 简单来说成熟的rpc库相对http容器，更多的是封装了“服务发现”，”负载均衡”，“熔断降级”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。 那http和rpc和websocket三者有什么关系呢？ Web Service 也提出了好久了, 那么究竟什么是 Web Service ? 简单地说, 也就是服务器如何向客户端提供服务. 常用的方法有: RPC 所谓的远程过程调用 (面向方法) SOA 所谓的面向服务的架构(面向消息) REST 所谓的 Representational state transfer (面向资源) 转载整理自：https://www.zhihu.com/question/41609070/answer/191965937","categories":[{"name":"微服务","slug":"微服务","permalink":"https://smartxia.github.io/blog/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"}],"tags":[{"name":"rpc()","slug":"rpc","permalink":"https://smartxia.github.io/blog/tags/rpc/"}]},{"title":"GOLANG笔记1","slug":"GOLANG-笔记1","date":"2020-06-09T09:36:01.000Z","updated":"2021-04-29T06:33:10.119Z","comments":true,"path":"2020/06/09/GOLANG-笔记1/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/09/GOLANG-%E7%AC%94%E8%AE%B01/","excerpt":"","text":"int 和 uintuint类型长度取决于 CPU，如果是32位CPU就是4个字节，如果是64位就是8个字节。我的电脑是64位的，而 playground 是32位的 int是带符号的，表示范围是：-2147483648到2147483648，即-2^31到2^31次方。 uint则是不带符号的，表示范围是：2^32即0到4294967295。 uint可以使用十进制，二进制，十六进制。和long,ulong,float,double,decimal等预定义可以进行隐式转换。但是需要注意值是否在可转换的范围内，不然会出现异常。 The Uint keyword signifies an integral type that stores calues according to the size and ranges shown in the following table. 关键字表示一种整型类型，该类型根据下表显示的大小和范围存储值。———————————————— 原文链接：https://blog.csdn.net/janny_flower/article/details/81082424","categories":[{"name":"golang","slug":"golang","permalink":"https://smartxia.github.io/blog/categories/golang/"}],"tags":[]},{"title":"HEXO快捷方式","slug":"建站-HEXO-快捷方式","date":"2020-06-09T06:23:15.000Z","updated":"2021-04-26T03:47:04.596Z","comments":true,"path":"2020/06/09/建站-HEXO-快捷方式/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/09/%E5%BB%BA%E7%AB%99-HEXO-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/","excerpt":"","text":"https://www.jianshu.com/p/1c888a6b8297?utm_source=oschina-app 新编写BLOGhexo new [layout] push到github：hexo deploy hexo clean hexo deploy 每次都要执行 hexo clean 和 hexo deploy，不如写个新的脚本123&#x2F;&#x2F; package.json&quot;dev&quot;: &quot;hexo s&quot;,&quot;build&quot;: &quot;hexo clean &amp; hexo deploy&quot; npm run build","categories":[{"name":"建站","slug":"建站","permalink":"https://smartxia.github.io/blog/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[]},{"title":"MYSQl索引","slug":"MYSQl-索引","date":"2020-06-09T06:20:36.000Z","updated":"2021-04-26T03:47:04.554Z","comments":true,"path":"2020/06/09/MYSQl-索引/","link":"","permalink":"https://smartxia.github.io/blog/2020/06/09/MYSQl-%E7%B4%A2%E5%BC%95/","excerpt":"","text":"docker logs -t -f –tail 100 im4处理init问题 一、查询和更新上的区别这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。建议尽量选择普通索引。1.1 MySQL 的查询操作普通索引查找到第一个满足条件的记录后，继续向后遍历，直到第一个不满足条件的记录。唯一索引由于索引定义了唯一性，查找到第一个满足条件的记录后，直接停止继续检索。普通索引会多检索一次，几乎没有影响。因为 InnoDB 的数据是按照数据页为单位进行读写的，需要读取数据时，并不是直接从磁盘读取记录，而是先把数据页读到内存，再去数据页中检索。一个数据页默认 16 KB，对于整型字段，一个数据页可以放近千个 key，除非要读取的数据在数据页的最后一条记录，就需要再读一个数据页，这种情况很少，对CPU的消耗基本可以忽略了。因此说，在查询数据方面，普通索引和唯一索引没差别。 1.2 MySQL 的更新操作更新操作并不是直接对磁盘中的数据进行更新，是先把数据页从磁盘读入内存，再更新数据页。普通索引将数据页从磁盘读入内存，更新数据页。唯一索引将数据页从磁盘读入内存，判断是否唯一，再更新数据页。由于 MySQL 中有个 change buffer 的机制，会导致普通索引和唯一索引在更新上有一定的区别。change buffer的作用是为了降低IO 操作，避免系统负载过高。change buffer将数据写入数据页的过程，叫做merge。如果需要更新的数据页在内存中时，会直接更新数据页；如果数据不在内存中，会先将更新操作记入change buffer，当下一次读取数据页时，顺带merge到数据页中，change buffer也有定期merge策略。数据库正常关闭的过程中，也会触发merge。对于唯一索引，更新前需要判断数据是否唯一（不能和表中数据重复），如果数据页在内存中，就可以直接判断并且更新，如果不在内存中，就需要去磁盘中读出来，判断一下是否唯一，是的话就更新。change buffer是用不到的。即使数据页不在内存中，还是要读出来。change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。 结论：唯一索引用不了change buffer，只有普通索引可以用。 二、change buffer 和 redo log的区别2.1 change buffer 的适用场景change buffer 的作用是降低更新操作的频率，缓存更新操作。这样会有一个缺点，就是更新不及时，对于读操作比较频繁的表，不建议使用 change buffer。因为更新操作刚记录进change buffer中，就读取了该表，数据页被读到了内存中，数据马上就merge到数据页中了。这样不仅不会降低性能消耗，反而会增加维护change buffer的成本。适用于写多读少的表。 2.2 change buffer 和 redo log 区别我们举一个例子用来理解 redo log 和 change buffer。我们执行以下 SQL 语句：mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2); 假设，(id1,k1) 在数据页 Page 1 中，(id2,k2) 在数据页 Page 2 中。并且 Page 1 在内存中，Page 2 不在内存中。执行过程如下：直接向 Page 1 中写入 (id1,k1)；在change buffer 中记下”向 Page 2 中写入(id2,k2)”这条信息；将以上两个动作记入redo log。做完上面这些，事务就可以完成了。执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。这条更新语句，涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。如果要读数据的话，过程是怎样的？mysql&gt; select * from t where k in (k1, k2); 假设读操作在更新后不久，此时内存中还有 Page 1，没有 Page 2，那么读操作就和 redo log 以及 ibdata1 无关了。从内存中获取到 Page 1 上的最新数据 (id1,k1)；将数据页 Page 2 读入内存，执行merge 操作，此时内存中的 Page 2 也有最新数据(id2,k2)；需要注意的是：redo log中的数据，可能还没有 flush 到磁盘，磁盘中的 Page 1 和 Page 2 中并没有最新数据，但我们依然可以拿到最新数据（内存中的 Page 1 就是最新的，Page 2 虽然不是最新的，但是从磁盘读到内存中后，执行了merge操作，内存中的 Page 2 就是最新的了。）如果此时 MySQL 异常宕机了，比如服务器异常掉电，change buffer 中的数据会不会丢？ change buffer 中的数据分为两部分，一部分是已经merge到ibdata1中的数据，这部分数据已经持久化，不会丢失。另一部分数据，还在 change buffer 中，没有merge 到ibdata1，分 3 种情况： （1）change buffer 写入数据到内存，redo log 也已经写入（ib-log-filex），但是未 commit，binlog中也没有fsync到磁盘，这部分数据会丢失；（2）change buffer 写入数据到内存，redo log 也已经写入（ib-log-filex），但是未 commit，binlog 已写入到磁盘，这部分不会多丢失，异常重启后会先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer；（3）change buffer 写入数据到内存，redo log 和 binlog 都已经fsync，直接从redo log 恢复，不会丢失。redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗 转载自：https://www.cnblogs.com/hhhhuanzi/p/12318504.html","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://smartxia.github.io/blog/categories/MYSQL/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://smartxia.github.io/blog/tags/%E7%B4%A2%E5%BC%95/"}]},{"title":"MYSQL_排序","slug":"MYSQL-排序","date":"2020-01-20T05:39:46.000Z","updated":"2021-04-29T09:05:33.299Z","comments":true,"path":"2020/01/20/MYSQL-排序/","link":"","permalink":"https://smartxia.github.io/blog/2020/01/20/MYSQL-%E6%8E%92%E5%BA%8F/","excerpt":"","text":"","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://smartxia.github.io/blog/categories/MYSQL/"}],"tags":[{"name":"MSYQL","slug":"MSYQL","permalink":"https://smartxia.github.io/blog/tags/MSYQL/"},{"name":"排序","slug":"排序","permalink":"https://smartxia.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"日志","slug":"MYSQL-日志","date":"2019-12-27T08:27:05.000Z","updated":"2021-04-29T06:34:07.240Z","comments":true,"path":"2019/12/27/MYSQL-日志/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/27/MYSQL-%E6%97%A5%E5%BF%97/","excerpt":"","text":"MYSQL 首先分享一个查看大日志的工具，只有几百k,适合用来实时查看mysql的日志 BareTail","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"https://smartxia.github.io/blog/categories/MYSQL/"}],"tags":[{"name":"日志","slug":"日志","permalink":"https://smartxia.github.io/blog/tags/%E6%97%A5%E5%BF%97/"},{"name":"工具","slug":"工具","permalink":"https://smartxia.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"}]},{"title":"redis基础知识","slug":"REDIS-redis基础知识","date":"2019-12-27T03:48:42.000Z","updated":"2021-04-29T06:35:37.500Z","comments":true,"path":"2019/12/27/REDIS-redis基础知识/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/27/REDIS-redis%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"redis pubsub 发布和订阅常用命令： 查看发布的频道：PUBSUB CHANNELS 新建频道： PUBLISH mychannel “hello world” 订阅频道：SUBSCRIBE mychannel | Psubscribe 多个channel |支持 channel* 格式 退订频道：UNSUBSCRIBE mychannel | Punsubscribe 多个channel |支持 channel* 格式","categories":[{"name":"redis学习","slug":"redis学习","permalink":"https://smartxia.github.io/blog/categories/redis%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"pubsub","slug":"pubsub","permalink":"https://smartxia.github.io/blog/tags/pubsub/"}]},{"title":"redis进阶知识","slug":"REDIS-redis知识点","date":"2019-12-27T03:01:49.000Z","updated":"2021-04-29T06:35:44.808Z","comments":true,"path":"2019/12/27/REDIS-redis知识点/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/27/REDIS-redis%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"关于redis 一些基本知识点redis基本介绍remote Dictionary Serer (远程字典服务) ANSI C 编写 支持网络 基于内存可持久化的日志型 key=&gt;value 数据库 官网 redis.io 作者：Salvatore Sanfilippo 意大利人 网名 antirez redis被使用的原因 传统型关系型数据库如mysql 已经不能适用所有场景，秒杀库存 app首页流量访问高峰 所以考虑缓存中间件，目前市面上比较常用的就是redis 和memcached redis 基本的数据结构String 、字典Hash、列表List、集合Set、有序集合 SortedSet、 HyperLogLog、Geo、Pub/Sub BloomFilter 布隆过滤器避免缓存击穿的利器之BloomFilter redis分布式锁-先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放 redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长 使用Redis做异步队列一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。 list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 实现延时队列使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。 生产一次消费多次使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列 缺点：消费者下线的话 生产者会消失，使用MQ Redis是怎么持久化RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。 RDB的原理: fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。 1这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF&#x2F;RDB文件城后，Redis启动成功； AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息 Pipeline有什么好处可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。 Redis的同步机制Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。","categories":[{"name":"redis学习","slug":"redis学习","permalink":"https://smartxia.github.io/blog/categories/redis%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://smartxia.github.io/blog/tags/redis/"}]},{"title":"redis进阶知识","slug":"REDIS-redis进阶知识","date":"2019-12-27T03:01:49.000Z","updated":"2021-04-29T06:35:41.172Z","comments":true,"path":"2019/12/27/REDIS-redis进阶知识/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/27/REDIS-redis%E8%BF%9B%E9%98%B6%E7%9F%A5%E8%AF%86/","excerpt":"","text":"关于redis 一些基本知识点redis基本介绍remote Dictionary Serer (远程字典服务) ANSI C 编写 支持网络 基于内存可持久化的日志型 key=&gt;value 数据库 官网 redis.io 作者：Salvatore Sanfilippo 意大利人 网名 antirez redis被使用的原因 传统型关系型数据库如mysql 已经不能适用所有场景，秒杀库存 app首页流量访问高峰 所以考虑缓存中间件，目前市面上比较常用的就是redis 和memcached redis 基本的数据结构String 、字典Hash、列表List、集合Set、有序集合 SortedSet、 HyperLogLog、Geo、Pub/Sub BloomFilter 布隆过滤器避免缓存击穿的利器之BloomFilter redis分布式锁-先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放 redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长 使用Redis做异步队列一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。 list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。 实现延时队列使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。 生产一次消费多次使用pub/sub主题订阅者模式，可以实现 1:N 的消息队列 缺点：消费者下线的话 生产者会消失，使用MQ Redis是怎么持久化RDB做镜像全量持久化，AOF做增量持久化。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。在redis实例重启时，会使用RDB持久化文件重新构建内存，再使用AOF重放近期的操作指令来实现完整恢复重启之前的状态。 RDB的原理: fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。 1这里很好理解，把RDB理解为一整个表全量的数据，AOF理解为每次操作的日志就好了，服务器重启的时候先把表的数据全部搞进去，但是他可能不完整，你再回放一下日志，数据不就完整了嘛。不过Redis本身的机制是 AOF持久化开启且存在AOF文件时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF&#x2F;RDB文件城后，Redis启动成功； AOF&#x2F;RDB文件存在错误时，Redis启动失败并打印错误信息 Pipeline有什么好处可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。 Redis的同步机制Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。","categories":[{"name":"redis学习","slug":"redis学习","permalink":"https://smartxia.github.io/blog/categories/redis%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://smartxia.github.io/blog/tags/redis/"}]},{"title":"HEXO-butteryly","slug":"建站-HEXO-butteryly","date":"2019-12-18T03:20:24.000Z","updated":"2021-04-26T03:47:04.593Z","comments":true,"path":"2019/12/18/建站-HEXO-butteryly/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/18/%E5%BB%BA%E7%AB%99-HEXO-butteryly/","excerpt":"","text":"主题·文档https://jerryc.me/ 评论系统gittalkhttps://github.com/settings/applications/1190035登录GitHub进行评论，会生成issueValinehttps://leancloud.cn/dashboard/applist.html#/apps特点在于可以免登陆进行评论，输入验证码评论 Laibili（来必力）域名到期不稳定Disqus暂时未测试使用到期 还是准备用valine做第一期","categories":[{"name":"建站","slug":"建站","permalink":"https://smartxia.github.io/blog/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"HEXO","slug":"HEXO","permalink":"https://smartxia.github.io/blog/tags/HEXO/"},{"name":"主题","slug":"主题","permalink":"https://smartxia.github.io/blog/tags/%E4%B8%BB%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"https://smartxia.github.io/blog/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"词条","slug":"计算机基础知识-词条","date":"2019-12-18T02:50:48.000Z","updated":"2021-04-29T06:31:58.520Z","comments":true,"path":"2019/12/18/计算机基础知识-词条/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AF%8D%E6%9D%A1/","excerpt":"","text":"rss: 简易信息聚合（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。 [1] RSS可以是以下三个解释的其中一个： Really Simple Syndication；RDF (Resource Description Framework) Site Summary； Rich Site Summary。但其实这三个解释都是指同一种Syndication的技术。RSS广泛用于网上新闻频道，blog和wiki，主要的版本有0.91, 1.0, 2.0。使用RSS订阅能更快地获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://smartxia.github.io/blog/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"wiki","slug":"wiki","permalink":"https://smartxia.github.io/blog/tags/wiki/"}]},{"title":"编码","slug":"计算机基础知识-编码","date":"2019-12-17T08:35:07.000Z","updated":"2021-04-29T06:31:54.659Z","comments":true,"path":"2019/12/17/计算机基础知识-编码/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/17/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BC%96%E7%A0%81/","excerpt":"","text":"出现%20 或者%%的问题 http://www.soupan.info/tool/utf-8.php%20/ 编码空格字符的URL：+或%20？ 当URL中的空格编码为+，什么时候编码到%20? %7C%7C%20 || 按“转换”即可将其转换为UTF-8字符。再按“还原”即可将其还原为简体中文。 【转】utf-8的中文是一个汉字占三个字节长度英文字母和中文汉字在不同字符集编码下的字节数英文字母： 字节数 : 1;编码：GB2312 字节数 : 1;编码：GBK 字节数 : 1;编码：GB18030 字节数 : 1;编码：ISO-8859-1 字节数 : 1;编码：UTF-8 字节数 : 4;编码：UTF-16 字节数 : 2;编码：UTF-16BE 字节数 : 2;编码：UTF-16LE 中文汉字： 字节数 : 2;编码：GB2312 字节数 : 2;编码：GBK 字节数 : 2;编码：GB18030 字节数 : 1;编码：ISO-8859-1 字节数 : 3;编码：UTF-8 字节数 : 4;编码：UTF-16 字节数 : 2;编码：UTF-16BE 字节数 : 2;编码：UTF-16LE 1、美国人首先对其英文字符进行了编码，也就是最早的ascii码，用一个字节的低7位来表示英文的128个字符，高1位统一为0； 2、后来欧洲人发现尼玛你这128位哪够用，比如我高贵的法国人字母上面的还有注音符，这个怎么区分，得，把高1位编进来吧，这样欧洲普遍使用一个全字节进行编码，最多可表示256位。欧美人就是喜欢直来直去，字符少，编码用得位数少； 3、但是即使位数少，不同国家地区用不同的字符编码，虽然0–127表示的符号是一样的，但是128–255这一段的解释完全乱套了，即使2进制完全一样，表示的字符完全不一样，比如135在法语，希伯来语，俄语编码中完全是不同的符号； 4、更麻烦的是，尼玛这电脑高科技传到中国后，中国人发现我们有10万多个汉字，你们欧美这256字塞牙缝都不够。于是就发明了GB2312这些汉字编码，典型的用2个字节来表示绝大部分的常用汉字，最多可以表示65536个汉字字符，这样就不难理解有些汉字你在新华字典里查得到，但是电脑上如果不处理一下你是显示不出来的了吧。 5、这下各用各的字符集编码，这世界咋统一？俄国人发封email给中国人，两边字符集编码不同，尼玛显示都是乱码啊。为了统一，于是就发明了unicode，将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码，现在unicode可以容纳100多万个符号，每个符号的编码都不一样，这下可统一了，所有语言都可以互通，一个网页页面里可以同时显示各国文字。 6、然而，unicode虽然统一了全世界字符的二进制编码，但没有规定如何存储啊，亲。x86和amd体系结构的电脑小端序和大端序都分不清，别提计算机如何识别到底是unicode还是acsii了。如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。这样导致一个后果：出现了Unicode的多种存储方式。 7、互联网的兴起，网页上要显示各种字符，必须统一啊，亲。utf-8就是Unicode最重要的实现方式之一。另外还有utf-16、utf-32等。UTF-8不是固定字长编码的，而是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。这是种比较巧妙的设计，如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 8、注意unicode的字符编码和utf-8的存储编码表示是不同的，例如”严”字的Unicode码是4E25，UTF-8编码是E4B8A5，这个7里面解释了的，UTF-8编码不仅考虑了编码，还考虑了存储，E4B8A5是在存储识别编码的基础上塞进了4E25。 9、UTF-8 使用一至四个字节为每个字符编码。128 个 ASCII 字符（Unicode 范围由 U+0000 至 U+007F）只需一个字节，带有变音符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及马尔代夫语（Unicode 范围由 U+0080 至 U+07FF）需要二个字节，其他基本多文种平面（BMP）中的字符（CJK属于此类-Qieqie注）使用三个字节，其他 Unicode 辅助平面的字符使用四字节编码。 10、最后，要回答你的问题，常规来看，中文汉字在utf-8中到底占几个字节，一般是3个字节，最常见的编码方式是1110xxxx 10xxxxxx 10xxxxxx。 知乎解答 https://www.zhihu.com/question/23374078Unicode 是「字符集」UTF-8 是「编码规则」其中：字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 / 码点 / Code Point）编码规则：将「码位」转换为字节序列的规则（编码/解码 可以理解为 加密/解密 的过程）广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和UTF-8、UTF-16、UTF-32 等等编码……Unicode 字符集为每一个字符分配一个码位，例如「知」的码位是 30693，记作 U+77E5（30693的十六进制为 0x77E5）。 UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节：","categories":[{"name":"基础知识","slug":"基础知识","permalink":"https://smartxia.github.io/blog/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"编码","slug":"编码","permalink":"https://smartxia.github.io/blog/tags/%E7%BC%96%E7%A0%81/"},{"name":"wiki","slug":"wiki","permalink":"https://smartxia.github.io/blog/tags/wiki/"}]},{"title":"Hello World","slug":"建站-HEXO-hello-world","date":"2019-12-16T09:57:11.000Z","updated":"2021-04-29T06:32:10.040Z","comments":true,"path":"2019/12/16/建站-HEXO-hello-world/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/16/%E5%BB%BA%E7%AB%99-HEXO-hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"建站","slug":"建站","permalink":"https://smartxia.github.io/blog/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[]},{"title":"图片链接","slug":"建站-图片链接","date":"2019-12-16T09:57:11.000Z","updated":"2021-04-29T06:32:02.822Z","comments":true,"path":"2019/12/16/建站-图片链接/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/16/%E5%BB%BA%E7%AB%99-%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5/","excerpt":"","text":"github头像地址链接 https://avatars0.githubusercontent.com/u/23631580?s=400&amp;u=8adfff85bef758535f26ec7c91204d21da557643&amp;v=4 微信头像地址 http://s2-cdn.oneitfarm.com/e12ece12233b4059860acf48637d830a.jpg 动态壁纸链接： https://source.unsplash.com/collection/collectionid/1600x900 https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture https://api.dujin.org/bing/1920.php https://api.dujin.org/bing/1366.php blog背景链接：wechat:http://s2-cdn.oneitfarm.com/ec13d36268ae41d7aaf87d5505324b6a.png (迷你版本)http://s2-cdn.oneitfarm.com/fc44dd8d7da4467da3831cd9e6229e19.jpgalipay:http://s2-cdn.oneitfarm.com/2eef3a681187495aa43ff8bbe1173c09.png (迷你版本)http://s2-cdn.oneitfarm.com/96c2b14feb774e49ae2d110bb500770c.jpg 网站默认背景：https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/top_img_index.jpg 文字默认图片：default_cover: https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png 阅读背景：archive_img: https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/archive.jpg tag背景：tag_img: https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/tag-bg.png 目录背景：category_img: https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/category-bg 如果你有使用hexo-douban去生成movie界面，可配置這個https://cdn.jsdelivr.net/gh/jerryc127/CDN/Photo/movie.jpg 评论背景http://s2-cdn.oneitfarm.com/94f489ea603c42ed854f035fe491222d.png 404背景http://s2-cdn.oneitfarm.com/b09dd72b0fb94cbaab76bdfbb121c4d6.jpgicp背景http://s2-cdn.oneitfarm.com/850aa332dae84b7c8f82f5d0631aa154.png loading 的svghttp://s2-cdn.oneitfarm.com/7ab2d4e7a3a34c81912580725f45c393.svg algolia的svghttp://s2-cdn.oneitfarm.com/0339c65e9ab74f3e919624ed02755dba.svg 私有的bghttps://s2-cdn.oneitfarm.com/92b19077218b48d8b6c1f8726d736c9f.jpg","categories":[{"name":"建站","slug":"建站","permalink":"https://smartxia.github.io/blog/categories/%E5%BB%BA%E7%AB%99/"}],"tags":[{"name":"photo","slug":"photo","permalink":"https://smartxia.github.io/blog/tags/photo/"}]},{"title":"PV,UV","slug":"建站-My-New-Post","date":"2019-12-16T09:57:07.000Z","updated":"2021-04-29T06:32:18.918Z","comments":true,"path":"2019/12/16/建站-My-New-Post/","link":"","permalink":"https://smartxia.github.io/blog/2019/12/16/%E5%BB%BA%E7%AB%99-My-New-Post/","excerpt":"","text":"PV：页面访问量，即PageView，用户每次对网站的访问均被记录，用户对同一页面的多次访问，访问量累计。 UV：独立访问用户数：即UniqueVisitor，访问网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。","categories":[{"name":"Diary","slug":"Diary","permalink":"https://smartxia.github.io/blog/categories/Diary/"},{"name":"PlayStation","slug":"Diary/PlayStation","permalink":"https://smartxia.github.io/blog/categories/Diary/PlayStation/"},{"name":"Games","slug":"Diary/Games","permalink":"https://smartxia.github.io/blog/categories/Diary/Games/"},{"name":"Life","slug":"Life","permalink":"https://smartxia.github.io/blog/categories/Life/"}],"tags":[]}],"categories":[{"name":"golang","slug":"golang","permalink":"https://smartxia.github.io/blog/categories/golang/"},{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/categories/PHP/"},{"name":"其他","slug":"其他","permalink":"https://smartxia.github.io/blog/categories/%E5%85%B6%E4%BB%96/"},{"name":"DOCKER","slug":"DOCKER","permalink":"https://smartxia.github.io/blog/categories/DOCKER/"},{"name":"设计模式","slug":"设计模式","permalink":"https://smartxia.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"微服务","slug":"微服务","permalink":"https://smartxia.github.io/blog/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"建站","slug":"建站","permalink":"https://smartxia.github.io/blog/categories/%E5%BB%BA%E7%AB%99/"},{"name":"MYSQL","slug":"MYSQL","permalink":"https://smartxia.github.io/blog/categories/MYSQL/"},{"name":"redis学习","slug":"redis学习","permalink":"https://smartxia.github.io/blog/categories/redis%E5%AD%A6%E4%B9%A0/"},{"name":"基础知识","slug":"基础知识","permalink":"https://smartxia.github.io/blog/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Diary","slug":"Diary","permalink":"https://smartxia.github.io/blog/categories/Diary/"},{"name":"PlayStation","slug":"Diary/PlayStation","permalink":"https://smartxia.github.io/blog/categories/Diary/PlayStation/"},{"name":"Games","slug":"Diary/Games","permalink":"https://smartxia.github.io/blog/categories/Diary/Games/"},{"name":"Life","slug":"Life","permalink":"https://smartxia.github.io/blog/categories/Life/"}],"tags":[{"name":"Slice","slug":"Slice","permalink":"https://smartxia.github.io/blog/tags/Slice/"},{"name":"Closure","slug":"Closure","permalink":"https://smartxia.github.io/blog/tags/Closure/"},{"name":"匿名函数","slug":"匿名函数","permalink":"https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"name":"匿名类","slug":"匿名类","permalink":"https://smartxia.github.io/blog/tags/%E5%8C%BF%E5%90%8D%E7%B1%BB/"},{"name":"cgi","slug":"cgi","permalink":"https://smartxia.github.io/blog/tags/cgi/"},{"name":"fastcgi","slug":"fastcgi","permalink":"https://smartxia.github.io/blog/tags/fastcgi/"},{"name":"cli","slug":"cli","permalink":"https://smartxia.github.io/blog/tags/cli/"},{"name":"Generator","slug":"Generator","permalink":"https://smartxia.github.io/blog/tags/Generator/"},{"name":"yield","slug":"yield","permalink":"https://smartxia.github.io/blog/tags/yield/"},{"name":"Iterator - 等待更新","slug":"Iterator-等待更新","permalink":"https://smartxia.github.io/blog/tags/Iterator-%E7%AD%89%E5%BE%85%E6%9B%B4%E6%96%B0/"},{"name":"网易云 server酱 py 云函数  待更新","slug":"网易云-server酱-py-云函数-待更新","permalink":"https://smartxia.github.io/blog/tags/%E7%BD%91%E6%98%93%E4%BA%91-server%E9%85%B1-py-%E4%BA%91%E5%87%BD%E6%95%B0-%E5%BE%85%E6%9B%B4%E6%96%B0/"},{"name":"docekr images","slug":"docekr-images","permalink":"https://smartxia.github.io/blog/tags/docekr-images/"},{"name":"xhprof docker push","slug":"xhprof-docker-push","permalink":"https://smartxia.github.io/blog/tags/xhprof-docker-push/"},{"name":"PHP","slug":"PHP","permalink":"https://smartxia.github.io/blog/tags/PHP/"},{"name":"数据结构","slug":"数据结构","permalink":"https://smartxia.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"USE","slug":"USE","permalink":"https://smartxia.github.io/blog/tags/USE/"},{"name":"strlen","slug":"strlen","permalink":"https://smartxia.github.io/blog/tags/strlen/"},{"name":"ssr","slug":"ssr","permalink":"https://smartxia.github.io/blog/tags/ssr/"},{"name":"异常","slug":"异常","permalink":"https://smartxia.github.io/blog/tags/%E5%BC%82%E5%B8%B8/"},{"name":"待更新","slug":"待更新","permalink":"https://smartxia.github.io/blog/tags/%E5%BE%85%E6%9B%B4%E6%96%B0/"},{"name":"rpc()","slug":"rpc","permalink":"https://smartxia.github.io/blog/tags/rpc/"},{"name":"索引","slug":"索引","permalink":"https://smartxia.github.io/blog/tags/%E7%B4%A2%E5%BC%95/"},{"name":"MSYQL","slug":"MSYQL","permalink":"https://smartxia.github.io/blog/tags/MSYQL/"},{"name":"排序","slug":"排序","permalink":"https://smartxia.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"},{"name":"日志","slug":"日志","permalink":"https://smartxia.github.io/blog/tags/%E6%97%A5%E5%BF%97/"},{"name":"工具","slug":"工具","permalink":"https://smartxia.github.io/blog/tags/%E5%B7%A5%E5%85%B7/"},{"name":"pubsub","slug":"pubsub","permalink":"https://smartxia.github.io/blog/tags/pubsub/"},{"name":"redis","slug":"redis","permalink":"https://smartxia.github.io/blog/tags/redis/"},{"name":"HEXO","slug":"HEXO","permalink":"https://smartxia.github.io/blog/tags/HEXO/"},{"name":"主题","slug":"主题","permalink":"https://smartxia.github.io/blog/tags/%E4%B8%BB%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"https://smartxia.github.io/blog/tags/%E6%95%99%E7%A8%8B/"},{"name":"wiki","slug":"wiki","permalink":"https://smartxia.github.io/blog/tags/wiki/"},{"name":"编码","slug":"编码","permalink":"https://smartxia.github.io/blog/tags/%E7%BC%96%E7%A0%81/"},{"name":"photo","slug":"photo","permalink":"https://smartxia.github.io/blog/tags/photo/"}]}