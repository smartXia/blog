<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏夏天的技术博客</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>以地事秦 犹抱薪救火 薪不尽 火不灭</subtitle>
  <link href="https://smartxia.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2025-10-15T10:03:43.351Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis技术总结</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-%E7%AE%80%E5%8C%96%E7%89%88%E6%80%BB%E7%BB%93/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-%E7%AE%80%E5%8C%96%E7%89%88%E6%80%BB%E7%BB%93/</id>
    <published>2025-10-15T11:00:00.000Z</published>
    <updated>2025-10-15T10:03:43.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis技术总结">Redis技术总结</span></h1><h2><span id="基础概念">基础概念</span></h2><p>Redis是内存数据库，数据存储在内存中，读写速度快。</p><p>主要特点：</p><ul><li>内存存储，速度快</li><li>支持数据持久化</li><li>支持多种数据类型</li><li>单线程模型</li></ul><h2><span id="数据类型">数据类型</span></h2><h3><span id="1-string">1. String</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">GET key</span><br><span class="line">INCR key</span><br></pre></td></tr></table></figure><h3><span id="2-hash">2. Hash</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HSET <span class="built_in">hash</span> field value</span><br><span class="line">HGET <span class="built_in">hash</span> field</span><br><span class="line">HGETALL <span class="built_in">hash</span></span><br></pre></td></tr></table></figure><h3><span id="3-list">3. List</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list item</span><br><span class="line">RPOP list</span><br><span class="line">LRANGE list 0 -1</span><br></pre></td></tr></table></figure><h3><span id="4-set">4. Set</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD <span class="built_in">set</span> member</span><br><span class="line">SMEMBERS <span class="built_in">set</span></span><br><span class="line">SINTER set1 set2</span><br></pre></td></tr></table></figure><h3><span id="5-sorted-set">5. Sorted Set</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD zset score member</span><br><span class="line">ZRANGE zset 0 -1</span><br><span class="line">ZREVRANGE zset 0 9</span><br></pre></td></tr></table></figure><h2><span id="持久化">持久化</span></h2><h3><span id="rdb">RDB</span></h3><ul><li>数据快照</li><li>文件小，恢复快</li><li>可能丢失数据</li></ul><h3><span id="aof">AOF</span></h3><ul><li>记录每个写操作</li><li>数据完整性高</li><li>文件大，恢复慢</li></ul><h3><span id="配置">配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><h2><span id="高级特性">高级特性</span></h2><h3><span id="事务">事务</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">SET key1 value1</span><br><span class="line">SET key2 value2</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><h3><span id="发布订阅">发布订阅</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br><span class="line">SUBSCRIBE channel</span><br></pre></td></tr></table></figure><h3><span id="管道">管道</span></h3><ul><li>批量发送命令</li><li>减少网络往返</li><li>提高性能</li></ul><h2><span id="实战应用">实战应用</span></h2><h3><span id="缓存">缓存</span></h3><ul><li>热点数据缓存</li><li>减少数据库压力</li><li>提升响应速度</li></ul><h3><span id="分布式锁">分布式锁</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock:order:123 <span class="string">&quot;locked&quot;</span> EX 30 NX</span><br></pre></td></tr></table></figure><h3><span id="消息队列">消息队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH queue:email <span class="string">&quot;email1&quot;</span></span><br><span class="line">RPOP queue:email</span><br></pre></td></tr></table></figure><h3><span id="计数器">计数器</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR page:views:article:123</span><br></pre></td></tr></table></figure><h3><span id="限流">限流</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL <span class="string">&quot;限流脚本&quot;</span> 1 key <span class="built_in">limit</span> window</span><br></pre></td></tr></table></figure><h2><span id="性能优化">性能优化</span></h2><ol><li>使用Pipeline减少网络往返</li><li>合理设置过期时间</li><li>选择合适的数据类型</li><li>避免大key</li><li>使用连接池</li></ol><h2><span id="监控">监控</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO                    <span class="comment"># 查看Redis信息</span></span><br><span class="line">INFO memory             <span class="comment"># 查看内存使用</span></span><br><span class="line">SLOWLOG GET 10          <span class="comment"># 查看慢查询</span></span><br></pre></td></tr></table></figure><h2><span id="配置建议">配置建议</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">port 6379</span><br><span class="line">maxmemory 256mb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br><span class="line">save 900 1</span><br><span class="line">appendonly yes</span><br><span class="line">requirepass yourpassword</span><br></pre></td></tr></table></figure><h2><span id="常见问题">常见问题</span></h2><h3><span id="缓存穿透">缓存穿透</span></h3><ul><li>缓存空值</li><li>使用布隆过滤器</li></ul><h3><span id="缓存击穿">缓存击穿</span></h3><ul><li>使用分布式锁</li><li>设置热点数据永不过期</li></ul><h3><span id="缓存雪崩">缓存雪崩</span></h3><ul><li>设置随机过期时间</li><li>使用多级缓存</li></ul><h2><span id="总结">总结</span></h2><p>Redis是高性能的内存数据库，适合用作缓存、消息队列、分布式锁等场景。掌握基本数据类型、持久化机制和高级特性，可以大大提高系统性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="数据库技术" scheme="https://smartxia.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redis" scheme="https://smartxia.github.io/blog/tags/Redis/"/>
    
    <category term="总结" scheme="https://smartxia.github.io/blog/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis实战应用</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-05-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-05-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</id>
    <published>2025-10-15T10:40:00.000Z</published>
    <updated>2025-10-15T10:00:55.150Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis实战应用">Redis实战应用</span></h1><p>Redis在实际项目中有很多应用场景，包括缓存、分布式锁、消息队列、计数器等。本文将介绍Redis在实际开发中的常见应用模式和最佳实践。</p><h2><span id="1-缓存应用">1. 缓存应用</span></h2><h3><span id="缓存穿透">缓存穿透</span></h3><p>缓存穿透是指查询一个不存在的数据，由于缓存中没有，请求会直接到达数据库。</p><h4><span id="解决方案">解决方案</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 缓存空值</span></span><br><span class="line">SET user:999999 <span class="string">&quot;&quot;</span> EX 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用布隆过滤器</span></span><br><span class="line"><span class="comment"># 在查询前先检查布隆过滤器</span></span><br></pre></td></tr></table></figure><h4><span id="实现示例">实现示例</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.redis_client = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">self, user_id</span>):</span><br><span class="line">        <span class="comment"># 先查缓存</span></span><br><span class="line">        cache_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">        cached_user = self.redis_client.get(cache_key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cached_user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cached_user == <span class="string">b&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 缓存空值</span></span><br><span class="line">            <span class="keyword">return</span> cached_user.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 查数据库</span></span><br><span class="line">        user = self.database.get_user(user_id)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 缓存空值，防止缓存穿透</span></span><br><span class="line">            self.redis_client.setex(cache_key, <span class="number">300</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 缓存用户数据</span></span><br><span class="line">            self.redis_client.setex(cache_key, <span class="number">3600</span>, user)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><h3><span id="缓存击穿">缓存击穿</span></h3><p>缓存击穿是指热点数据过期，大量请求直接访问数据库。</p><h4><span id="解决方案">解决方案</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用分布式锁</span></span><br><span class="line">SET lock:user:1001 <span class="string">&quot;locked&quot;</span> EX 10 NX</span><br></pre></td></tr></table></figure><h4><span id="实现示例">实现示例</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_hot_data</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 先查缓存</span></span><br><span class="line">        data = self.redis_client.get(key)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取分布式锁</span></span><br><span class="line">        lock_key = <span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span></span><br><span class="line">        lock_value = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.redis_client.<span class="built_in">set</span>(lock_key, lock_value, ex=<span class="number">10</span>, nx=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 双重检查</span></span><br><span class="line">                data = self.redis_client.get(key)</span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    <span class="keyword">return</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 查询数据库</span></span><br><span class="line">                data = self.database.get_data(key)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新缓存</span></span><br><span class="line">                self.redis_client.setex(key, <span class="number">3600</span>, data)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                <span class="comment"># 释放锁</span></span><br><span class="line">                <span class="keyword">if</span> self.redis_client.get(lock_key) == lock_value.encode():</span><br><span class="line">                    self.redis_client.delete(lock_key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 等待一段时间后重试</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_hot_data(key)</span><br></pre></td></tr></table></figure><h3><span id="缓存雪崩">缓存雪崩</span></h3><p>缓存雪崩是指大量缓存同时过期，导致请求直接访问数据库。</p><h4><span id="解决方案">解决方案</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 设置随机过期时间</span></span><br><span class="line">SET key1 <span class="string">&quot;value1&quot;</span> EX 3600</span><br><span class="line">SET key2 <span class="string">&quot;value2&quot;</span> EX 3650</span><br><span class="line">SET key3 <span class="string">&quot;value3&quot;</span> EX 3700</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用多级缓存</span></span><br><span class="line"><span class="comment"># 3. 缓存预热</span></span><br></pre></td></tr></table></figure><h2><span id="2-分布式锁">2. 分布式锁</span></h2><h3><span id="基本实现">基本实现</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取锁</span></span><br><span class="line">SET lock:order:123 <span class="string">&quot;locked&quot;</span> EX 30 NX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁</span></span><br><span class="line">DEL lock:order:123</span><br></pre></td></tr></table></figure><h3><span id="改进实现防止误删">改进实现（防止误删）</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取锁时设置唯一值</span></span><br><span class="line">SET lock:order:123 <span class="string">&quot;uuid-12345&quot;</span> EX 30 NX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁时检查值</span></span><br><span class="line">EVAL <span class="string">&quot;</span></span><br><span class="line"><span class="string">if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">    return redis.call(&#x27;DEL&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    return 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&quot;</span> 1 lock:order:123 uuid-12345</span><br></pre></td></tr></table></figure><h3><span id="完整实现">完整实现</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedLock</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, lock_name, timeout=<span class="number">30</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.lock_name = <span class="string">f&quot;lock:<span class="subst">&#123;lock_name&#125;</span>&quot;</span></span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.identifier = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        self.lock_time = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">acquire</span>(<span class="params">self, blocking=<span class="literal">True</span>, blocking_timeout=<span class="literal">None</span></span>):</span><br><span class="line">        end = time.time() + (blocking_timeout <span class="keyword">or</span> self.timeout)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.redis_client.<span class="built_in">set</span>(self.lock_name, self.identifier, ex=self.timeout, nx=<span class="literal">True</span>):</span><br><span class="line">                self.lock_time = time.time()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> blocking <span class="keyword">or</span> time.time() &gt; end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            time.sleep(<span class="number">0.001</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.lock_time <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">            return redis.call(&#x27;DEL&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        result = self.redis_client.<span class="built_in">eval</span>(script, <span class="number">1</span>, self.lock_name, self.identifier)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            self.lock_time = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self, additional_time</span>):</span><br><span class="line">        <span class="keyword">if</span> self.lock_time <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">            return redis.call(&#x27;EXPIRE&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.redis_client.<span class="built_in">eval</span>(script, <span class="number">1</span>, self.lock_name, self.identifier, self.timeout + additional_time)</span><br></pre></td></tr></table></figure><h2><span id="3-消息队列">3. 消息队列</span></h2><h3><span id="简单队列">简单队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email1&quot;</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者</span></span><br><span class="line">RPOP queue:email</span><br></pre></td></tr></table></figure><h3><span id="阻塞队列">阻塞队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阻塞式消费</span></span><br><span class="line">BLPOP queue:email 10</span><br></pre></td></tr></table></figure><h3><span id="延时队列">延时队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加延时任务</span></span><br><span class="line">ZADD delay_queue 1640995200 <span class="string">&quot;task1&quot;</span></span><br><span class="line">ZADD delay_queue 1640995260 <span class="string">&quot;task2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取到期任务</span></span><br><span class="line">ZRANGEBYSCORE delay_queue 0 1640995200</span><br></pre></td></tr></table></figure><h3><span id="完整实现">完整实现</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, queue_name</span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.queue_name = queue_name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;推送消息&quot;&quot;&quot;</span></span><br><span class="line">        self.redis_client.lpush(self.queue_name, json.dumps(message))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, timeout=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;消费消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">            result = self.redis_client.brpop(self.queue_name, timeout)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="keyword">return</span> json.loads(result[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = self.redis_client.rpop(self.queue_name)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="keyword">return</span> json.loads(result)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取队列长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.redis_client.llen(self.queue_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelayQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, queue_name</span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.queue_name = queue_name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, message, delay_seconds</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加延时任务&quot;&quot;&quot;</span></span><br><span class="line">        execute_time = time.time() + delay_seconds</span><br><span class="line">        self.redis_client.zadd(self.queue_name, &#123;json.dumps(message): execute_time&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取到期任务&quot;&quot;&quot;</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        result = self.redis_client.zrangebyscore(self.queue_name, <span class="number">0</span>, now, start=<span class="number">0</span>, num=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            message = json.loads(result[<span class="number">0</span>])</span><br><span class="line">            self.redis_client.zrem(self.queue_name, result[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2><span id="4-计数器应用">4. 计数器应用</span></h2><h3><span id="基本计数器">基本计数器</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问计数</span></span><br><span class="line">INCR page:views:article:123</span><br><span class="line">GET page:views:article:123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量计数</span></span><br><span class="line">INCRBY user:1001:score 10</span><br><span class="line">INCRBY user:1001:score -5</span><br></pre></td></tr></table></figure><h3><span id="限流器">限流器</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口限流</span></span><br><span class="line">EVAL <span class="string">&quot;</span></span><br><span class="line"><span class="string">local key = KEYS[1]</span></span><br><span class="line"><span class="string">local window = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">local limit = tonumber(ARGV[2])</span></span><br><span class="line"><span class="string">local now = tonumber(ARGV[3])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 清理过期数据</span></span><br><span class="line"><span class="string">redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, key, 0, now - window)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 获取当前计数</span></span><br><span class="line"><span class="string">local current = redis.call(&#x27;ZCARD&#x27;, key)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if current &lt; limit then</span></span><br><span class="line"><span class="string">    redis.call(&#x27;ZADD&#x27;, key, now, now)</span></span><br><span class="line"><span class="string">    redis.call(&#x27;EXPIRE&#x27;, key, window)</span></span><br><span class="line"><span class="string">    return 1</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    return 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&quot;</span> 1 rate_limit:user:1001 60 100 1640995200</span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimiter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, key_prefix=<span class="string">&quot;rate_limit&quot;</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.key_prefix = key_prefix</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_allowed</span>(<span class="params">self, identifier, limit, window</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查是否允许请求&quot;&quot;&quot;</span></span><br><span class="line">        key = <span class="string">f&quot;<span class="subst">&#123;self.key_prefix&#125;</span>:<span class="subst">&#123;identifier&#125;</span>&quot;</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        </span><br><span class="line">        script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        local key = KEYS[1]</span></span><br><span class="line"><span class="string">        local window = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">        local limit = tonumber(ARGV[2])</span></span><br><span class="line"><span class="string">        local now = tonumber(ARGV[3])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, key, 0, now - window)</span></span><br><span class="line"><span class="string">        local current = redis.call(&#x27;ZCARD&#x27;, key)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        if current &lt; limit then</span></span><br><span class="line"><span class="string">            redis.call(&#x27;ZADD&#x27;, key, now, now)</span></span><br><span class="line"><span class="string">            redis.call(&#x27;EXPIRE&#x27;, key, window)</span></span><br><span class="line"><span class="string">            return 1</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        result = self.redis_client.<span class="built_in">eval</span>(script, <span class="number">1</span>, key, window, limit, now)</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="5-会话管理">5. 会话管理</span></h2><h3><span id="用户会话">用户会话</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储会话</span></span><br><span class="line">HSET session:abc123 user_id 1001</span><br><span class="line">HSET session:abc123 username <span class="string">&quot;张三&quot;</span></span><br><span class="line">HSET session:abc123 login_time 1640995200</span><br><span class="line">EXPIRE session:abc123 3600</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取会话</span></span><br><span class="line">HGETALL session:abc123</span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SessionManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, session_timeout=<span class="number">3600</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.session_timeout = session_timeout</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_session</span>(<span class="params">self, user_id, user_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建会话&quot;&quot;&quot;</span></span><br><span class="line">        session_id = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        session_data = &#123;</span><br><span class="line">            <span class="string">&#x27;user_id&#x27;</span>: user_id,</span><br><span class="line">            <span class="string">&#x27;created_at&#x27;</span>: time.time(),</span><br><span class="line">            **user_data</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.redis_client.hmset(session_key, session_data)</span><br><span class="line">        self.redis_client.expire(session_key, self.session_timeout)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> session_id</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_session</span>(<span class="params">self, session_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取会话&quot;&quot;&quot;</span></span><br><span class="line">        session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">        session_data = self.redis_client.hgetall(session_key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> session_data:</span><br><span class="line">            <span class="comment"># 刷新过期时间</span></span><br><span class="line">            self.redis_client.expire(session_key, self.session_timeout)</span><br><span class="line">            <span class="keyword">return</span> &#123;k.decode(): v.decode() <span class="keyword">for</span> k, v <span class="keyword">in</span> session_data.items()&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">destroy_session</span>(<span class="params">self, session_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;销毁会话&quot;&quot;&quot;</span></span><br><span class="line">        session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">        self.redis_client.delete(session_key)</span><br></pre></td></tr></table></figure><h2><span id="6-排行榜">6. 排行榜</span></h2><h3><span id="游戏排行榜">游戏排行榜</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新分数</span></span><br><span class="line">ZADD leaderboard 1000 <span class="string">&quot;player1&quot;</span></span><br><span class="line">ZADD leaderboard 950 <span class="string">&quot;player2&quot;</span></span><br><span class="line">ZADD leaderboard 1100 <span class="string">&quot;player3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取排行榜</span></span><br><span class="line">ZREVRANGE leaderboard 0 9 WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取玩家排名</span></span><br><span class="line">ZREVRANK leaderboard <span class="string">&quot;player1&quot;</span></span><br><span class="line">ZSCORE leaderboard <span class="string">&quot;player1&quot;</span></span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaderboard</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, leaderboard_name</span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.leaderboard_name = leaderboard_name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_score</span>(<span class="params">self, player, score</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新分数&quot;&quot;&quot;</span></span><br><span class="line">        self.redis_client.zadd(self.leaderboard_name, &#123;player: score&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_top_players</span>(<span class="params">self, limit=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取排行榜&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.redis_client.zrevrange(self.leaderboard_name, <span class="number">0</span>, limit-<span class="number">1</span>, withscores=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_player_rank</span>(<span class="params">self, player</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取玩家排名&quot;&quot;&quot;</span></span><br><span class="line">        rank = self.redis_client.zrevrank(self.leaderboard_name, player)</span><br><span class="line">        score = self.redis_client.zscore(self.leaderboard_name, player)</span><br><span class="line">        <span class="keyword">return</span> rank + <span class="number">1</span> <span class="keyword">if</span> rank <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span>, score</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_players_around</span>(<span class="params">self, player, range_size=<span class="number">5</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取玩家周围的排名&quot;&quot;&quot;</span></span><br><span class="line">        rank = self.redis_client.zrevrank(self.leaderboard_name, player)</span><br><span class="line">        <span class="keyword">if</span> rank <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        start = <span class="built_in">max</span>(<span class="number">0</span>, rank - range_size)</span><br><span class="line">        end = rank + range_size</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.redis_client.zrevrange(self.leaderboard_name, start, end, withscores=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2><span id="7-布隆过滤器">7. 布隆过滤器</span></h2><h3><span id="基本使用">基本使用</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">BF.ADD bloom_filter <span class="string">&quot;item1&quot;</span></span><br><span class="line">BF.ADD bloom_filter <span class="string">&quot;item2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查元素</span></span><br><span class="line">BF.EXISTS bloom_filter <span class="string">&quot;item1&quot;</span></span><br><span class="line">BF.EXISTS bloom_filter <span class="string">&quot;item3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量添加</span></span><br><span class="line">BF.MADD bloom_filter <span class="string">&quot;item4&quot;</span> <span class="string">&quot;item5&quot;</span> <span class="string">&quot;item6&quot;</span></span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, key, capacity=<span class="number">10000</span>, error_rate=<span class="number">0.01</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.key = key</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.error_rate = error_rate</span><br><span class="line">        self.bit_array_size = self._calculate_bit_array_size()</span><br><span class="line">        self.hash_functions = self._calculate_hash_functions()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calculate_bit_array_size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算位数组大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(-(self.capacity * math.log(self.error_rate)) / (math.log(<span class="number">2</span>) ** <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calculate_hash_functions</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算哈希函数数量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>((self.bit_array_size / self.capacity) * math.log(<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, item, seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        hash_obj = hashlib.md5()</span><br><span class="line">        hash_obj.update(<span class="string">f&quot;<span class="subst">&#123;item&#125;</span><span class="subst">&#123;seed&#125;</span>&quot;</span>.encode())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(hash_obj.hexdigest(), <span class="number">16</span>) % self.bit_array_size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_functions):</span><br><span class="line">            bit_index = self._<span class="built_in">hash</span>(item, i)</span><br><span class="line">            self.redis_client.setbit(self.key, bit_index, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exists</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_functions):</span><br><span class="line">            bit_index = self._<span class="built_in">hash</span>(item, i)</span><br><span class="line">            <span class="keyword">if</span> self.redis_client.getbit(self.key, bit_index) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2><span id="8-最佳实践">8. 最佳实践</span></h2><h3><span id="1-性能优化">1. 性能优化</span></h3><ul><li>使用Pipeline减少网络往返</li><li>合理设置过期时间</li><li>使用合适的数据类型</li><li>避免大key</li></ul><h3><span id="2-内存优化">2. 内存优化</span></h3><ul><li>定期清理过期数据</li><li>使用压缩</li><li>监控内存使用</li><li>设置合理的淘汰策略</li></ul><h3><span id="3-高可用">3. 高可用</span></h3><ul><li>使用主从复制</li><li>配置哨兵模式</li><li>定期备份数据</li><li>监控系统状态</li></ul><h3><span id="4-安全配置">4. 安全配置</span></h3><ul><li>设置密码</li><li>限制网络访问</li><li>禁用危险命令</li><li>定期更新版本</li></ul><h2><span id="总结">总结</span></h2><p>Redis在实际项目中有广泛的应用，从简单的缓存到复杂的分布式系统都能发挥重要作用。掌握这些实战应用模式，可以大大提高开发效率和系统性能。在实际使用中，需要根据具体业务场景选择合适的应用模式，并注意性能优化和安全性。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.md">Redis高级特性</a><br><strong>系列总结</strong>：Redis技术文档整理完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="数据库技术" scheme="https://smartxia.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redis" scheme="https://smartxia.github.io/blog/tags/Redis/"/>
    
    <category term="缓存" scheme="https://smartxia.github.io/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
    <category term="实战应用" scheme="https://smartxia.github.io/blog/tags/%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
    
    <category term="分布式锁" scheme="https://smartxia.github.io/blog/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
    <category term="消息队列" scheme="https://smartxia.github.io/blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis高级特性</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</id>
    <published>2025-10-15T10:30:00.000Z</published>
    <updated>2025-10-15T09:58:29.181Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis高级特性">Redis高级特性</span></h1><p>Redis不仅是一个简单的键值存储，还提供了许多高级特性，包括事务、发布订阅、管道、Lua脚本等。这些特性使得Redis能够处理更复杂的应用场景。</p><h2><span id="1-事务transaction">1. 事务（Transaction）</span></h2><p>Redis事务是一组命令的集合，这些命令要么全部执行，要么全部不执行。</p><h3><span id="事务特性">事务特性</span></h3><ul><li><strong>原子性</strong>：事务中的所有命令要么全部执行，要么全部不执行</li><li><strong>隔离性</strong>：事务在执行过程中不会被其他客户端打断</li><li><strong>一致性</strong>：事务执行前后数据库状态保持一致</li><li><strong>不支持回滚</strong>：Redis事务不支持回滚操作</li></ul><h3><span id="事务命令">事务命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始事务</span></span><br><span class="line">MULTI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令（命令会进入队列）</span></span><br><span class="line">SET key1 <span class="string">&quot;value1&quot;</span></span><br><span class="line">SET key2 <span class="string">&quot;value2&quot;</span></span><br><span class="line">INCR counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消事务</span></span><br><span class="line">DISCARD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视键</span></span><br><span class="line">WATCH key1 key2</span><br></pre></td></tr></table></figure><h3><span id="事务示例">事务示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本事务</span></span><br><span class="line">MULTI</span><br><span class="line">SET user:1001:name <span class="string">&quot;张三&quot;</span></span><br><span class="line">SET user:1001:age 25</span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带监视的事务</span></span><br><span class="line">WATCH user:1001:balance</span><br><span class="line">MULTI</span><br><span class="line">DECRBY user:1001:balance 100</span><br><span class="line">INCRBY user:1002:balance 100</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><h3><span id="事务注意事项">事务注意事项</span></h3><ol><li><strong>命令错误</strong>：语法错误会导致整个事务失败</li><li><strong>运行时错误</strong>：运行时错误不会影响其他命令执行</li><li><strong>WATCH机制</strong>：被监视的键被修改时，事务会失败</li></ol><h2><span id="2-发布订阅pubx2fsub">2. 发布订阅（Pub&#x2F;Sub）</span></h2><p>Redis发布订阅是一种消息通信模式，发布者发送消息，订阅者接收消息。</p><h3><span id="基本概念">基本概念</span></h3><ul><li><strong>发布者（Publisher）</strong>：发送消息的客户端</li><li><strong>订阅者（Subscriber）</strong>：接收消息的客户端</li><li><strong>频道（Channel）</strong>：消息传递的通道</li></ul><h3><span id="发布订阅命令">发布订阅命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布消息</span></span><br><span class="line">PUBLISH channel message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅频道</span></span><br><span class="line">SUBSCRIBE channel1 channel2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消订阅</span></span><br><span class="line">UNSUBSCRIBE channel1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式订阅</span></span><br><span class="line">PSUBSCRIBE news.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消模式订阅</span></span><br><span class="line">PUNSUBSCRIBE news.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看活跃频道</span></span><br><span class="line">PUBSUB CHANNELS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看频道订阅数</span></span><br><span class="line">PUBSUB NUMSUB channel1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看模式订阅数</span></span><br><span class="line">PUBSUB NUMPAT</span><br></pre></td></tr></table></figure><h3><span id="发布订阅示例">发布订阅示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布者</span></span><br><span class="line">PUBLISH news:sports <span class="string">&quot;足球比赛结果&quot;</span></span><br><span class="line">PUBLISH news:tech <span class="string">&quot;新技术发布&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者1</span></span><br><span class="line">SUBSCRIBE news:sports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者2</span></span><br><span class="line">PSUBSCRIBE news:*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看活跃频道</span></span><br><span class="line">PUBSUB CHANNELS news:*</span><br></pre></td></tr></table></figure><h3><span id="发布订阅特点">发布订阅特点</span></h3><ul><li><strong>无持久化</strong>：消息不会持久化存储</li><li><strong>无确认机制</strong>：订阅者可能丢失消息</li><li><strong>实时性</strong>：消息实时传递</li><li><strong>一对多</strong>：一个发布者可以对应多个订阅者</li></ul><h2><span id="3-管道pipeline">3. 管道（Pipeline）</span></h2><p>Pipeline允许客户端一次性发送多个命令，减少网络往返次数，提高性能。</p><h3><span id="pipeline原理">Pipeline原理</span></h3><ol><li><strong>批量发送</strong>：将多个命令打包发送</li><li><strong>批量接收</strong>：一次性接收所有响应</li><li><strong>减少延迟</strong>：减少网络往返时间</li></ol><h3><span id="pipeline示例">Pipeline示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用Pipeline</span></span><br><span class="line">SET key1 <span class="string">&quot;value1&quot;</span></span><br><span class="line">GET key1</span><br><span class="line">SET key2 <span class="string">&quot;value2&quot;</span></span><br><span class="line">GET key2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Pipeline（伪代码）</span></span><br><span class="line">pipeline = redis.pipeline()</span><br><span class="line">pipeline.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">pipeline.get(<span class="string">&quot;key1&quot;</span>)</span><br><span class="line">pipeline.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">pipeline.get(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line">results = pipeline.execute()</span><br></pre></td></tr></table></figure><h3><span id="pipeline性能测试">Pipeline性能测试</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试脚本</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Pipeline测试</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -P 16 -q</span><br></pre></td></tr></table></figure><h3><span id="pipeline注意事项">Pipeline注意事项</span></h3><ul><li><strong>原子性</strong>：Pipeline中的命令不是原子性的</li><li><strong>错误处理</strong>：需要检查每个命令的执行结果</li><li><strong>内存使用</strong>：大量命令可能占用较多内存</li></ul><h2><span id="4-lua脚本">4. Lua脚本</span></h2><p>Redis支持Lua脚本，可以在服务器端执行复杂的逻辑。</p><h3><span id="lua脚本优势">Lua脚本优势</span></h3><ul><li><strong>原子性</strong>：脚本执行是原子性的</li><li><strong>减少网络开销</strong>：复杂逻辑在服务器端执行</li><li><strong>高性能</strong>：避免多次网络往返</li></ul><h3><span id="lua脚本命令">Lua脚本命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行Lua脚本</span></span><br><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行缓存的脚本</span></span><br><span class="line">EVALSHA sha1 numkeys key [key ...] arg [arg ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存脚本</span></span><br><span class="line">SCRIPT LOAD script</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查脚本是否存在</span></span><br><span class="line">SCRIPT EXISTS sha1 [sha1 ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死正在执行的脚本</span></span><br><span class="line">SCRIPT KILL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新脚本缓存</span></span><br><span class="line">SCRIPT FLUSH</span><br></pre></td></tr></table></figure><h3><span id="lua脚本示例">Lua脚本示例</span></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 限流脚本</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> current = redis.call(<span class="string">&#x27;GET&#x27;</span>, key)</span><br><span class="line"><span class="keyword">if</span> current == <span class="literal">false</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;SET&#x27;</span>, key, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, expire)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    current = <span class="built_in">tonumber</span>(current)</span><br><span class="line">    <span class="keyword">if</span> current &lt; limit <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;INCR&#x27;</span>, key)</span><br><span class="line">        <span class="keyword">return</span> current + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3><span id="执行lua脚本">执行Lua脚本</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接执行</span></span><br><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;GET&#x27;, KEYS[1])&quot;</span> 1 mykey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存后执行</span></span><br><span class="line">SCRIPT LOAD <span class="string">&quot;return redis.call(&#x27;GET&#x27;, KEYS[1])&quot;</span></span><br><span class="line">EVALSHA &lt;sha1&gt; 1 mykey</span><br></pre></td></tr></table></figure><h2><span id="5-慢查询日志">5. 慢查询日志</span></h2><p>Redis慢查询日志记录执行时间超过指定阈值的命令。</p><h3><span id="慢查询配置">慢查询配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置慢查询阈值（微秒）</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 设置慢查询日志最大长度</span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure><h3><span id="慢查询命令">慢查询命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看慢查询日志</span></span><br><span class="line">SLOWLOG GET 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取慢查询日志长度</span></span><br><span class="line">SLOWLOG LEN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空慢查询日志</span></span><br><span class="line">SLOWLOG RESET</span><br></pre></td></tr></table></figure><h3><span id="慢查询分析">慢查询分析</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看慢查询日志</span></span><br><span class="line">SLOWLOG GET 5</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 14</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1309448221</span><br><span class="line">   3) (<span class="built_in">integer</span>) 15</span><br><span class="line">   4) 1) <span class="string">&quot;ping&quot;</span></span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 13</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1309448128</span><br><span class="line">   3) (<span class="built_in">integer</span>) 30</span><br><span class="line">   4) 1) <span class="string">&quot;slowlog&quot;</span></span><br><span class="line">      2) <span class="string">&quot;get&quot;</span></span><br><span class="line">      3) <span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure><h2><span id="6-内存优化">6. 内存优化</span></h2><h3><span id="内存使用分析">内存使用分析</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内存使用情况</span></span><br><span class="line">INFO memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存使用详情</span></span><br><span class="line">MEMORY USAGE key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存统计</span></span><br><span class="line">MEMORY STATS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存医生</span></span><br><span class="line">MEMORY DOCTOR</span><br></pre></td></tr></table></figure><h3><span id="内存优化策略">内存优化策略</span></h3><ol><li><strong>选择合适的数据类型</strong></li><li><strong>使用过期时间</strong></li><li><strong>定期清理无用数据</strong></li><li><strong>使用压缩</strong></li></ol><h3><span id="内存优化示例">内存优化示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置过期时间</span></span><br><span class="line">EXPIRE key 3600</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Hash存储对象</span></span><br><span class="line">HSET user:1001 name <span class="string">&quot;张三&quot;</span> age 25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用BitMap存储状态</span></span><br><span class="line">SETBIT user:1001:online 0 1</span><br></pre></td></tr></table></figure><h2><span id="7-性能监控">7. 性能监控</span></h2><h3><span id="监控命令">监控命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Redis信息</span></span><br><span class="line">INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看统计信息</span></span><br><span class="line">INFO stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看客户端信息</span></span><br><span class="line">INFO clients</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看CPU信息</span></span><br><span class="line">INFO cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看复制信息</span></span><br><span class="line">INFO replication</span><br></pre></td></tr></table></figure><h3><span id="性能指标">性能指标</span></h3><ul><li><strong>QPS</strong>：每秒查询数</li><li><strong>延迟</strong>：命令执行时间</li><li><strong>内存使用率</strong>：内存占用情况</li><li><strong>连接数</strong>：客户端连接数</li></ul><h3><span id="性能测试">性能测试</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本性能测试</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定客户端数</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -c 50 -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定Pipeline</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -P 16 -q</span><br></pre></td></tr></table></figure><h2><span id="8-安全配置">8. 安全配置</span></h2><h3><span id="基本安全">基本安全</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置密码</span><br><span class="line">requirepass yourpassword</span><br><span class="line"></span><br><span class="line"># 绑定IP</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 禁用危险命令</span><br><span class="line">rename-command FLUSHDB &quot;&quot;</span><br><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 设置最大内存</span><br><span class="line">maxmemory 2gb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><h3><span id="网络安全">网络安全</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 禁用外部访问</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 设置超时</span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure><h2><span id="9-最佳实践">9. 最佳实践</span></h2><h3><span id="1-性能优化">1. 性能优化</span></h3><ul><li>使用Pipeline减少网络往返</li><li>合理使用Lua脚本</li><li>监控慢查询日志</li><li>优化内存使用</li></ul><h3><span id="2-安全配置">2. 安全配置</span></h3><ul><li>设置强密码</li><li>限制网络访问</li><li>禁用危险命令</li><li>定期更新Redis版本</li></ul><h3><span id="3-监控告警">3. 监控告警</span></h3><ul><li>监控关键指标</li><li>设置告警阈值</li><li>定期检查日志</li><li>性能测试</li></ul><h2><span id="总结">总结</span></h2><p>Redis的高级特性为复杂应用场景提供了强大的支持。事务保证了数据一致性，发布订阅实现了消息通信，Pipeline提高了性能，Lua脚本提供了服务器端逻辑处理能力。合理使用这些特性可以大大提高Redis的应用价值。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6.md">Redis持久化机制</a><br><strong>下一篇</strong>：<a href="./Redis-05-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8.md">Redis实战应用</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="数据库技术" scheme="https://smartxia.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redis" scheme="https://smartxia.github.io/blog/tags/Redis/"/>
    
    <category term="高级特性" scheme="https://smartxia.github.io/blog/tags/%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    
    <category term="事务" scheme="https://smartxia.github.io/blog/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="发布订阅" scheme="https://smartxia.github.io/blog/tags/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/"/>
    
    <category term="管道" scheme="https://smartxia.github.io/blog/tags/%E7%AE%A1%E9%81%93/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化机制</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</id>
    <published>2025-10-15T10:20:00.000Z</published>
    <updated>2025-10-15T09:57:32.314Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis持久化机制">Redis持久化机制</span></h1><p>Redis是内存数据库，数据存储在内存中，但Redis提供了持久化机制来保证数据的可靠性。Redis支持两种持久化方式：RDB（Redis Database）和AOF（Append Only File）。</p><h2><span id="1-rdb持久化">1. RDB持久化</span></h2><p>RDB是Redis的默认持久化方式，通过创建数据快照来保存数据。</p><h3><span id="rdb工作原理">RDB工作原理</span></h3><ol><li><strong>fork子进程</strong>：Redis主进程fork一个子进程</li><li><strong>数据快照</strong>：子进程将内存中的数据写入RDB文件</li><li><strong>替换文件</strong>：用新的RDB文件替换旧的RDB文件</li></ol><h3><span id="rdb配置">RDB配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf配置</span><br><span class="line">save 900 1      # 900秒内至少1个key发生变化</span><br><span class="line">save 300 10     # 300秒内至少10个key发生变化</span><br><span class="line">save 60 10000   # 60秒内至少10000个key发生变化</span><br><span class="line"></span><br><span class="line"># 禁用RDB</span><br><span class="line">save &quot;&quot;</span><br><span class="line"></span><br><span class="line"># RDB文件位置</span><br><span class="line">dir /var/lib/redis</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 压缩RDB文件</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><h3><span id="rdb命令">RDB命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动保存</span></span><br><span class="line">SAVE          <span class="comment"># 同步保存，阻塞主进程</span></span><br><span class="line">BGSAVE        <span class="comment"># 异步保存，不阻塞主进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最后保存时间</span></span><br><span class="line">LASTSAVE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查RDB文件</span></span><br><span class="line">redis-check-rdb dump.rdb</span><br></pre></td></tr></table></figure><h3><span id="rdb优缺点">RDB优缺点</span></h3><p><strong>优点：</strong></p><ul><li>文件紧凑，适合备份和灾难恢复</li><li>恢复大数据集时速度很快</li><li>对Redis性能影响最小</li><li>适合大规模数据迁移</li></ul><p><strong>缺点：</strong></p><ul><li>可能丢失最后一次快照后的数据</li><li>数据量大时fork过程耗时较长</li><li>不适合对数据完整性要求很高的场景</li></ul><h2><span id="2-aof持久化">2. AOF持久化</span></h2><p>AOF通过记录每个写操作来持久化数据，类似于数据库的binlog。</p><h3><span id="aof工作原理">AOF工作原理</span></h3><ol><li><strong>记录命令</strong>：将每个写命令追加到AOF文件</li><li><strong>文件重写</strong>：定期重写AOF文件，去除冗余命令</li><li><strong>恢复数据</strong>：重启时重放AOF文件中的命令</li></ol><h3><span id="aof配置">AOF配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 启用AOF</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF同步策略</span><br><span class="line">appendfsync always     # 每个写命令都同步</span><br><span class="line">appendfsync everysec   # 每秒同步一次（推荐）</span><br><span class="line">appendfsync no         # 由操作系统决定何时同步</span><br><span class="line"></span><br><span class="line"># AOF重写配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 混合持久化（Redis 4.0+）</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h3><span id="aof命令">AOF命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动重写AOF</span></span><br><span class="line">BGREWRITEAOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看AOF文件</span></span><br><span class="line">redis-check-aof appendonly.aof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看AOF状态</span></span><br><span class="line">INFO persistence</span><br></pre></td></tr></table></figure><h3><span id="aof优缺点">AOF优缺点</span></h3><p><strong>优点：</strong></p><ul><li>数据完整性高，最多丢失1秒数据</li><li>AOF文件可读性好，便于分析</li><li>支持混合持久化，兼顾性能和完整性</li></ul><p><strong>缺点：</strong></p><ul><li>文件体积较大</li><li>恢复速度比RDB慢</li><li>对性能有一定影响</li></ul><h2><span id="3-混合持久化redis-40">3. 混合持久化（Redis 4.0+）</span></h2><p>混合持久化结合了RDB和AOF的优点，在AOF重写时使用RDB格式。</p><h3><span id="工作原理">工作原理</span></h3><ol><li><strong>AOF重写时</strong>：先生成RDB快照</li><li><strong>追加增量</strong>：将重写期间的增量命令追加到RDB后</li><li><strong>文件格式</strong>：RDB数据 + AOF增量命令</li></ol><h3><span id="配置">配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启用混合持久化</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h2><span id="4-持久化策略选择">4. 持久化策略选择</span></h2><h3><span id="场景1缓存系统">场景1：缓存系统</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 只使用RDB</span><br><span class="line">save 900 1</span><br><span class="line">appendonly no</span><br></pre></td></tr></table></figure><h3><span id="场景2数据存储">场景2：数据存储</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用AOF</span><br><span class="line">save &quot;&quot;</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><h3><span id="场景3高可用系统">场景3：高可用系统</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 混合持久化</span><br><span class="line">save 900 1</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h2><span id="5-持久化监控">5. 持久化监控</span></h2><h3><span id="监控命令">监控命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看持久化信息</span></span><br><span class="line">INFO persistence</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最后保存时间</span></span><br><span class="line">LASTSAVE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看AOF文件大小</span></span><br><span class="line">INFO memory</span><br></pre></td></tr></table></figure><h3><span id="监控指标">监控指标</span></h3><ul><li><strong>RDB相关</strong>：last_save_time、rdb_last_bgsave_status</li><li><strong>AOF相关</strong>：aof_enabled、aof_last_rewrite_time_sec</li><li><strong>内存相关</strong>：used_memory、used_memory_peak</li></ul><h2><span id="6-备份与恢复">6. 备份与恢复</span></h2><h3><span id="备份策略">备份策略</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 自动备份脚本</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">BACKUP_DIR=<span class="string">&quot;/backup/redis&quot;</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%Y%m%d_%H%M%S)</span><br><span class="line">redis-cli BGSAVE</span><br><span class="line"><span class="built_in">cp</span> /var/lib/redis/dump.rdb <span class="variable">$BACKUP_DIR</span>/dump_<span class="variable">$DATE</span>.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定期清理旧备份</span></span><br><span class="line">find <span class="variable">$BACKUP_DIR</span> -name <span class="string">&quot;dump_*.rdb&quot;</span> -mtime +7 -delete</span><br></pre></td></tr></table></figure><h3><span id="恢复数据">恢复数据</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 停止Redis服务</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 备份当前数据</span></span><br><span class="line"><span class="built_in">cp</span> /var/lib/redis/dump.rdb /var/lib/redis/dump.rdb.backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 恢复RDB文件</span></span><br><span class="line"><span class="built_in">cp</span> /backup/redis/dump_20231015_120000.rdb /var/lib/redis/dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 启动Redis服务</span></span><br><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure><h2><span id="7-性能优化">7. 性能优化</span></h2><h3><span id="rdb优化">RDB优化</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 调整保存频率</span><br><span class="line">save 300 10    # 减少保存频率</span><br><span class="line"></span><br><span class="line"># 优化fork性能</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure><h3><span id="aof优化">AOF优化</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 调整同步策略</span><br><span class="line">appendfsync everysec  # 平衡性能和安全性</span><br><span class="line"></span><br><span class="line"># 优化重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h2><span id="8-故障处理">8. 故障处理</span></h2><h3><span id="常见问题">常见问题</span></h3><ol><li><p><strong>RDB文件损坏</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查文件完整性</span></span><br><span class="line">redis-check-rdb dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份恢复</span></span><br><span class="line"><span class="built_in">cp</span> backup/dump.rdb /var/lib/redis/</span><br></pre></td></tr></table></figure></li><li><p><strong>AOF文件损坏</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查AOF文件</span></span><br><span class="line">redis-check-aof appendonly.aof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复AOF文件</span></span><br><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure></li><li><p><strong>持久化失败</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查磁盘空间</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查权限</span></span><br><span class="line"><span class="built_in">ls</span> -la /var/lib/redis/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure></li></ol><h2><span id="9-最佳实践">9. 最佳实践</span></h2><h3><span id="1-配置建议">1. 配置建议</span></h3><ul><li>生产环境建议使用混合持久化</li><li>根据业务需求调整保存频率</li><li>定期监控持久化状态</li></ul><h3><span id="2-备份策略">2. 备份策略</span></h3><ul><li>定期备份RDB和AOF文件</li><li>异地备份重要数据</li><li>测试恢复流程</li></ul><h3><span id="3-监控告警">3. 监控告警</span></h3><ul><li>监控持久化状态</li><li>设置磁盘空间告警</li><li>监控持久化性能</li></ul><h2><span id="总结">总结</span></h2><p>Redis的持久化机制是保证数据可靠性的重要手段。RDB适合备份和快速恢复，AOF适合数据完整性要求高的场景，混合持久化则兼顾了两者的优点。在实际应用中，需要根据业务需求选择合适的持久化策略。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3.md">Redis数据结构详解</a><br><strong>下一篇</strong>：<a href="./Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.md">Redis高级特性</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="数据库技术" scheme="https://smartxia.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redis" scheme="https://smartxia.github.io/blog/tags/Redis/"/>
    
    <category term="持久化" scheme="https://smartxia.github.io/blog/tags/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="RDB" scheme="https://smartxia.github.io/blog/tags/RDB/"/>
    
    <category term="AOF" scheme="https://smartxia.github.io/blog/tags/AOF/"/>
    
  </entry>
  
  <entry>
    <title>Redis数据结构详解</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</id>
    <published>2025-10-15T10:10:00.000Z</published>
    <updated>2025-10-15T10:03:43.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis数据结构详解">Redis数据结构详解</span></h1><p>Redis支持五种基本数据类型：String、Hash、List、Set、Sorted Set。每种类型都有特定的使用场景。</p><h2><span id="1-string字符串">1. String（字符串）</span></h2><p>String是Redis最基本的数据类型，可以存储字符串、整数或浮点数。</p><p>基本操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET key value           <span class="comment"># 设置和获取</span></span><br><span class="line">GET key</span><br><span class="line">MSET key1 value1 key2 value2  <span class="comment"># 批量操作</span></span><br><span class="line">MGET key1 key2</span><br><span class="line">INCR key               <span class="comment"># 数值操作</span></span><br><span class="line">DECR key</span><br><span class="line">INCRBY key 5</span><br><span class="line">APPEND key <span class="string">&quot;suffix&quot;</span>    <span class="comment"># 字符串操作</span></span><br><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p>使用场景：</p><ul><li>缓存：存储用户信息、商品信息</li><li>计数器：网站访问量、点赞数</li><li>分布式锁：使用SETNX实现</li><li>会话存储：存储用户登录状态</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET user:1001 <span class="string">&#x27;&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:25&#125;&#x27;</span>  <span class="comment"># 用户信息缓存</span></span><br><span class="line">INCR page:views:article:123               <span class="comment"># 访问计数器</span></span><br><span class="line">SETNX lock:order:123 <span class="string">&quot;locked&quot;</span>             <span class="comment"># 分布式锁</span></span><br></pre></td></tr></table></figure><h2><span id="2-hash哈希">2. Hash（哈希）</span></h2><p>Hash是一个键值对集合，适合存储对象。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置和获取</span></span><br><span class="line">HSET <span class="built_in">hash</span> field value</span><br><span class="line">HGET <span class="built_in">hash</span> field</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line">HMSET <span class="built_in">hash</span> field1 value1 field2 value2</span><br><span class="line">HMGET <span class="built_in">hash</span> field1 field2</span><br><span class="line">HGETALL <span class="built_in">hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line">HDEL <span class="built_in">hash</span> field        <span class="comment"># 删除字段</span></span><br><span class="line">HEXISTS <span class="built_in">hash</span> field     <span class="comment"># 检查字段是否存在</span></span><br><span class="line">HKEYS <span class="built_in">hash</span>             <span class="comment"># 获取所有字段名</span></span><br><span class="line">HVALS <span class="built_in">hash</span>             <span class="comment"># 获取所有字段值</span></span><br><span class="line">HLEN <span class="built_in">hash</span>              <span class="comment"># 获取字段数量</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>对象存储</strong>：用户信息、商品详情等</li><li><strong>配置管理</strong>：系统配置参数</li><li><strong>购物车</strong>：用户购物车商品</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户信息存储</span></span><br><span class="line">HSET user:1001 name <span class="string">&quot;张三&quot;</span></span><br><span class="line">HSET user:1001 age 25</span><br><span class="line">HSET user:1001 email <span class="string">&quot;zhangsan@example.com&quot;</span></span><br><span class="line">HGETALL user:1001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 购物车</span></span><br><span class="line">HSET cart:1001 product:001 2</span><br><span class="line">HSET cart:1001 product:002 1</span><br><span class="line">HGETALL cart:1001</span><br></pre></td></tr></table></figure><h2><span id="3-list列表">3. List（列表）</span></h2><p>List是一个双向链表，支持从两端进行插入和删除操作。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左侧操作</span></span><br><span class="line">LPUSH list item1 item2    <span class="comment"># 左侧插入</span></span><br><span class="line">LPOP list                 <span class="comment"># 左侧弹出</span></span><br><span class="line">LINDEX list 0             <span class="comment"># 获取指定位置元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右侧操作</span></span><br><span class="line">RPUSH list item3 item4    <span class="comment"># 右侧插入</span></span><br><span class="line">RPOP list                 <span class="comment"># 右侧弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line">LLEN list                 <span class="comment"># 获取列表长度</span></span><br><span class="line">LRANGE list 0 -1          <span class="comment"># 获取指定范围元素</span></span><br><span class="line">LREM list 2 <span class="string">&quot;item&quot;</span>        <span class="comment"># 删除指定元素</span></span><br><span class="line">LTRIM list 0 4            <span class="comment"># 截取列表</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>消息队列</strong>：FIFO队列</li><li><strong>最新列表</strong>：最新文章、最新评论</li><li><strong>栈结构</strong>：LIFO操作</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消息队列</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email1&quot;</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email2&quot;</span></span><br><span class="line">RPOP queue:email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最新文章列表</span></span><br><span class="line">LPUSH articles:latest <span class="string">&quot;article:001&quot;</span></span><br><span class="line">LPUSH articles:latest <span class="string">&quot;article:002&quot;</span></span><br><span class="line">LRANGE articles:latest 0 9  <span class="comment"># 获取最新10篇文章</span></span><br></pre></td></tr></table></figure><h2><span id="4-set集合">4. Set（集合）</span></h2><p>Set是一个无序的、不重复的元素集合。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line">SADD <span class="built_in">set</span> member1 member2    <span class="comment"># 添加成员</span></span><br><span class="line">SREM <span class="built_in">set</span> member1            <span class="comment"># 删除成员</span></span><br><span class="line">SMEMBERS <span class="built_in">set</span>                <span class="comment"># 获取所有成员</span></span><br><span class="line">SISMEMBER <span class="built_in">set</span> member1       <span class="comment"># 检查成员是否存在</span></span><br><span class="line">SCARD <span class="built_in">set</span>                   <span class="comment"># 获取成员数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合运算</span></span><br><span class="line">SUNION set1 set2            <span class="comment"># 并集</span></span><br><span class="line">SINTER set1 set2            <span class="comment"># 交集</span></span><br><span class="line">SDIFF set1 set2             <span class="comment"># 差集</span></span><br><span class="line">SUNIONSTORE result set1 set2 <span class="comment"># 并集存储到新集合</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>标签系统</strong>：文章标签、用户兴趣</li><li><strong>好友关系</strong>：共同好友、推荐好友</li><li><strong>去重</strong>：IP黑名单、用户ID去重</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章标签</span></span><br><span class="line">SADD article:001:tags <span class="string">&quot;技术&quot;</span> <span class="string">&quot;Redis&quot;</span> <span class="string">&quot;数据库&quot;</span></span><br><span class="line">SADD article:002:tags <span class="string">&quot;技术&quot;</span> <span class="string">&quot;MySQL&quot;</span> <span class="string">&quot;数据库&quot;</span></span><br><span class="line">SINTER article:001:tags article:002:tags  <span class="comment"># 共同标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户关注</span></span><br><span class="line">SADD user:1001:following 1002 1003</span><br><span class="line">SADD user:1002:following 1001 1003</span><br><span class="line">SINTER user:1001:following user:1002:following  <span class="comment"># 共同关注</span></span><br></pre></td></tr></table></figure><h2><span id="5-sorted-set有序集合">5. Sorted Set（有序集合）</span></h2><p>Sorted Set是有序的、不重复的元素集合，每个元素都有一个分数（score）。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line">ZADD zset score1 member1 score2 member2  <span class="comment"># 添加成员</span></span><br><span class="line">ZREM zset member1                        <span class="comment"># 删除成员</span></span><br><span class="line">ZSCORE zset member1                      <span class="comment"># 获取成员分数</span></span><br><span class="line">ZRANK zset member1                       <span class="comment"># 获取成员排名</span></span><br><span class="line">ZCARD zset                               <span class="comment"># 获取成员数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围操作</span></span><br><span class="line">ZRANGE zset 0 -1                         <span class="comment"># 按排名获取成员</span></span><br><span class="line">ZRANGEBYSCORE zset 80 100                <span class="comment"># 按分数获取成员</span></span><br><span class="line">ZREVRANGE zset 0 9                       <span class="comment"># 倒序获取前10名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分数操作</span></span><br><span class="line">ZINCRBY zset 5 member1                   <span class="comment"># 增加分数</span></span><br><span class="line">ZCOUNT zset 80 100                       <span class="comment"># 统计分数范围内的成员数</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>排行榜</strong>：游戏积分、文章热度</li><li><strong>延时队列</strong>：任务调度</li><li><strong>范围查询</strong>：按分数范围查询</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 游戏排行榜</span></span><br><span class="line">ZADD leaderboard 1000 <span class="string">&quot;player1&quot;</span></span><br><span class="line">ZADD leaderboard 950 <span class="string">&quot;player2&quot;</span></span><br><span class="line">ZADD leaderboard 1100 <span class="string">&quot;player3&quot;</span></span><br><span class="line">ZREVRANGE leaderboard 0 9  <span class="comment"># 获取前10名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延时队列</span></span><br><span class="line">ZADD delay_queue 1640995200 <span class="string">&quot;task1&quot;</span>  <span class="comment"># 2022-01-01执行</span></span><br><span class="line">ZADD delay_queue 1640995260 <span class="string">&quot;task2&quot;</span>  <span class="comment"># 2022-01-01 01:01执行</span></span><br><span class="line">ZRANGEBYSCORE delay_queue 0 1640995200  <span class="comment"># 获取到期的任务</span></span><br></pre></td></tr></table></figure><h2><span id="6-其他数据类型">6. 其他数据类型</span></h2><h3><span id="bitmap位图">Bitmap（位图）</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位操作</span></span><br><span class="line">SETBIT bitmap 0 1        <span class="comment"># 设置第0位为1</span></span><br><span class="line">GETBIT bitmap 0          <span class="comment"># 获取第0位的值</span></span><br><span class="line">BITCOUNT bitmap          <span class="comment"># 统计1的个数</span></span><br><span class="line">BITOP AND result bitmap1 bitmap2  <span class="comment"># 位运算</span></span><br></pre></td></tr></table></figure><h3><span id="hyperloglog">HyperLogLog</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基数统计</span></span><br><span class="line">PFADD hll element1 element2  <span class="comment"># 添加元素</span></span><br><span class="line">PFCOUNT hll                  <span class="comment"># 统计基数</span></span><br><span class="line">PFMERGE result hll1 hll2     <span class="comment"># 合并多个HyperLogLog</span></span><br></pre></td></tr></table></figure><h3><span id="geo地理位置">Geo（地理位置）</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地理位置操作</span></span><br><span class="line">GEOADD locations 116.397 39.916 <span class="string">&quot;北京&quot;</span></span><br><span class="line">GEODIST locations <span class="string">&quot;北京&quot;</span> <span class="string">&quot;上海&quot;</span> km</span><br><span class="line">GEORADIUS locations 116.397 39.916 100 km</span><br></pre></td></tr></table></figure><h2><span id="数据类型选择指南">数据类型选择指南</span></h2><table><thead><tr><th>数据类型</th><th>使用场景</th><th>优势</th><th>注意事项</th></tr></thead><tbody><tr><td>String</td><td>缓存、计数器</td><td>简单高效</td><td>内存占用较大</td></tr><tr><td>Hash</td><td>对象存储</td><td>结构化存储</td><td>不适合大对象</td></tr><tr><td>List</td><td>队列、栈</td><td>有序存储</td><td>随机访问效率低</td></tr><tr><td>Set</td><td>去重、集合运算</td><td>去重、运算</td><td>无序存储</td></tr><tr><td>Sorted Set</td><td>排行榜、范围查询</td><td>有序、范围查询</td><td>内存占用较大</td></tr></tbody></table><h2><span id="性能优化建议">性能优化建议</span></h2><h3><span id="1-选择合适的数据类型">1. 选择合适的数据类型</span></h3><ul><li>根据使用场景选择最合适的数据类型</li><li>避免使用String存储复杂对象</li></ul><h3><span id="2-控制数据大小">2. 控制数据大小</span></h3><ul><li>避免存储过大的单个值</li><li>合理设置过期时间</li></ul><h3><span id="3-批量操作">3. 批量操作</span></h3><ul><li>使用MSET、MGET等批量命令</li><li>减少网络往返次数</li></ul><h3><span id="4-内存优化">4. 内存优化</span></h3><ul><li>使用压缩列表等优化存储</li><li>定期清理过期数据</li></ul><h2><span id="总结">总结</span></h2><p>Redis的五种基本数据类型各有特点，选择合适的类型可以大大提高系统性能。在实际应用中，需要根据具体场景选择最合适的数据类型，并注意性能优化。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-01-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md">Redis基础入门</a><br><strong>下一篇</strong>：<a href="./Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6.md">Redis持久化机制</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="数据库技术" scheme="https://smartxia.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="数据结构" scheme="https://smartxia.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="Redis" scheme="https://smartxia.github.io/blog/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础入门</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-01-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/tech/backend/database/redis/Redis-01-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</id>
    <published>2025-10-15T10:00:00.000Z</published>
    <updated>2025-10-15T10:03:43.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis基础入门">Redis基础入门</span></h1><h2><span id="什么是redis">什么是Redis</span></h2><p>Redis是一个高性能的键值对数据库，数据存储在内存中，读写速度很快。</p><p>主要特点：</p><ul><li>内存存储，速度快</li><li>支持数据持久化</li><li>支持多种数据类型</li><li>单线程模型</li><li>每秒可处理10万次读写操作</li></ul><h2><span id="redis应用场景">Redis应用场景</span></h2><ol><li>缓存系统 - 热点数据缓存，减少数据库压力</li><li>会话存储 - 分布式Session，用户登录状态管理</li><li>消息队列 - 异步任务处理，发布&#x2F;订阅模式</li><li>分布式锁 - 防止重复操作，保证数据一致性</li><li>计数器 - 网站访问统计，实时数据统计</li></ol><h2><span id="redis优缺点">Redis优缺点</span></h2><p>优点：</p><ul><li>读写速度极快</li><li>支持多种数据类型</li><li>支持数据持久化</li><li>支持主从复制</li><li>所有操作都是原子性的</li></ul><p>缺点：</p><ul><li>数据量受内存限制</li><li>CPU密集型任务性能有限</li><li>主从同步可能有延迟</li><li>在线扩容较复杂</li></ul><h2><span id="redis安装配置">Redis安装配置</span></h2><p>安装Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line">sudo apt install redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo yum install redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line">brew install redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker</span></span><br><span class="line">docker run -d -p 6379:6379 redis:latest</span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-server                    <span class="comment"># 启动服务</span></span><br><span class="line">redis-server --daemonize <span class="built_in">yes</span>    <span class="comment"># 后台启动</span></span><br><span class="line">redis-cli                       <span class="comment"># 连接客户端</span></span><br><span class="line">redis-cli ping                  <span class="comment"># 测试连接</span></span><br></pre></td></tr></table></figure><h2><span id="基本命令">基本命令</span></h2><p>键值操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET key value        <span class="comment"># 设置键值</span></span><br><span class="line">GET key              <span class="comment"># 获取值</span></span><br><span class="line">DEL key              <span class="comment"># 删除键</span></span><br><span class="line">EXISTS key           <span class="comment"># 检查键是否存在</span></span><br><span class="line">EXPIRE key seconds   <span class="comment"># 设置过期时间</span></span><br><span class="line">TTL key              <span class="comment"># 查看剩余过期时间</span></span><br></pre></td></tr></table></figure><p>数据类型操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">SET name <span class="string">&quot;张三&quot;</span></span><br><span class="line">GET name</span><br><span class="line">APPEND name <span class="string">&quot;李四&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">LPUSH list <span class="string">&quot;item1&quot;</span>   <span class="comment"># 左侧插入</span></span><br><span class="line">RPUSH list <span class="string">&quot;item2&quot;</span>   <span class="comment"># 右侧插入</span></span><br><span class="line">LPOP list            <span class="comment"># 左侧弹出</span></span><br><span class="line">RPOP list            <span class="comment"># 右侧弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line">SADD <span class="built_in">set</span> <span class="string">&quot;member1&quot;</span>   <span class="comment"># 添加成员</span></span><br><span class="line">SMEMBERS <span class="built_in">set</span>         <span class="comment"># 查看所有成员</span></span><br><span class="line">SREM <span class="built_in">set</span> <span class="string">&quot;member1&quot;</span>   <span class="comment"># 删除成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希</span></span><br><span class="line">HSET <span class="built_in">hash</span> field1 <span class="string">&quot;value1&quot;</span>  <span class="comment"># 设置字段</span></span><br><span class="line">HGET <span class="built_in">hash</span> field1           <span class="comment"># 获取字段值</span></span><br><span class="line">HGETALL <span class="built_in">hash</span>               <span class="comment"># 获取所有字段</span></span><br></pre></td></tr></table></figure><h2><span id="配置说明">配置说明</span></h2><p>主要配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1          # 绑定IP</span><br><span class="line">port 6379               # 端口</span><br><span class="line">maxmemory 256mb         # 最大内存</span><br><span class="line">maxmemory-policy allkeys-lru  # 淘汰策略</span><br><span class="line">save 900 1              # 持久化配置</span><br><span class="line">requirepass yourpassword # 密码</span><br></pre></td></tr></table></figure><h2><span id="性能优化">性能优化</span></h2><ol><li>内存优化 - 合理设置maxmemory，选择合适的数据类型</li><li>网络优化 - 使用pipeline，合理设置超时时间</li><li>持久化优化 - 根据业务需求选择持久化方式</li></ol><h2><span id="监控维护">监控维护</span></h2><p>监控命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO                    <span class="comment"># 查看Redis信息</span></span><br><span class="line">INFO memory             <span class="comment"># 查看内存使用</span></span><br><span class="line">INFO clients            <span class="comment"># 查看连接信息</span></span><br><span class="line">SLOWLOG GET 10          <span class="comment"># 查看慢查询</span></span><br></pre></td></tr></table></figure><p>维护操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLUSHDB                 <span class="comment"># 清空当前数据库</span></span><br><span class="line">FLUSHALL                <span class="comment"># 清空所有数据库</span></span><br><span class="line">SCAN 0                  <span class="comment"># 安全遍历键</span></span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>Redis是功能强大的内存数据库，适合用作缓存和高速数据存储。掌握基础知识是学习高级特性的前提。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="数据库技术" scheme="https://smartxia.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="Redis" scheme="https://smartxia.github.io/blog/tags/Redis/"/>
    
    <category term="数据库" scheme="https://smartxia.github.io/blog/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="缓存" scheme="https://smartxia.github.io/blog/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>WebRTC/WHIP 区别详解</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/%E8%A7%86%E9%A2%91%E6%B5%81/WebRTC-WHIP-%E5%8C%BA%E5%88%AB/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/%E8%A7%86%E9%A2%91%E6%B5%81/WebRTC-WHIP-%E5%8C%BA%E5%88%AB/</id>
    <published>2025-10-15T09:19:46.000Z</published>
    <updated>2025-10-15T09:25:00.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="概述">概述</span></h2><p>WebRTC 和 WHIP 是两种不同的技术。简单说：</p><p>🧠 <strong>WebRTC</strong> 是通信协议族<br>🚀 <strong>WHIP</strong> 是用于推流（Ingest）的 WebRTC 标准化子协议</p><h2><span id="一-概念对比总览">一、概念对比总览</span></h2><table><thead><tr><th>项目</th><th>WebRTC</th><th>WHIP</th></tr></thead><tbody><tr><td><strong>全称</strong></td><td>Web Real-Time Communication</td><td>WebRTC-HTTP Ingestion Protocol</td></tr><tr><td><strong>定位</strong></td><td>一整套实时音视频传输协议（P2P 实时通信标准）</td><td>用 HTTP 封装 WebRTC 推流到服务器的简化协议</td></tr><tr><td><strong>标准组织</strong></td><td>W3C &#x2F; IETF</td><td>IETF (draft-ietf-wish-whip)</td></tr><tr><td><strong>使用场景</strong></td><td>浏览器与浏览器、浏览器与服务端之间的实时通信</td><td>客户端（如 OBS、浏览器、摄像头）推流到媒体服务器（如 Wowza、Janus、LiveKit、Millicast）</td></tr><tr><td><strong>信令机制</strong></td><td>自定义（开发者自己实现信令）</td><td>通过 HTTP POST&#x2F;DELETE 标准化信令</td></tr><tr><td><strong>传输协议</strong></td><td>SRTP + DTLS + ICE (UDP)</td><td>同 WebRTC，底层依然是 SRTP + DTLS + ICE</td></tr><tr><td><strong>推流&#x2F;拉流角色</strong></td><td>双方对等（peer-to-peer）</td><td>单向：Publisher → Media Server</td></tr><tr><td><strong>典型用途</strong></td><td>视频会议、实时互动</td><td>WebRTC 直播推流（低延迟直播）</td></tr></tbody></table><h2><span id="二-whip-的设计背景">二、WHIP 的设计背景</span></h2><p>WebRTC 本身只定义了音视频传输层（媒体、网络、加密），但<strong>不定义信令层</strong>。<br>也就是说，如何交换 SDP（Session Description Protocol）、如何建立连接由开发者自己决定。</p><p>→ 这让”推流场景”实现起来很复杂，每个平台信令都不一样。</p><p>💡 所以 IETF 推出了 <strong>WHIP</strong>（WebRTC-HTTP Ingestion Protocol），<br>目标是让 WebRTC 像 RTMP 一样容易推流：</p><ol><li>用一个 <strong>HTTP POST</strong> 发起推流（发送 SDP offer）</li><li>服务器返回 <strong>SDP answer</strong></li><li>推流端开始传输媒体流</li><li>用 <strong>HTTP DELETE</strong> 停止推流</li></ol><p>这样浏览器、OBS、GStreamer 等工具可以用统一接口推流到任意支持 WHIP 的服务器。</p><h2><span id="三-whip-工作流程示例">三、WHIP 工作流程示例</span></h2><p>👇 <strong>WHIP 推流时序图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[Client]                        [Media Server]</span><br><span class="line">   |                                  |</span><br><span class="line">   |  POST /whip-endpoint             |</span><br><span class="line">   |  Content-Type: application/sdp   |</span><br><span class="line">   |  Body: SDP offer                 |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |       201 Created                |</span><br><span class="line">   |  Location: /resource/id          |</span><br><span class="line">   |  Body: SDP answer                |</span><br><span class="line">   |&lt;---------------------------------|</span><br><span class="line">   |                                  |</span><br><span class="line">   |------ ICE Candidate Exchange ----|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  (Start sending RTP media)       |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  DELETE /resource/id             |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  (Stop streaming)                |</span><br></pre></td></tr></table></figure><h2><span id="四-whip-与传统-rtmp-推流对比">四、WHIP 与传统 RTMP 推流对比</span></h2><table><thead><tr><th>对比项</th><th>RTMP</th><th>WHIP</th></tr></thead><tbody><tr><td><strong>协议层</strong></td><td>TCP</td><td>UDP (SRTP over ICE)</td></tr><tr><td><strong>延迟</strong></td><td>秒级（2~5s）</td><td>低于 500ms</td></tr><tr><td><strong>推流接口</strong></td><td>统一（rtmp:&#x2F;&#x2F;…）</td><td>标准化 HTTP (REST API)</td></tr><tr><td><strong>推流格式</strong></td><td>FLV</td><td>SDP + RTP</td></tr><tr><td><strong>是否加密</strong></td><td>否（或 TLS）</td><td>强制 DTLS + SRTP</td></tr><tr><td><strong>主要用途</strong></td><td>点播直播</td><td>超低延迟互动直播</td></tr></tbody></table><h2><span id="五-whip-的反向协议whep">五、WHIP 的反向协议：WHEP</span></h2><p><strong>WHIP</strong> 是 推流（Ingest），<br>而 <strong>WHEP</strong>（WebRTC-HTTP Egress Protocol） 是 拉流（Playback） 标准化协议。</p><p>二者配合可以替代 RTMP + HLS 的整套流程：</p><table><thead><tr><th>方向</th><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>推流</td><td>WHIP</td><td>客户端 → 服务端</td></tr><tr><td>拉流</td><td>WHEP</td><td>服务端 → 播放端</td></tr></tbody></table><h2><span id="六-总结">六、总结</span></h2><p><strong>WebRTC</strong> 是底层传输标准，<strong>WHIP</strong> 是基于 WebRTC 的统一推流信令协议。<br>WHIP 让”WebRTC 推流”像”RTMP 推流”一样简单。</p><h2><span id="七-实际应用">七、实际应用</span></h2><p>如果你要在实际项目中使用：</p><h3><span id="服务器端">服务器端</span></h3><p>可以使用支持 WHIP 的媒体服务器：</p><ul><li><strong>Janus</strong> - 开源的 WebRTC 网关</li><li><strong>LiveKit</strong> - 现代化的实时音视频平台</li><li><strong>Wowza</strong> - 商业流媒体服务器</li><li><strong>OvenMediaEngine</strong> - 开源流媒体服务器</li></ul><h3><span id="客户端">客户端</span></h3><p>可以用以下工具：</p><ul><li>浏览器原生 <strong>WebRTC API</strong></li><li><strong>OBS</strong> 最新版本的 “WHIP 推流插件”</li><li><strong>ffmpeg</strong> -f whip（最新版也支持）</li></ul><hr><blockquote><p>💡 <strong>提示</strong>：WHIP 协议目前还在 IETF 草案阶段，但已经被多个主流媒体服务器支持，是未来 WebRTC 推流的标准方向。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="视频流技术" scheme="https://smartxia.github.io/blog/categories/%E8%A7%86%E9%A2%91%E6%B5%81%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="WebRTC" scheme="https://smartxia.github.io/blog/tags/WebRTC/"/>
    
    <category term="WHIP" scheme="https://smartxia.github.io/blog/tags/WHIP/"/>
    
    <category term="实时通信" scheme="https://smartxia.github.io/blog/tags/%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
    <category term="直播技术" scheme="https://smartxia.github.io/blog/tags/%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>k8s中如何做到动态分配网络域名</title>
    <link href="https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/"/>
    <id>https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/</id>
    <published>2024-07-17T03:00:56.000Z</published>
    <updated>2024-07-17T03:12:24.348Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s中关于服务网络的使用</title>
    <link href="https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-07-17T02:59:54.000Z</published>
    <updated>2024-07-17T03:02:37.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>golang Context上下文</title>
    <link href="https://smartxia.github.io/blog/2024/07/15/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B08-Context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://smartxia.github.io/blog/2024/07/15/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B08-Context%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2024-07-15T10:56:27.000Z</published>
    <updated>2024-07-31T07:15:10.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="/blog/image.png" alt="alt text"></p><p><a href="https://zhuanlan.zhihu.com/p/68792989">https://zhuanlan.zhihu.com/p/68792989</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>k8s-有状态服务无状态服务和对外访问服务</title>
    <link href="https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-04-12T08:43:25.000Z</published>
    <updated>2024-04-12T08:46:22.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol><li>基本概念<br>无状态服务<br>无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.</li></ol><p>有状态服务<br>有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.</p><ol start="2"><li>Deployment部署的问题?</li></ol><p>Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?</p><p>无状态服务内的多个Pod创建的顺序是没有顺序的.<br>无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化.<br>无状态服务内的多个Pod背后是共享存储的.<br>2.1.新的问题</p><p>对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了.<br>比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致.<br>所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master&#x2F;slave角色)必须有自己独立的持久化存储组件.<br>有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储.<br>所以K8S提供了一个新的工具——StatefulSet来统一解决问题.</p><ol start="3"><li>Stateful如何解决问题?<br>Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.</li></ol><p>而Stateful管理有状态的应用,它的Pod有如下特征:</p><p>唯一性: 每个Pod会被分配一个唯一序号.<br>顺序性: Pod启动,更新,销毁是按顺序进行.<br>稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化.<br>稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.</p><p>3.1. 如何理解稳定网络标识?</p><p>创建名为test-redis-pod的Stateful模型,根据你配置的Replica&#x3D;3的设置,K8S会创建三个Pod,依次命名为: test-redis-pod-0; test-redis-pod-1; test-redis-pod-2</p><p>K8S为有状态的服务Pod分配稳定的网络标识,具体实现基于test-redis-pod-0名称,借助Headless DNS进行如下解析,获取后端其中一个Pod的地址.</p><p>$(pod name).$(service name).$(namespace).svc.cluster.local<br>下面是一个通过Pod名称访问Redis集群的Master节点地址的方法.</p><p>session.save_path &#x3D; “tcp:&#x2F;&#x2F;test-redis-pod-0.test-redis-service.default.svc.cluster.local:6379”<br>现在回答如下二个问题:</p><p>在Redis Pod内部,主从节点之间数据同步的需求,Slave节点对应的配置文件中需要一个稳定的Master地址.下边脚本就是稳定访问test-redis-pod-0 名称来间接获得Redis Master节点IP地址,然后写入到Redis Slave的配置文件中,这样后续Slave节点与Master节点才能完成增量数据的同步.<br>if [ “${server_host}” !&#x3D; “test-redis-pod-0” ];then<br>        #echo “server-count: ${server_counts}” &gt;&gt; &#x2F;data&#x2F;test.log</p><pre><code>    while [ -z &quot;$&#123;master_address&#125;&quot; ];do        echo &quot;master_address is not available, $&#123;master_address&#125; waiting for redis master...&quot; &gt;&gt; /data/test.log        master_address=$(replication_master_address)        sleep 1s    donefiecho &quot;master_address: $(master_address)&quot; &gt;&gt; /data/test.logif [ ! -z &quot;$master_address&quot; ]; then    printf &quot;\nslaveof %s 6379\n&quot; &quot;$master_address&quot; &gt;&gt; $conffi</code></pre><p>在Redis Pod外部, 可以通过$(pod name).$(service name).$(namespace).svc.cluster.local方式来访问具体的Pod服务.<br>3.2. 如何理解稳定持久化存储?</p><p>每个Redis Pod对应一个自己的PVC&#x2F;PV.当Pod发生调度时,需要在别的节点启动时,根据Pod背后关联的存储信息保证其名称的稳定性.</p><p>Pod还是会attach挂载到原来的PV&#x2F;PVC中,从而确定每个Pod有自己专用的存储卷.</p><ol start="4"><li>总结<br>本文主要介绍了无状态和有状态服务在K8S中的典型应用场景.</li></ol><p>通过对Deployment部署无状态服务所遇到问题的分析,引出了Stateful新的部署组件.它是通过支持Pod一些特性(e.g. 名称唯一性,稳定的网络标识, 稳定的持久化存储等)来实现在K8S中部署运维有状态服务.</p><p>牢记: Stateful有状态服务,每个Pod有独立的PVC&#x2F;PV存储组件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-StorageClass PV PVC 概念和使用</title>
    <link href="https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-4-StorageClass%20PV%20PVC/"/>
    <id>https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-4-StorageClass%20PV%20PVC/</id>
    <published>2024-04-12T02:25:53.000Z</published>
    <updated>2024-04-12T07:59:31.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>负责把PVC绑定到PV的是一个持久化存储卷控制循环，这个控制器也是kube-manager-controller的一部分运行在master上。而真正把目录挂载到容器上的操作是在POD所在主机上发生的，所以通过kubelet来完成。而且创建PV以及PVC的绑定是在POD被调度到某一节点之后进行的，完成这些操作，POD就可以运行了。下面梳理一下挂载一个PV的过程：</p><p>用户提交一个包含PVC的POD</p><p>调度器把根据各种调度算法把该POD分配到某个节点，比如node01</p><p>Node01上的kubelet等待Volume Manager准备存储设备</p><p>PV控制器调用存储插件创建PV并与PVC进行绑定</p><p>Attach&#x2F;Detach Controller或Volume Manager通过存储插件实现设备的attach。（这一步是针对块设备存储）</p><p>Volume Manager等待存储设备变为可用后，挂载该设备到&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;&lt;Pod 的 ID&gt;&#x2F;volumes&#x2F;kubernetes.io~&lt;Volume 类型 &gt;&#x2F;&lt;Volume 名字 &gt;目录上</p><p>Kubelet被告知卷已经准备好，开始启动POD，通过映射方式挂载到容器中</p><p>总结：本地卷也就是LPV不支持动态供给的方式，延迟绑定，就是为了综合考虑所有因素再进行POD调度。其根本原因是动态供给是先调度POD到节点，然后动态创建PV以及绑定PVC最后运行POD；而LPV是先创建与某一节点关联的PV，然后在调度的时候综合考虑各种因素而且要包括PV在哪个节点，然后再进行调度，到达该节点后在进行PVC的绑定。也就说动态供给不考虑节点，LPV必须考虑节点。所以这两种机制有冲突导致无法在动态供给策略下使用LPV。换句话说动态供给是PV跟着POD走，而LPV是POD跟着PV走。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记7-error.group用法</title>
    <link href="https://smartxia.github.io/blog/2024/03/26/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/"/>
    <id>https://smartxia.github.io/blog/2024/03/26/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/</id>
    <published>2024-03-26T06:18:21.000Z</published>
    <updated>2024-03-26T07:02:26.582Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4><span id="1-先看下数据结构">1 .先看下数据结构</span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">sem <span class="keyword">chan</span> token</span><br><span class="line"></span><br><span class="line">errOnce sync.Once</span><br><span class="line">err     <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="2在并发编程里-syncwaitgroup">2.在并发编程里 sync.WaitGroup</span></h4><p>并发原语的使用频率非常高，它经常用于协同等待的场景 gorouting 都完成后才能继续执行。</p><p>如果在woker goroutine的执行过程中遇到错误并想要处理该怎么办？</p><p>WaitGroup并没有提供传播错误的功能，遇到这种场景我们该怎么办？Go语言在扩展库提供了ErrorGroup并发原语正好适合在这种场景下使用，它在WaitGroup的基础上还提供了，错误传播以及上下文取消的功能。</p><p>扩展库通过errorgroup.Group提供ErrorGroup原语的功能，它有三个方法可调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func WithContext(ctx context.Context) (*Group, context.Context)</span><br><span class="line">func (g *Group) Go(f func() error)</span><br><span class="line">func (g *Group) Wait() error</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ErrorGroup有一个特点是会返回所以执行任务的goroutine遇到的第一个错误</span></span><br></pre></td></tr></table></figure><h4><span id="3想让程序遇到错误就终止其他子任务">3.想让程序遇到错误就终止其他子任务</span></h4><p>最早执行遇到错误的goroutine输出了Error: 98但是所有未执行完的其他任务并没有停止执行，那么想让程序遇到错误就终止其他子任务该怎么办呢？我们可以用errgroup.Group提供的WithContext方法创建一个带可取消上下文功能的ErrorGroup。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用errorgroup.Group时注意它的两个特点：</span><br><span class="line">- errgroup.Group在出现错误或者等待结束后都会调用 Context对象 的 cancel 方法同步取消信号。</span><br><span class="line">- 只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</span><br><span class="line">*/</span><br><span class="line">func main() &#123;</span><br><span class="line">   eg, ctx := errgroup.WithContext(context.Background())</span><br><span class="line"></span><br><span class="line">   for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">      i := i</span><br><span class="line">      eg.Go(func() error &#123;</span><br><span class="line">         time.Sleep(2 * time.Second)</span><br><span class="line"></span><br><span class="line">         select &#123;</span><br><span class="line">         case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;Canceled:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         default:</span><br><span class="line">            if i &gt; 90 &#123;</span><br><span class="line">               fmt.Println(&quot;Error:&quot;, i)</span><br><span class="line">               return fmt.Errorf(&quot;Error: %d&quot;, i)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(&quot;End:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   if err := eg.Wait(); err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="4cancle到其他的子任务">4.cancle到其他的子任务</span></h4><p>在上面的例子中，子goroutine出现错误后，会cancle到其他的子任务，但是我们并没有看到调用ctx的cancel方法，下面我们看下源码，看看内部是怎么处理的。<br> errgroup 的设计非常精练，全部代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package errgroup</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// A Group is a collection of goroutines working on subtasks that are part of</span><br><span class="line">// the same overall task.</span><br><span class="line">//</span><br><span class="line">// A zero Group is valid and does not cancel on error.</span><br><span class="line">type Group struct &#123;</span><br><span class="line">    cancel func()</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    errOnce sync.Once</span><br><span class="line">    err     error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WithContext returns a new Group and an associated Context derived from ctx.</span><br><span class="line">//</span><br><span class="line">// The derived Context is canceled the first time a function passed to Go</span><br><span class="line">// returns a non-nil error or the first time Wait returns, whichever occurs</span><br><span class="line">// first.</span><br><span class="line">func WithContext(ctx context.Context) (*Group, context.Context) &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    return &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Wait blocks until all function calls from the Go method have returned, then</span><br><span class="line">// returns the first non-nil error (if any) from them.</span><br><span class="line">func (g *Group) Wait() error &#123;</span><br><span class="line">    g.wg.Wait()</span><br><span class="line">    if g.cancel != nil &#123;</span><br><span class="line">        g.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    return g.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Go calls the given function in a new goroutine.</span><br><span class="line">//</span><br><span class="line">// The first call to return a non-nil error cancels the group; its error will be</span><br><span class="line">// returned by Wait.</span><br><span class="line">func (g *Group) Go(f func() error) &#123;</span><br><span class="line">    g.wg.Add(1)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer g.wg.Done()</span><br><span class="line"></span><br><span class="line">        if err := f(); err != nil &#123;</span><br><span class="line">            g.errOnce.Do(func() &#123;</span><br><span class="line">                g.err = err</span><br><span class="line">                if g.cancel != nil &#123;</span><br><span class="line">                    g.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，errgroup 的实现依靠于结构体 Group，它通过封装 sync.WaitGroup，继承了 WaitGroup 的特性，在 Go() 方法中新起一个子任务 goroutine，并在 Wait() 方法中通过 sync.WaitGroup 的 Wait 进行阻塞等待。</p><p>同时 Group 利用 sync.Once 保证了它有且仅会保留第一个子 goroutine 错误。<br> Group 通过嵌入 context.WithCancel 方法产生的 <code>cancel</code> 函数（对于 Context 不熟悉的读者，推荐阅读 <a href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&mid=2247484553&idx=1&sn=ce4c7e052bacf69c38e27d71187726c8&scene=21%23wechat_redirect">理解Context机制</a> 一文），能够<strong>在子 goroutine 发生错误时，及时通过调用 cancle 函数，将 Context 的取消信号及时传播出去。</strong></p><h4><span id="5总结">5.总结:</span></h4><p>使用errorgroup.Group时注意它的特点：</p><ul><li>继承了 WaitGroup 的功能</li><li>errgroup.Group在出现错误或者等待结束后都会调用Context对象 的 cancel 方法同步取消信号。</li><li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</li><li>context 信号传播：如果子任务 goroutine 中有循环逻辑，则可以添加 ctx.Done 逻辑，此时通过 context 的取消信号，提前结束子任务执行。</li></ul><p>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="error.group" scheme="https://smartxia.github.io/blog/tags/error-group/"/>
    
  </entry>
  
  <entry>
    <title>k8s-kubeadmin安装</title>
    <link href="https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/"/>
    <id>https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/</id>
    <published>2024-03-18T03:30:15.000Z</published>
    <updated>2024-04-12T02:34:54.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>通过kubeadm工具，部署k8s集群。操作步骤如下：</p><ol><li><p>准备工作：</p></li><li><ol><li>配置yum源，repo(防被墙)</li><li>安装常用工具，同步时间</li><li>关闭防火墙，将SELinux配置为Permissive模式，关闭swap</li><li>加载ipvs模块，优化内核</li></ol></li><li><p>在所有机器上安装docker</p></li><li><p>在所有机器上安装kubeadm, kubelet, kubectl</p></li><li><p>部署集群Master节点</p></li><li><p>部署集群工作节点</p></li><li><p>安装CNI网络插件</p></li></ol><ul><li>一个Kubernetes集群Master节点。k8s官网现在将master节点称为control plane node(控制平面节点)</li><li>一个Kubernetes集群Slave节点。k8s官网叫worker node(工作节点)。下文中Slave节点和工作节点含义含义相同。</li></ul><table><thead><tr><th>hostname</th><th>ip</th><th>备注</th><th></th></tr></thead><tbody><tr><td>master</td><td>master.k8s</td><td>192.168.246.133</td><td>k8s主节点(control plane node)</td></tr><tr><td>slave</td><td>slave.k8s</td><td>192.168.246.132</td><td>k8s 工作节点(worker node)</td></tr></tbody></table><h2><span id="0-系统要求">0. <strong>系统要求</strong></span></h2><p>安装之前，请确保操作系统满足如下要求：</p><ol><li>Linux内核操作系统，如CentOS，Ubuntu等</li><li>至少2 CPU， 2GB</li><li>集群中所有机器之间的网络必须是通的(公共或私有网络都可以)。</li><li>每个节点都有唯一的主机名、MAC地址和product_uuid</li><li>部署时要保证能连外网</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看操作系统</span></span></span><br><span class="line">cat /proc/version</span><br><span class="line">hostnamectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看IP和MAC命令</span></span></span><br><span class="line">ip link</span><br><span class="line">ifconfig -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看product_uuid</span></span></span><br><span class="line">sudo cat /sys/class/dmi/id/product_uuid</span><br></pre></td></tr></table></figure><h2><span id="1-准备工作"><strong>1. 准备工作</strong></span></h2><p><strong>在所有节点上运行</strong></p><h3><span id="11-配置yum源repo"><strong>1.1 配置yum源，repo</strong></span></h3><p>由于众所周知的原因，为防止在安装时出现资源下载失败的问题，在所有节点上配置yum源，repo。shell如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum源</span></span><br><span class="line">curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker repo</span></span><br><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes repo</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure><h3><span id="12-安装常用的工具同步时间"><strong>1.2 安装常用的工具，同步时间</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum -y install tree vim wget bash-completion bash-completion-extras lrzsz net-tools sysstat iotop iftop htop unzip nc nmap telnet bc  psmisc httpd-tools ntpdate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时区修改,如果/etc/localtime有软连接,不是Shanghai,可以直接删除,在软链接</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate ntp2.aliyun.com            # 同步阿里云服务器上的时间.</span><br><span class="line">/sbin/hwclock --systohc            # 写入到bios系统    </span><br></pre></td></tr></table></figure><h3><span id="13-检查防火墙是否关闭将selinux配置为permissive模式关闭swap"><strong>1.3 检查防火墙是否关闭，将SELinux配置为Permissive模式，关闭swap</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看防火墙状态</span></span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果防火墙是running，关闭防火墙</span></span></span><br><span class="line">sudo systemctl disable firewalld &amp;&amp; systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Set SELinux to permissive mode.将SELinux配置为Permissive模式</span></span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 也可以直接关闭SELinux</span></span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo setenforce 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo sed -ri <span class="string">&#x27;s#(SELINUX=).*#\1disabled#&#x27;</span> /etc/selinux/config</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时关闭swap。如果不关闭，kubelet会启动失败</span></span><br><span class="line">sudo swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久防止开机自动挂载swap</span></span><br><span class="line">sudo sed -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h3><span id="14-加载ipvs模块优化内核"><strong>1.4 加载ipvs模块，优化内核</strong></span></h3><p>如下参数不修改，会导致<code>kubeadm init</code>运行失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载ipvs模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证ip_vs模块</span></span><br><span class="line">lsmod |grep ip_vs</span><br><span class="line">ip_vs_wrr              12697  0 </span><br><span class="line">ip_vs_rr               12600  0 </span><br><span class="line">ip_vs_sh               12688  0 </span><br><span class="line">ip_vs                 145458  6 ip_vs_rr,ip_vs_sh,ip_vs_wrr</span><br><span class="line">nf_conntrack          139264  2 ip_vs,nf_conntrack_ipv4</span><br><span class="line">libcrc32c              12644  3 xfs,ip_vs,nf_conntrack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核文件</span> </span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效并验证内核优化</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><h2><span id="2-安装docker"><strong>2. 安装docker</strong></span></h2><p><em>在所有节点上运行</em></p><h3><span id="21-安装启动docker"><strong>2.1 安装启动docker</strong></span></h3><p>注意：安装docker需要root权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. yum 安装</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 运行sudo yum install docker-ce 也是可以的，docker-ce依赖了docker-ce-cli, containerd.io, docker-buildx-plugin, docker-compose-plugin。这些依赖会同步install</span></span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 配置docker</span></span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://registry.hub.docker.com&quot;,</span><br><span class="line">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 启动docker</span></span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>验证是否安装正确</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4. docker运行正常</span></span><br><span class="line">[shirley@master k8s_install]$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2023-10-10 09:23:41 CST; 19s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 16381 (dockerd)</span><br><span class="line">    Tasks: 8</span><br><span class="line">   Memory: 27.4M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─16381 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/con...</span><br><span class="line">[shirley@master k8s_install]$</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行docker命令，验证镜像下载正常，容器运行正常</span></span><br><span class="line">[shirley@slave k8s_install]$ sudo docker run hello-world</span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">719385e32844: Pull complete</span><br><span class="line">Digest: sha256:4f53e2564790c8e7856ec08e384732aa38dc43c52f02952483e3f003afbf23db</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h3><span id="22-配置containerd中pause镜像地址"><strong>2.2 配置containerd中pause镜像地址</strong></span></h3><p>为了防止安装过程中出现pause镜像下载失败的问题，建议运行<code>containerd config dump &gt; /etc/containerd/config.toml </code>命令，将当前配置导出到文件，并修改<code>sandbox_image</code>配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果没有/etc/containerd/config.toml文件，将默认配置导出到/etc/containerd/config.toml。</span></span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置</span></span></span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># PS: 如果生成的/etc/containerd/config.toml中没有如上配置项，可以运行如下命令导出当前所有配置项后再修改文件/etc/containerd/config.toml</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">containerd config dump &gt; /etc/containerd/config.toml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重启containerd</span></span></span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h2><span id="3-部署kubeadm-kubelet-kubectl"><strong>3. 部署kubeadm, kubelet, kubectl</strong></span></h2><p>kubeadm：启动k8s集群的工具</p><p>kubelet: 该组件在集群中的所有机器上运行，并执行启动pod和容器之类的任务。</p><p>kubectl: 与集群通信的工具。可以只在master节点上安装。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">## 开机启动kubelet</span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看kubeadm版本</span></span><br><span class="line">[root@master ~]<span class="comment"># sudo kubeadm version</span></span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:<span class="string">&quot;1&quot;</span>, Minor:<span class="string">&quot;28&quot;</span>, GitVersion:<span class="string">&quot;v1.28.2&quot;</span>, GitCommit:<span class="string">&quot;89a4ea3e1e4ddd7f7572286090359983e0387b2f&quot;</span>, GitTreeState:<span class="string">&quot;clean&quot;</span>, BuildDate:<span class="string">&quot;2023-09-13T09:34:32Z&quot;</span>, GoVersion:<span class="string">&quot;go1.20.8&quot;</span>, Compiler:<span class="string">&quot;gc&quot;</span>, Platform:<span class="string">&quot;linux/amd64&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2><span id="4-初始化master节点kubeadm-init"><strong>4.</strong> 初始化Master节点（kubeadm init）</span></h2><p><em>在Master节点运行</em></p><h3><span id="41-更改配置文件"><strong>4.1. 更改配置文件</strong></span></h3><p><code>kubeadm init</code>命令用于初始化master节点。kubeadm init 的参数可以通过<strong>命令行</strong>或<strong>yaml文件</strong>进行配置。本文介绍如何通过yaml文件进行配置。可以通过<code>kubeadm config print init-defaults</code>命令得到一份默认配置，然后对其进行修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm.yaml</span><br></pre></td></tr></table></figure><p>对kubeadm.yaml进行编辑，修改内容如下：</p><ol><li>修改<code>advertiseAddress</code>为master IP地址</li><li><code>imageRepository</code>修改为<code>registry.aliyuncs.com/google_containers</code>，防止镜像拉不下来</li><li>建议将<code>networking.podSubnet</code>修改为<code>10.244.0.0/16</code>， 和后续安装的flannel CNI 插件的默认配置保持一致。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.246.133    ## change the IP of apiserver.</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: node</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers   ## change imageRepository to aliyun.</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.28.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  podSubnet: 10.244.0.0/16  ## add this line to config POD network. Same with CNI config.</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure><p>如上配置文件等价于命令行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.246.133 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.28.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 </span><br></pre></td></tr></table></figure><ul><li>–apiserver-advertise-address 集群通告地址</li><li>–image-repository 由于默认拉取镜像地址<a href="https://link.zhihu.com/?target=http://k8s.gcr.io">http://k8s.gcr.io</a>国内无法访问，这里指定阿里云镜像仓库地址</li><li>–kubernetes-version K8s版本，与上面安装的一致</li><li>–service-cidr 集群内部虚拟网络，Pod统一访问入口</li><li>–pod-network-cidr Pod网络，<strong>与下面部署的CNI网络组件yaml中保持一致</strong></li></ul><h3><span id="42-提前pull镜像可选"><strong>4.2 提前pull镜像（可选）</strong></span></h3><p>为了使后续安装更快，建议先把安装需要的镜像pull下来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 验证配置文件格式是否正确</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config validate --config kubeadm.yaml</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看需要下载哪些镜像。需要关注下载的repository地址是否正确。</span></span><br><span class="line"><span class="comment">## 如上在kubeadm.yaml文件配置了imageRepository：registry.aliyuncs.com/google_containers，因此images会从aliyun的repo下载。</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config images list --config kubeadm.yaml</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">## pull镜像。pull镜像有点慢，第一个镜像pull成功后才有日志输出。命令运行后发现没有日志不要着急，多等一会。</span></span><br><span class="line">[shirley@master k8s_install]$ sudo kubeadm config images pull --config kubeadm.yaml</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><h3><span id="43-kubeadm-init初始化"><strong>4.3 kubeadm init初始化</strong></span></h3><p>运行<code>kubeadm init --config kubeadm.yaml</code>， 当看到<code>Your Kubernetes control-plane has initialized successfully!</code>时表示安装成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master k8s_install]<span class="comment"># kubeadm init --config kubeadm.yaml</span></span><br><span class="line">... ...</span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p><strong>PS：最好将最后一行log需要记下来，worker节点安装会用到。</strong></p><p>根据提示，退出root账户后运行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><h3><span id="44-验证"><strong>4.4 验证</strong></span></h3><p>验证master节点是否部署成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## kubectl 运行正常. STATUS=NotReady是因为CNI插件还没装。</span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME   STATUS     ROLES           AGE   VERSION</span><br><span class="line">node   NotReady   control-plane   20m   v1.28.2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 通过crictl命令可以查看到运行的container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo crictl ps -a</span><br><span class="line">CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID              POD</span><br><span class="line">955b0c87ad621       ea1030da44aa1       26 minutes ago      Running             kube-proxy                0                   78efbee65dfac       kube-proxy-kp9kw</span><br><span class="line">f69d8c3246904       73deb9a3f7025       26 minutes ago      Running             etcd                      0                   77180bc7ff0a8       etcd-node</span><br><span class="line">3efba65f263d3       f6f496300a2ae       26 minutes ago      Running             kube-scheduler            0                   f89fb4bb60e2e       kube-scheduler-node</span><br><span class="line">5dfb28390f30b       4be79c38a4bab       26 minutes ago      Running             kube-controller-manager   0                   b716cb4652e1c       kube-controller-manager-node</span><br><span class="line">b8cfce31fa842       bb5e0dde9054c       26 minutes ago      Running             kube-apiserver            0                   006db1ce43cfe       kube-apiserver-node</span><br></pre></td></tr></table></figure><p>这里有大家可能有个疑惑，为什么docker ps看不到运行的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 运行docker命令，发现没有container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><p>这是因为kubernetes使用的containerd作为容器运行时，而不是Docker engine. kubernetes支持4中容器运行时：</p><table><thead><tr><th>Runtime</th><th>Path to Unix domain socket（CRI socket）</th></tr></thead><tbody><tr><td>containerd</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock</td></tr><tr><td>CRI-O</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;crio&#x2F;crio.sock</td></tr><tr><td>Docker Engine (using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr><tr><td>Mirantis Container Runtime (MCR)(using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr></tbody></table><p>By default, Kubernetes uses the Container Runtime Interface (CRI) to interface with your chosen container runtime.</p><p>默认情况下，kubernetes会用CRI找到选择的容器运行时。在我们安装docker时，安装了containerd，因此k8s找到了containerd作为容器运行时。在kubeadm.yam文件中也能看到相应的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>为什么k8s不选用docker engine作为容器运行时？因为如果使用docker engine, 还需要安装cri-dockerd，才能作为容器时被k8s识别。而如上操作并未安装。</p><p>此外，k8s推荐直接使用containerd作为容器运行时。</p><h2><span id="5-初始化工作节点"><strong>5. 初始化工作节点</strong></span></h2><h3><span id="51-运行kubeadm-join将工作节点加入集群"><strong>5.1 运行kubeadm join将工作节点加入集群</strong></span></h3><p>在master节点kubeadm init安装完成后，会有如下类似log</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.. ... </span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p>将上述命令粘贴到工作节点，将工作节点添加到集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slave ~]# kubeadm join 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot; could not be reached</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot;: lookup slave.k8s on 192.168.246.2:53: no such host</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><h3><span id="52-验证"><strong>5.2 验证</strong></span></h3><p>到master节点运行kubelet get node,可以看到加进来的node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl get nodes</span><br><span class="line">NAME        STATUS     ROLES           AGE    VERSION</span><br><span class="line">node        NotReady   control-plane   121m   v1.28.2</span><br><span class="line">slave.k8s   NotReady   &lt;none&gt;          28s    v1.28.2</span><br></pre></td></tr></table></figure><p>当前STATUS都是NotReady，这是因为还没有安装网络插件CNI</p><h3><span id="53-忘记token怎么办"><strong>5.3 忘记token怎么办</strong></span></h3><p>如果master节点安装时，没有记录下token，或token超时(默认24小时)，可以运行如下命令重新生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubeadm token create --print-join-command</span><br><span class="line">kubeadm join 192.168.246.133:6443 --token by8q23.65btteq9iud7ypso --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><h2><span id="6-安装cni网络插件"><strong>6. 安装CNI网络插件</strong></span></h2><p>Kubernetes 它需要网络插件来提供集群内部和集群外部的网络通信。以下是一些常用的 k8s 网络插件：</p><ul><li>Flannel：Flannel 是最常用的 k8s 网络插件之一，它使用了虚拟网络技术来实现容器之间的通信，支持多种网络后端，如 VXLAN、UDP 和 Host-GW。</li><li>Calico：Calico 是一种基于 BGP 的网络插件，它使用路由表来路由容器之间的流量，支持多种网络拓扑结构，并提供了安全性和网络策略功能。</li><li>Canal：Canal 是一个组合了 Flannel 和 Calico 的网络插件，它使用 Flannel 来提供容器之间的通信，同时使用 Calico 来提供网络策略和安全性功能。</li><li>Weave Net：Weave Net 是一种轻量级的网络插件，它使用虚拟网络技术来为容器提供 IP 地址，并支持多种网络后端，如 VXLAN、UDP 和 TCP&#x2F;IP，同时还提供了网络策略和安全性功能。</li><li>Cilium：Cilium 是一种基于 eBPF (Extended Berkeley Packet Filter) 技术的网络插件，它使用 Linux 内核的动态插件来提供网络功能，如路由、负载均衡、安全性和网络策略等。</li><li>Contiv：Contiv 是一种基于 SDN 技术的网络插件，它提供了多种网络功能，如虚拟网络、网络隔离、负载均衡和安全策略等。</li><li>Antrea：Antrea 是一种基于 OVS (Open vSwitch) 技术的网络插件，它提供了容器之间的通信、网络策略和安全性等功能，还支持多种网络拓扑结构。</li></ul><table><thead><tr><th>提供商</th><th>网络模型</th><th>路线分发</th><th>网络策略</th><th>网格</th><th>外部数据存储</th><th>加密</th><th>Ingress&#x2F;Egress 策略</th></tr></thead><tbody><tr><td>Canal</td><td>封装 (VXLAN)</td><td>否</td><td>是</td><td>否</td><td>K8s API</td><td>是</td><td>是</td></tr><tr><td>Flannel</td><td>封装 (VXLAN)</td><td>否</td><td>否</td><td>否</td><td>K8s API</td><td>是</td><td>否</td></tr><tr><td>Calico</td><td>封装（VXLAN，IPIP）或未封装</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr><tr><td>Weave</td><td>封装</td><td>是</td><td>是</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Cilium</td><td>封装 (VXLAN)</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr></tbody></table><p>Calico 和 Flannel都是常用的CNI，如下介绍如何安装flannel网络插件</p><h3><span id="61-安装flannel网络插件"><strong>6.1 安装flannel网络插件</strong></span></h3><ol><li>下载kube-flannel.yml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. 下载kube-flannel.yml</span></span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p><code>kube-flannel.yaml</code>文件中，需要注意，net-conf.json里的network要和kubeadm.yaml里配置的networking.podSubnet相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      ### 这里的network和kubeadm.yaml里配置的networking.podSubnet相同 </span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><ol start="2"><li>容器部署flannel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl apply -f kube-flannel.yml</span><br><span class="line">namespace/kube-flannel created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure><h3><span id="62-验证cni"><strong>6.2 验证CNI</strong></span></h3><p>安装后，运行<code>kubectl -n kube-system get pod -o wide</code>， 可以看到在master节点和slave节点分别运行了一个kube-proxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 每个节点上都运行了kube-proxy</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl -n kube-system get pod -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE     IP                NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66f779496c-d8rws       1/1     Running   0          4h40m   10.244.0.3        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66f779496c-fzmjm       1/1     Running   0          4h40m   10.244.0.2        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-node                      1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-node   1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-bpv8d               1/1     Running   0          160m    192.168.246.132   slave.k8s   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-kp9kw               1/1     Running   0          4h40m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># node状态显示为Ready</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME        STATUS   ROLES           AGE     VERSION</span><br><span class="line">node        Ready    control-plane   4h38m   v1.28.2</span><br><span class="line">slave.k8s   Ready    &lt;none&gt;          158m    v1.28.2</span><br></pre></td></tr></table></figure><p>自此，集群搭建完成。</p><h2><span id="其他说明"><strong>其他说明</strong></span></h2><p>另外，在初始安装的Master节点上也启动了<code>kubelet</code>和<code>kube-proxy</code>，在默认情况下并不参与工作负载的调度。如果希望Master节点也作为Node角色，则可以运行下面的命令（删除Master节点的：<code>node-role.kubernetes.io/control-plane:NoSchedule</code>），让Master节点也成为一个Node：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-IPVS概念原理以及应用</title>
    <link href="https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2024-03-18T03:24:31.000Z</published>
    <updated>2024-04-12T02:34:47.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="ipvs的概念-原理及应用">IPVS的概念、原理及应用</span></h3><h3><span id="一-什么是ipvs">一、什么是IPVS</span></h3><p>LVS（Linux 虚拟服务器）和 IPVS（IP 虚拟服务器）是 Linux 中用于构建可扩展和高性能网络服务的两种相关技术。</p><p>LVS 是 Linux 系统的内核级负载均衡解决方案。 它允许您在多个服务器之间分配传入的网络流量，创建一个服务器集群，在客户端看来就像一个虚拟服务器。 LVS 中的负载均衡算法可以根据各种因素（例如循环法、最少连接数和源 IP 哈希）来分配流量。 </p><h3><span id="二-ipvs的工作原理">二、IPVS的工作原理</span></h3><p>IPVS的工作原理基于网络地址转换（Network Address Translation，NAT）和端口转换（Port Translation）。</p><p>当一个网络请求到达IPVS，IPVS会根据预设的调度算法选择一个后端服务器，然后修改网络请求的目标IP地址和端口，使其指向选择的后端服务器。</p><p>当后端服务器处理完请求后，IPVS会将服务器的响应转发回原始请求的客户端。</p><p>在这个过程中，客户端并不知道实际上是哪个后端服务器处理了它的请求。</p><h3><span id="三-ipvs的主要特性">三、IPVS的主要特性</span></h3><p>丰富的调度算法：IPVS支持多种调度算法，包括最小连接（Least-Connection）、轮询（Round-Robin）和加权轮询（Weighted Round-Robin）等，满足不同应用场景的需求。<br>健康检查：IPVS能够定期对后端服务器进行健康检查，当检测到某个服务器故障时，可以将其从服务列表中移除，防止向故障服务器发送请求。<br>高性能：由于IPVS是Linux内核的一部分，因此处理网络请求的效率非常高。IPVS支持大规模并发连接，能够处理每秒数以万计的网络请求。<br>易于集成：IPVS可以与其他Linux内核模块和用户空间工具一起使用，如iptables和keepalived等，提供更加强大和灵活的网络服务。</p><h3><span id="四-ipvs的应用场景">四、IPVS的应用场景</span></h3><p>IPVS广泛应用于大规模的互联网服务，如网站、在线视频和游戏等，提供高可用性和高性能的网络服务。</p><p>此外，IPVS也在云计算、大数据和容器技术等领域有广泛的应用，例如在Kubernetes中，IPVS作为服务代理的一种模式，为集群内的服务提供负载均衡。</p><p>综上所述，LVS 是 Linux 系统的综合负载均衡解决方案，而 IPVS 是 LVS 中专门处理 IP 负载均衡的组件。 LVS 利用 IPVS 在多个真实服务器之间分发流量，并为各种网络服务提供可扩展性和容错性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>PHP-析构函数-destruct</title>
    <link href="https://smartxia.github.io/blog/2024/03/12/tech/backend/php/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
    <id>https://smartxia.github.io/blog/2024/03/12/tech/backend/php/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</id>
    <published>2024-03-12T03:55:12.845Z</published>
    <updated>2024-03-12T03:55:12.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3><span id="析构函数destruct">析构函数destruct</span></h3><p><img src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：__construct()在初始化对象的时候默认执行的<br>析构函数：__destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data = [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#x27;appkey&#x27;] = getAppkey();</span><br><span class="line">        $data[&#x27;channel&#x27;] = getChannel();</span><br><span class="line">        $this-&gt;data[] = $data;</span><br><span class="line">        //这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id = $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#x27;id &lt;&#x27; =&gt; $id - 50000</span><br><span class="line">            ], &#x27;&#x27;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend=new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
    <category term="php" scheme="https://smartxia.github.io/blog/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2024/03/12/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
    <id>https://smartxia.github.io/blog/2024/03/12/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</id>
    <published>2024-03-12T03:55:12.820Z</published>
    <updated>2024-03-12T03:55:12.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. := = ==</span><br><span class="line"></span><br><span class="line">:= 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">= 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">== 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 := make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val := make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">ch := make(chan int, 100) // make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">// 并把值赋给 v</span><br><span class="line">​```</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>darp Docs</title>
    <link href="https://smartxia.github.io/blog/2022/03/16/tech/devops/darp-Docs/"/>
    <id>https://smartxia.github.io/blog/2022/03/16/tech/devops/darp-Docs/</id>
    <published>2022-03-16T06:59:18.000Z</published>
    <updated>2024-03-12T03:55:12.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>dapr 文档贡献<br>dapr 文档贡献规则：<a href="https://docs.dapr.io/zh-hans/contributing/contributing-docs/">https://docs.dapr.io/zh-hans/contributing/contributing-docs/</a></p><p>dapr 文档网站使用hugo 开发工具：</p><p>Windows：安装流程<br>安装scoope<br>powerSheel ：执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br><span class="line"></span><br><span class="line">iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)</span><br><span class="line"></span><br><span class="line">执行scoope help 查看是否安装正常</span><br><span class="line"></span><br><span class="line">执行   scoop install hugo</span><br><span class="line">      scoop install hugo-extended</span><br><span class="line">这两部即可 完成对其安装</span><br><span class="line"></span><br><span class="line">文档：https://gohugo.io/getting-started/installing/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="1执行doc仓库下载和安装依赖">1.执行doc仓库下载和安装依赖</span></h3><p>仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https://github.com.cnpmjs.org/dapr/docs.git</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">这步可能遇到下载不下来情况，可以按照此步骤进行操作</span><br><span class="line"></span><br><span class="line">1.执行 git submodule update --init</span><br><span class="line">2.去.gitmodules文件 进行编辑将所有的https://github.com  后缀加上 cnpmjs.org</span><br><span class="line">(这个原理可以参考:谷歌插件---GitHub加速1.3.5)</span><br><span class="line">3.然后利用git submodule sync更新子项目对应的url</span><br><span class="line">4.git submodule update --init --recursive，最后执行</span><br><span class="line"></span><br><span class="line">//s2-cdn.oneitfarm.com/6d3518411d074f9eae604f77da39da83.png</span><br></pre></td></tr></table></figure><p><img src="//s2-cdn.oneitfarm.com/a23f2220daff4375ba97522c7edc552c.png"></p><p>错误1.</p><p><img src="//s2-cdn.oneitfarm.com/c036d24abc364f00be0870faec874818.png" alt="image-20220316151455745"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用git代理：</span><br><span class="line">git config *--global https.proxy*</span><br><span class="line">执行命令后取消代理</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>错误2：</p><p><img src="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png" alt="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是因为没有执行git module的 下载</span><br></pre></td></tr></table></figure><h3><span id="2安装依赖">2.安装依赖</span></h3><p>此项目使用的还是npm </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install （很慢） </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="dapr" scheme="https://smartxia.github.io/blog/categories/dapr/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc-2</title>
    <link href="https://smartxia.github.io/blog/2021/12/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B013grpc-2/"/>
    <id>https://smartxia.github.io/blog/2021/12/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B013grpc-2/</id>
    <published>2021-12-09T07:05:54.000Z</published>
    <updated>2024-03-12T03:55:12.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>脑图：</p><p><a href="https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5">https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5</a></p><p>服务端的操作：</p><p>取出server</p><p>挂载方法</p><p>注册服务</p><p>创建监听</p><p>客户端：</p><p>创建链接</p><p>new 一个client</p><p>调用client方法</p><p>获取返回值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>x86和arm架构区别</title>
    <link href="https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-12-02T08:22:44.000Z</published>
    <updated>2024-03-12T03:55:12.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是arm架构">什么是arm架构</span></h3><p>ARM架构过去称之为进阶精简指令集机器，是一个32位的精简指令集（RISC）处理器架构，其广泛的使用在嵌入式系统设计，由于节能的特点，ARM非常适合处理移动通讯领域，符合其设计目标低消耗 电量的特性，在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.</p><p>arm架构图</p><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据&#x2F;地址寄存器组成.</p><p><img src="http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg"></p><p>1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</p><p>2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移&#x2F;右移n位、环移n位和算术右移n位等都可以一次完成。</p><p>3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1&#x2F;3）。</p><p>4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</p><p>5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</p><p>6、寄存器</p><h2><span id="x86架构"><strong>x86架构</strong></span></h2><p><img src="http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg"></p><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><p>   1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</p><p>　2： 北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</p><p>　3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I&#x2F;O总线较多，离处理器远一点有利于布线。</p><p>　4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p><p>　5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</p><p>　6：显示j接口</p><p>　7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>　8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</p><p>　9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</p><p>　10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</p><p>　11：总线</p><h2><span id="arm架构和x86架构有什么区别"><strong>arm架构和x86架构有什么区别</strong></span></h2><p><strong>一、性能</strong> </p><p>​    X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。</p><p>　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.</p><p><strong>二、扩展能力</strong></p><p>​    X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.</p><p>　　ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.</p><p> <strong>三、操作系统的兼容性</strong></p><p>​    X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。</p><p>　　ARM系统几乎都采用<strong>Linux</strong>的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的<strong>Android</strong>系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.</p><p><strong>四、软件开发的方便性及可使用工具的多样性</strong></p><p>​    X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。</p><p>　　Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。</p><p>　　对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。</p><p>　　从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：<strong>功耗.</strong></p><p><strong>五、功耗</strong> </p><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
  </entry>
  
</feed>
