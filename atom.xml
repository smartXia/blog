<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏夏天的技术博客</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>以地事秦 犹抱薪救火 薪不尽 火不灭</subtitle>
  <link href="https://smartxia.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2025-10-15T09:25:00.950Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebRTC/WHIP 区别详解</title>
    <link href="https://smartxia.github.io/blog/2025/10/15/%E8%A7%86%E9%A2%91%E6%B5%81/WebRTC-WHIP-%E5%8C%BA%E5%88%AB/"/>
    <id>https://smartxia.github.io/blog/2025/10/15/%E8%A7%86%E9%A2%91%E6%B5%81/WebRTC-WHIP-%E5%8C%BA%E5%88%AB/</id>
    <published>2025-10-15T09:19:46.000Z</published>
    <updated>2025-10-15T09:25:00.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="概述">概述</span></h2><p>WebRTC 和 WHIP 是两种不同的技术。简单说：</p><p>🧠 <strong>WebRTC</strong> 是通信协议族<br>🚀 <strong>WHIP</strong> 是用于推流（Ingest）的 WebRTC 标准化子协议</p><h2><span id="一-概念对比总览">一、概念对比总览</span></h2><table><thead><tr><th>项目</th><th>WebRTC</th><th>WHIP</th></tr></thead><tbody><tr><td><strong>全称</strong></td><td>Web Real-Time Communication</td><td>WebRTC-HTTP Ingestion Protocol</td></tr><tr><td><strong>定位</strong></td><td>一整套实时音视频传输协议（P2P 实时通信标准）</td><td>用 HTTP 封装 WebRTC 推流到服务器的简化协议</td></tr><tr><td><strong>标准组织</strong></td><td>W3C &#x2F; IETF</td><td>IETF (draft-ietf-wish-whip)</td></tr><tr><td><strong>使用场景</strong></td><td>浏览器与浏览器、浏览器与服务端之间的实时通信</td><td>客户端（如 OBS、浏览器、摄像头）推流到媒体服务器（如 Wowza、Janus、LiveKit、Millicast）</td></tr><tr><td><strong>信令机制</strong></td><td>自定义（开发者自己实现信令）</td><td>通过 HTTP POST&#x2F;DELETE 标准化信令</td></tr><tr><td><strong>传输协议</strong></td><td>SRTP + DTLS + ICE (UDP)</td><td>同 WebRTC，底层依然是 SRTP + DTLS + ICE</td></tr><tr><td><strong>推流&#x2F;拉流角色</strong></td><td>双方对等（peer-to-peer）</td><td>单向：Publisher → Media Server</td></tr><tr><td><strong>典型用途</strong></td><td>视频会议、实时互动</td><td>WebRTC 直播推流（低延迟直播）</td></tr></tbody></table><h2><span id="二-whip-的设计背景">二、WHIP 的设计背景</span></h2><p>WebRTC 本身只定义了音视频传输层（媒体、网络、加密），但<strong>不定义信令层</strong>。<br>也就是说，如何交换 SDP（Session Description Protocol）、如何建立连接由开发者自己决定。</p><p>→ 这让”推流场景”实现起来很复杂，每个平台信令都不一样。</p><p>💡 所以 IETF 推出了 <strong>WHIP</strong>（WebRTC-HTTP Ingestion Protocol），<br>目标是让 WebRTC 像 RTMP 一样容易推流：</p><ol><li>用一个 <strong>HTTP POST</strong> 发起推流（发送 SDP offer）</li><li>服务器返回 <strong>SDP answer</strong></li><li>推流端开始传输媒体流</li><li>用 <strong>HTTP DELETE</strong> 停止推流</li></ol><p>这样浏览器、OBS、GStreamer 等工具可以用统一接口推流到任意支持 WHIP 的服务器。</p><h2><span id="三-whip-工作流程示例">三、WHIP 工作流程示例</span></h2><p>👇 <strong>WHIP 推流时序图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[Client]                        [Media Server]</span><br><span class="line">   |                                  |</span><br><span class="line">   |  POST /whip-endpoint             |</span><br><span class="line">   |  Content-Type: application/sdp   |</span><br><span class="line">   |  Body: SDP offer                 |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |       201 Created                |</span><br><span class="line">   |  Location: /resource/id          |</span><br><span class="line">   |  Body: SDP answer                |</span><br><span class="line">   |&lt;---------------------------------|</span><br><span class="line">   |                                  |</span><br><span class="line">   |------ ICE Candidate Exchange ----|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  (Start sending RTP media)       |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  DELETE /resource/id             |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  (Stop streaming)                |</span><br></pre></td></tr></table></figure><h2><span id="四-whip-与传统-rtmp-推流对比">四、WHIP 与传统 RTMP 推流对比</span></h2><table><thead><tr><th>对比项</th><th>RTMP</th><th>WHIP</th></tr></thead><tbody><tr><td><strong>协议层</strong></td><td>TCP</td><td>UDP (SRTP over ICE)</td></tr><tr><td><strong>延迟</strong></td><td>秒级（2~5s）</td><td>低于 500ms</td></tr><tr><td><strong>推流接口</strong></td><td>统一（rtmp:&#x2F;&#x2F;…）</td><td>标准化 HTTP (REST API)</td></tr><tr><td><strong>推流格式</strong></td><td>FLV</td><td>SDP + RTP</td></tr><tr><td><strong>是否加密</strong></td><td>否（或 TLS）</td><td>强制 DTLS + SRTP</td></tr><tr><td><strong>主要用途</strong></td><td>点播直播</td><td>超低延迟互动直播</td></tr></tbody></table><h2><span id="五-whip-的反向协议whep">五、WHIP 的反向协议：WHEP</span></h2><p><strong>WHIP</strong> 是 推流（Ingest），<br>而 <strong>WHEP</strong>（WebRTC-HTTP Egress Protocol） 是 拉流（Playback） 标准化协议。</p><p>二者配合可以替代 RTMP + HLS 的整套流程：</p><table><thead><tr><th>方向</th><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>推流</td><td>WHIP</td><td>客户端 → 服务端</td></tr><tr><td>拉流</td><td>WHEP</td><td>服务端 → 播放端</td></tr></tbody></table><h2><span id="六-总结">六、总结</span></h2><p><strong>WebRTC</strong> 是底层传输标准，<strong>WHIP</strong> 是基于 WebRTC 的统一推流信令协议。<br>WHIP 让”WebRTC 推流”像”RTMP 推流”一样简单。</p><h2><span id="七-实际应用">七、实际应用</span></h2><p>如果你要在实际项目中使用：</p><h3><span id="服务器端">服务器端</span></h3><p>可以使用支持 WHIP 的媒体服务器：</p><ul><li><strong>Janus</strong> - 开源的 WebRTC 网关</li><li><strong>LiveKit</strong> - 现代化的实时音视频平台</li><li><strong>Wowza</strong> - 商业流媒体服务器</li><li><strong>OvenMediaEngine</strong> - 开源流媒体服务器</li></ul><h3><span id="客户端">客户端</span></h3><p>可以用以下工具：</p><ul><li>浏览器原生 <strong>WebRTC API</strong></li><li><strong>OBS</strong> 最新版本的 “WHIP 推流插件”</li><li><strong>ffmpeg</strong> -f whip（最新版也支持）</li></ul><hr><blockquote><p>💡 <strong>提示</strong>：WHIP 协议目前还在 IETF 草案阶段，但已经被多个主流媒体服务器支持，是未来 WebRTC 推流的标准方向。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="视频流技术" scheme="https://smartxia.github.io/blog/categories/%E8%A7%86%E9%A2%91%E6%B5%81%E6%8A%80%E6%9C%AF/"/>
    
    
    <category term="WebRTC" scheme="https://smartxia.github.io/blog/tags/WebRTC/"/>
    
    <category term="WHIP" scheme="https://smartxia.github.io/blog/tags/WHIP/"/>
    
    <category term="实时通信" scheme="https://smartxia.github.io/blog/tags/%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1/"/>
    
    <category term="直播技术" scheme="https://smartxia.github.io/blog/tags/%E7%9B%B4%E6%92%AD%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>k8s中如何做到动态分配网络域名</title>
    <link href="https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/"/>
    <id>https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/</id>
    <published>2024-07-17T03:00:56.000Z</published>
    <updated>2024-07-17T03:12:24.348Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s中关于服务网络的使用</title>
    <link href="https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://smartxia.github.io/blog/2024/07/17/tech/devops/k8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-07-17T02:59:54.000Z</published>
    <updated>2024-07-17T03:02:37.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>golang Context上下文</title>
    <link href="https://smartxia.github.io/blog/2024/07/15/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B08-Context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://smartxia.github.io/blog/2024/07/15/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B08-Context%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2024-07-15T10:56:27.000Z</published>
    <updated>2024-07-31T07:15:10.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="/blog/image.png" alt="alt text"></p><p><a href="https://zhuanlan.zhihu.com/p/68792989">https://zhuanlan.zhihu.com/p/68792989</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>k8s-有状态服务无状态服务和对外访问服务</title>
    <link href="https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-04-12T08:43:25.000Z</published>
    <updated>2024-04-12T08:46:22.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol><li>基本概念<br>无状态服务<br>无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.</li></ol><p>有状态服务<br>有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.</p><ol start="2"><li>Deployment部署的问题?</li></ol><p>Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?</p><p>无状态服务内的多个Pod创建的顺序是没有顺序的.<br>无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化.<br>无状态服务内的多个Pod背后是共享存储的.<br>2.1.新的问题</p><p>对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了.<br>比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致.<br>所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master&#x2F;slave角色)必须有自己独立的持久化存储组件.<br>有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储.<br>所以K8S提供了一个新的工具——StatefulSet来统一解决问题.</p><ol start="3"><li>Stateful如何解决问题?<br>Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.</li></ol><p>而Stateful管理有状态的应用,它的Pod有如下特征:</p><p>唯一性: 每个Pod会被分配一个唯一序号.<br>顺序性: Pod启动,更新,销毁是按顺序进行.<br>稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化.<br>稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.</p><p>3.1. 如何理解稳定网络标识?</p><p>创建名为test-redis-pod的Stateful模型,根据你配置的Replica&#x3D;3的设置,K8S会创建三个Pod,依次命名为: test-redis-pod-0; test-redis-pod-1; test-redis-pod-2</p><p>K8S为有状态的服务Pod分配稳定的网络标识,具体实现基于test-redis-pod-0名称,借助Headless DNS进行如下解析,获取后端其中一个Pod的地址.</p><p>$(pod name).$(service name).$(namespace).svc.cluster.local<br>下面是一个通过Pod名称访问Redis集群的Master节点地址的方法.</p><p>session.save_path &#x3D; “tcp:&#x2F;&#x2F;test-redis-pod-0.test-redis-service.default.svc.cluster.local:6379”<br>现在回答如下二个问题:</p><p>在Redis Pod内部,主从节点之间数据同步的需求,Slave节点对应的配置文件中需要一个稳定的Master地址.下边脚本就是稳定访问test-redis-pod-0 名称来间接获得Redis Master节点IP地址,然后写入到Redis Slave的配置文件中,这样后续Slave节点与Master节点才能完成增量数据的同步.<br>if [ “${server_host}” !&#x3D; “test-redis-pod-0” ];then<br>        #echo “server-count: ${server_counts}” &gt;&gt; &#x2F;data&#x2F;test.log</p><pre><code>    while [ -z &quot;$&#123;master_address&#125;&quot; ];do        echo &quot;master_address is not available, $&#123;master_address&#125; waiting for redis master...&quot; &gt;&gt; /data/test.log        master_address=$(replication_master_address)        sleep 1s    donefiecho &quot;master_address: $(master_address)&quot; &gt;&gt; /data/test.logif [ ! -z &quot;$master_address&quot; ]; then    printf &quot;\nslaveof %s 6379\n&quot; &quot;$master_address&quot; &gt;&gt; $conffi</code></pre><p>在Redis Pod外部, 可以通过$(pod name).$(service name).$(namespace).svc.cluster.local方式来访问具体的Pod服务.<br>3.2. 如何理解稳定持久化存储?</p><p>每个Redis Pod对应一个自己的PVC&#x2F;PV.当Pod发生调度时,需要在别的节点启动时,根据Pod背后关联的存储信息保证其名称的稳定性.</p><p>Pod还是会attach挂载到原来的PV&#x2F;PVC中,从而确定每个Pod有自己专用的存储卷.</p><ol start="4"><li>总结<br>本文主要介绍了无状态和有状态服务在K8S中的典型应用场景.</li></ol><p>通过对Deployment部署无状态服务所遇到问题的分析,引出了Stateful新的部署组件.它是通过支持Pod一些特性(e.g. 名称唯一性,稳定的网络标识, 稳定的持久化存储等)来实现在K8S中部署运维有状态服务.</p><p>牢记: Stateful有状态服务,每个Pod有独立的PVC&#x2F;PV存储组件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-StorageClass PV PVC 概念和使用</title>
    <link href="https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-4-StorageClass%20PV%20PVC/"/>
    <id>https://smartxia.github.io/blog/2024/04/12/tech/devops/k8s/k8s-4-StorageClass%20PV%20PVC/</id>
    <published>2024-04-12T02:25:53.000Z</published>
    <updated>2024-04-12T07:59:31.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>负责把PVC绑定到PV的是一个持久化存储卷控制循环，这个控制器也是kube-manager-controller的一部分运行在master上。而真正把目录挂载到容器上的操作是在POD所在主机上发生的，所以通过kubelet来完成。而且创建PV以及PVC的绑定是在POD被调度到某一节点之后进行的，完成这些操作，POD就可以运行了。下面梳理一下挂载一个PV的过程：</p><p>用户提交一个包含PVC的POD</p><p>调度器把根据各种调度算法把该POD分配到某个节点，比如node01</p><p>Node01上的kubelet等待Volume Manager准备存储设备</p><p>PV控制器调用存储插件创建PV并与PVC进行绑定</p><p>Attach&#x2F;Detach Controller或Volume Manager通过存储插件实现设备的attach。（这一步是针对块设备存储）</p><p>Volume Manager等待存储设备变为可用后，挂载该设备到&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;&lt;Pod 的 ID&gt;&#x2F;volumes&#x2F;kubernetes.io~&lt;Volume 类型 &gt;&#x2F;&lt;Volume 名字 &gt;目录上</p><p>Kubelet被告知卷已经准备好，开始启动POD，通过映射方式挂载到容器中</p><p>总结：本地卷也就是LPV不支持动态供给的方式，延迟绑定，就是为了综合考虑所有因素再进行POD调度。其根本原因是动态供给是先调度POD到节点，然后动态创建PV以及绑定PVC最后运行POD；而LPV是先创建与某一节点关联的PV，然后在调度的时候综合考虑各种因素而且要包括PV在哪个节点，然后再进行调度，到达该节点后在进行PVC的绑定。也就说动态供给不考虑节点，LPV必须考虑节点。所以这两种机制有冲突导致无法在动态供给策略下使用LPV。换句话说动态供给是PV跟着POD走，而LPV是POD跟着PV走。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记7-error.group用法</title>
    <link href="https://smartxia.github.io/blog/2024/03/26/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/"/>
    <id>https://smartxia.github.io/blog/2024/03/26/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/</id>
    <published>2024-03-26T06:18:21.000Z</published>
    <updated>2024-03-26T07:02:26.582Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4><span id="1-先看下数据结构">1 .先看下数据结构</span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">sem <span class="keyword">chan</span> token</span><br><span class="line"></span><br><span class="line">errOnce sync.Once</span><br><span class="line">err     <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="2在并发编程里-syncwaitgroup">2.在并发编程里 sync.WaitGroup</span></h4><p>并发原语的使用频率非常高，它经常用于协同等待的场景 gorouting 都完成后才能继续执行。</p><p>如果在woker goroutine的执行过程中遇到错误并想要处理该怎么办？</p><p>WaitGroup并没有提供传播错误的功能，遇到这种场景我们该怎么办？Go语言在扩展库提供了ErrorGroup并发原语正好适合在这种场景下使用，它在WaitGroup的基础上还提供了，错误传播以及上下文取消的功能。</p><p>扩展库通过errorgroup.Group提供ErrorGroup原语的功能，它有三个方法可调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func WithContext(ctx context.Context) (*Group, context.Context)</span><br><span class="line">func (g *Group) Go(f func() error)</span><br><span class="line">func (g *Group) Wait() error</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ErrorGroup有一个特点是会返回所以执行任务的goroutine遇到的第一个错误</span></span><br></pre></td></tr></table></figure><h4><span id="3想让程序遇到错误就终止其他子任务">3.想让程序遇到错误就终止其他子任务</span></h4><p>最早执行遇到错误的goroutine输出了Error: 98但是所有未执行完的其他任务并没有停止执行，那么想让程序遇到错误就终止其他子任务该怎么办呢？我们可以用errgroup.Group提供的WithContext方法创建一个带可取消上下文功能的ErrorGroup。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用errorgroup.Group时注意它的两个特点：</span><br><span class="line">- errgroup.Group在出现错误或者等待结束后都会调用 Context对象 的 cancel 方法同步取消信号。</span><br><span class="line">- 只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</span><br><span class="line">*/</span><br><span class="line">func main() &#123;</span><br><span class="line">   eg, ctx := errgroup.WithContext(context.Background())</span><br><span class="line"></span><br><span class="line">   for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">      i := i</span><br><span class="line">      eg.Go(func() error &#123;</span><br><span class="line">         time.Sleep(2 * time.Second)</span><br><span class="line"></span><br><span class="line">         select &#123;</span><br><span class="line">         case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;Canceled:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         default:</span><br><span class="line">            if i &gt; 90 &#123;</span><br><span class="line">               fmt.Println(&quot;Error:&quot;, i)</span><br><span class="line">               return fmt.Errorf(&quot;Error: %d&quot;, i)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(&quot;End:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   if err := eg.Wait(); err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="4cancle到其他的子任务">4.cancle到其他的子任务</span></h4><p>在上面的例子中，子goroutine出现错误后，会cancle到其他的子任务，但是我们并没有看到调用ctx的cancel方法，下面我们看下源码，看看内部是怎么处理的。<br> errgroup 的设计非常精练，全部代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package errgroup</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// A Group is a collection of goroutines working on subtasks that are part of</span><br><span class="line">// the same overall task.</span><br><span class="line">//</span><br><span class="line">// A zero Group is valid and does not cancel on error.</span><br><span class="line">type Group struct &#123;</span><br><span class="line">    cancel func()</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    errOnce sync.Once</span><br><span class="line">    err     error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WithContext returns a new Group and an associated Context derived from ctx.</span><br><span class="line">//</span><br><span class="line">// The derived Context is canceled the first time a function passed to Go</span><br><span class="line">// returns a non-nil error or the first time Wait returns, whichever occurs</span><br><span class="line">// first.</span><br><span class="line">func WithContext(ctx context.Context) (*Group, context.Context) &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    return &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Wait blocks until all function calls from the Go method have returned, then</span><br><span class="line">// returns the first non-nil error (if any) from them.</span><br><span class="line">func (g *Group) Wait() error &#123;</span><br><span class="line">    g.wg.Wait()</span><br><span class="line">    if g.cancel != nil &#123;</span><br><span class="line">        g.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    return g.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Go calls the given function in a new goroutine.</span><br><span class="line">//</span><br><span class="line">// The first call to return a non-nil error cancels the group; its error will be</span><br><span class="line">// returned by Wait.</span><br><span class="line">func (g *Group) Go(f func() error) &#123;</span><br><span class="line">    g.wg.Add(1)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer g.wg.Done()</span><br><span class="line"></span><br><span class="line">        if err := f(); err != nil &#123;</span><br><span class="line">            g.errOnce.Do(func() &#123;</span><br><span class="line">                g.err = err</span><br><span class="line">                if g.cancel != nil &#123;</span><br><span class="line">                    g.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，errgroup 的实现依靠于结构体 Group，它通过封装 sync.WaitGroup，继承了 WaitGroup 的特性，在 Go() 方法中新起一个子任务 goroutine，并在 Wait() 方法中通过 sync.WaitGroup 的 Wait 进行阻塞等待。</p><p>同时 Group 利用 sync.Once 保证了它有且仅会保留第一个子 goroutine 错误。<br> Group 通过嵌入 context.WithCancel 方法产生的 <code>cancel</code> 函数（对于 Context 不熟悉的读者，推荐阅读 <a href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&mid=2247484553&idx=1&sn=ce4c7e052bacf69c38e27d71187726c8&scene=21%23wechat_redirect">理解Context机制</a> 一文），能够<strong>在子 goroutine 发生错误时，及时通过调用 cancle 函数，将 Context 的取消信号及时传播出去。</strong></p><h4><span id="5总结">5.总结:</span></h4><p>使用errorgroup.Group时注意它的特点：</p><ul><li>继承了 WaitGroup 的功能</li><li>errgroup.Group在出现错误或者等待结束后都会调用Context对象 的 cancel 方法同步取消信号。</li><li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</li><li>context 信号传播：如果子任务 goroutine 中有循环逻辑，则可以添加 ctx.Done 逻辑，此时通过 context 的取消信号，提前结束子任务执行。</li></ul><p>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="error.group" scheme="https://smartxia.github.io/blog/tags/error-group/"/>
    
  </entry>
  
  <entry>
    <title>k8s-kubeadmin安装</title>
    <link href="https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/"/>
    <id>https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/</id>
    <published>2024-03-18T03:30:15.000Z</published>
    <updated>2024-04-12T02:34:54.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>通过kubeadm工具，部署k8s集群。操作步骤如下：</p><ol><li><p>准备工作：</p></li><li><ol><li>配置yum源，repo(防被墙)</li><li>安装常用工具，同步时间</li><li>关闭防火墙，将SELinux配置为Permissive模式，关闭swap</li><li>加载ipvs模块，优化内核</li></ol></li><li><p>在所有机器上安装docker</p></li><li><p>在所有机器上安装kubeadm, kubelet, kubectl</p></li><li><p>部署集群Master节点</p></li><li><p>部署集群工作节点</p></li><li><p>安装CNI网络插件</p></li></ol><ul><li>一个Kubernetes集群Master节点。k8s官网现在将master节点称为control plane node(控制平面节点)</li><li>一个Kubernetes集群Slave节点。k8s官网叫worker node(工作节点)。下文中Slave节点和工作节点含义含义相同。</li></ul><table><thead><tr><th>hostname</th><th>ip</th><th>备注</th><th></th></tr></thead><tbody><tr><td>master</td><td>master.k8s</td><td>192.168.246.133</td><td>k8s主节点(control plane node)</td></tr><tr><td>slave</td><td>slave.k8s</td><td>192.168.246.132</td><td>k8s 工作节点(worker node)</td></tr></tbody></table><h2><span id="0-系统要求">0. <strong>系统要求</strong></span></h2><p>安装之前，请确保操作系统满足如下要求：</p><ol><li>Linux内核操作系统，如CentOS，Ubuntu等</li><li>至少2 CPU， 2GB</li><li>集群中所有机器之间的网络必须是通的(公共或私有网络都可以)。</li><li>每个节点都有唯一的主机名、MAC地址和product_uuid</li><li>部署时要保证能连外网</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看操作系统</span></span></span><br><span class="line">cat /proc/version</span><br><span class="line">hostnamectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看IP和MAC命令</span></span></span><br><span class="line">ip link</span><br><span class="line">ifconfig -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看product_uuid</span></span></span><br><span class="line">sudo cat /sys/class/dmi/id/product_uuid</span><br></pre></td></tr></table></figure><h2><span id="1-准备工作"><strong>1. 准备工作</strong></span></h2><p><strong>在所有节点上运行</strong></p><h3><span id="11-配置yum源repo"><strong>1.1 配置yum源，repo</strong></span></h3><p>由于众所周知的原因，为防止在安装时出现资源下载失败的问题，在所有节点上配置yum源，repo。shell如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum源</span></span><br><span class="line">curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker repo</span></span><br><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes repo</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure><h3><span id="12-安装常用的工具同步时间"><strong>1.2 安装常用的工具，同步时间</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum -y install tree vim wget bash-completion bash-completion-extras lrzsz net-tools sysstat iotop iftop htop unzip nc nmap telnet bc  psmisc httpd-tools ntpdate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时区修改,如果/etc/localtime有软连接,不是Shanghai,可以直接删除,在软链接</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate ntp2.aliyun.com            # 同步阿里云服务器上的时间.</span><br><span class="line">/sbin/hwclock --systohc            # 写入到bios系统    </span><br></pre></td></tr></table></figure><h3><span id="13-检查防火墙是否关闭将selinux配置为permissive模式关闭swap"><strong>1.3 检查防火墙是否关闭，将SELinux配置为Permissive模式，关闭swap</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看防火墙状态</span></span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果防火墙是running，关闭防火墙</span></span></span><br><span class="line">sudo systemctl disable firewalld &amp;&amp; systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Set SELinux to permissive mode.将SELinux配置为Permissive模式</span></span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 也可以直接关闭SELinux</span></span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo setenforce 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo sed -ri <span class="string">&#x27;s#(SELINUX=).*#\1disabled#&#x27;</span> /etc/selinux/config</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时关闭swap。如果不关闭，kubelet会启动失败</span></span><br><span class="line">sudo swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久防止开机自动挂载swap</span></span><br><span class="line">sudo sed -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h3><span id="14-加载ipvs模块优化内核"><strong>1.4 加载ipvs模块，优化内核</strong></span></h3><p>如下参数不修改，会导致<code>kubeadm init</code>运行失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载ipvs模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证ip_vs模块</span></span><br><span class="line">lsmod |grep ip_vs</span><br><span class="line">ip_vs_wrr              12697  0 </span><br><span class="line">ip_vs_rr               12600  0 </span><br><span class="line">ip_vs_sh               12688  0 </span><br><span class="line">ip_vs                 145458  6 ip_vs_rr,ip_vs_sh,ip_vs_wrr</span><br><span class="line">nf_conntrack          139264  2 ip_vs,nf_conntrack_ipv4</span><br><span class="line">libcrc32c              12644  3 xfs,ip_vs,nf_conntrack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核文件</span> </span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效并验证内核优化</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><h2><span id="2-安装docker"><strong>2. 安装docker</strong></span></h2><p><em>在所有节点上运行</em></p><h3><span id="21-安装启动docker"><strong>2.1 安装启动docker</strong></span></h3><p>注意：安装docker需要root权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. yum 安装</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 运行sudo yum install docker-ce 也是可以的，docker-ce依赖了docker-ce-cli, containerd.io, docker-buildx-plugin, docker-compose-plugin。这些依赖会同步install</span></span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 配置docker</span></span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://registry.hub.docker.com&quot;,</span><br><span class="line">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 启动docker</span></span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>验证是否安装正确</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4. docker运行正常</span></span><br><span class="line">[shirley@master k8s_install]$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2023-10-10 09:23:41 CST; 19s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 16381 (dockerd)</span><br><span class="line">    Tasks: 8</span><br><span class="line">   Memory: 27.4M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─16381 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/con...</span><br><span class="line">[shirley@master k8s_install]$</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行docker命令，验证镜像下载正常，容器运行正常</span></span><br><span class="line">[shirley@slave k8s_install]$ sudo docker run hello-world</span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">719385e32844: Pull complete</span><br><span class="line">Digest: sha256:4f53e2564790c8e7856ec08e384732aa38dc43c52f02952483e3f003afbf23db</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h3><span id="22-配置containerd中pause镜像地址"><strong>2.2 配置containerd中pause镜像地址</strong></span></h3><p>为了防止安装过程中出现pause镜像下载失败的问题，建议运行<code>containerd config dump &gt; /etc/containerd/config.toml </code>命令，将当前配置导出到文件，并修改<code>sandbox_image</code>配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果没有/etc/containerd/config.toml文件，将默认配置导出到/etc/containerd/config.toml。</span></span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置</span></span></span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># PS: 如果生成的/etc/containerd/config.toml中没有如上配置项，可以运行如下命令导出当前所有配置项后再修改文件/etc/containerd/config.toml</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">containerd config dump &gt; /etc/containerd/config.toml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重启containerd</span></span></span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h2><span id="3-部署kubeadm-kubelet-kubectl"><strong>3. 部署kubeadm, kubelet, kubectl</strong></span></h2><p>kubeadm：启动k8s集群的工具</p><p>kubelet: 该组件在集群中的所有机器上运行，并执行启动pod和容器之类的任务。</p><p>kubectl: 与集群通信的工具。可以只在master节点上安装。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">## 开机启动kubelet</span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看kubeadm版本</span></span><br><span class="line">[root@master ~]<span class="comment"># sudo kubeadm version</span></span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:<span class="string">&quot;1&quot;</span>, Minor:<span class="string">&quot;28&quot;</span>, GitVersion:<span class="string">&quot;v1.28.2&quot;</span>, GitCommit:<span class="string">&quot;89a4ea3e1e4ddd7f7572286090359983e0387b2f&quot;</span>, GitTreeState:<span class="string">&quot;clean&quot;</span>, BuildDate:<span class="string">&quot;2023-09-13T09:34:32Z&quot;</span>, GoVersion:<span class="string">&quot;go1.20.8&quot;</span>, Compiler:<span class="string">&quot;gc&quot;</span>, Platform:<span class="string">&quot;linux/amd64&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2><span id="4-初始化master节点kubeadm-init"><strong>4.</strong> 初始化Master节点（kubeadm init）</span></h2><p><em>在Master节点运行</em></p><h3><span id="41-更改配置文件"><strong>4.1. 更改配置文件</strong></span></h3><p><code>kubeadm init</code>命令用于初始化master节点。kubeadm init 的参数可以通过<strong>命令行</strong>或<strong>yaml文件</strong>进行配置。本文介绍如何通过yaml文件进行配置。可以通过<code>kubeadm config print init-defaults</code>命令得到一份默认配置，然后对其进行修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm.yaml</span><br></pre></td></tr></table></figure><p>对kubeadm.yaml进行编辑，修改内容如下：</p><ol><li>修改<code>advertiseAddress</code>为master IP地址</li><li><code>imageRepository</code>修改为<code>registry.aliyuncs.com/google_containers</code>，防止镜像拉不下来</li><li>建议将<code>networking.podSubnet</code>修改为<code>10.244.0.0/16</code>， 和后续安装的flannel CNI 插件的默认配置保持一致。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.246.133    ## change the IP of apiserver.</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: node</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers   ## change imageRepository to aliyun.</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.28.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  podSubnet: 10.244.0.0/16  ## add this line to config POD network. Same with CNI config.</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure><p>如上配置文件等价于命令行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.246.133 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.28.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 </span><br></pre></td></tr></table></figure><ul><li>–apiserver-advertise-address 集群通告地址</li><li>–image-repository 由于默认拉取镜像地址<a href="https://link.zhihu.com/?target=http://k8s.gcr.io">http://k8s.gcr.io</a>国内无法访问，这里指定阿里云镜像仓库地址</li><li>–kubernetes-version K8s版本，与上面安装的一致</li><li>–service-cidr 集群内部虚拟网络，Pod统一访问入口</li><li>–pod-network-cidr Pod网络，<strong>与下面部署的CNI网络组件yaml中保持一致</strong></li></ul><h3><span id="42-提前pull镜像可选"><strong>4.2 提前pull镜像（可选）</strong></span></h3><p>为了使后续安装更快，建议先把安装需要的镜像pull下来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 验证配置文件格式是否正确</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config validate --config kubeadm.yaml</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看需要下载哪些镜像。需要关注下载的repository地址是否正确。</span></span><br><span class="line"><span class="comment">## 如上在kubeadm.yaml文件配置了imageRepository：registry.aliyuncs.com/google_containers，因此images会从aliyun的repo下载。</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config images list --config kubeadm.yaml</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">## pull镜像。pull镜像有点慢，第一个镜像pull成功后才有日志输出。命令运行后发现没有日志不要着急，多等一会。</span></span><br><span class="line">[shirley@master k8s_install]$ sudo kubeadm config images pull --config kubeadm.yaml</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><h3><span id="43-kubeadm-init初始化"><strong>4.3 kubeadm init初始化</strong></span></h3><p>运行<code>kubeadm init --config kubeadm.yaml</code>， 当看到<code>Your Kubernetes control-plane has initialized successfully!</code>时表示安装成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master k8s_install]<span class="comment"># kubeadm init --config kubeadm.yaml</span></span><br><span class="line">... ...</span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p><strong>PS：最好将最后一行log需要记下来，worker节点安装会用到。</strong></p><p>根据提示，退出root账户后运行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><h3><span id="44-验证"><strong>4.4 验证</strong></span></h3><p>验证master节点是否部署成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## kubectl 运行正常. STATUS=NotReady是因为CNI插件还没装。</span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME   STATUS     ROLES           AGE   VERSION</span><br><span class="line">node   NotReady   control-plane   20m   v1.28.2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 通过crictl命令可以查看到运行的container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo crictl ps -a</span><br><span class="line">CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID              POD</span><br><span class="line">955b0c87ad621       ea1030da44aa1       26 minutes ago      Running             kube-proxy                0                   78efbee65dfac       kube-proxy-kp9kw</span><br><span class="line">f69d8c3246904       73deb9a3f7025       26 minutes ago      Running             etcd                      0                   77180bc7ff0a8       etcd-node</span><br><span class="line">3efba65f263d3       f6f496300a2ae       26 minutes ago      Running             kube-scheduler            0                   f89fb4bb60e2e       kube-scheduler-node</span><br><span class="line">5dfb28390f30b       4be79c38a4bab       26 minutes ago      Running             kube-controller-manager   0                   b716cb4652e1c       kube-controller-manager-node</span><br><span class="line">b8cfce31fa842       bb5e0dde9054c       26 minutes ago      Running             kube-apiserver            0                   006db1ce43cfe       kube-apiserver-node</span><br></pre></td></tr></table></figure><p>这里有大家可能有个疑惑，为什么docker ps看不到运行的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 运行docker命令，发现没有container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><p>这是因为kubernetes使用的containerd作为容器运行时，而不是Docker engine. kubernetes支持4中容器运行时：</p><table><thead><tr><th>Runtime</th><th>Path to Unix domain socket（CRI socket）</th></tr></thead><tbody><tr><td>containerd</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock</td></tr><tr><td>CRI-O</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;crio&#x2F;crio.sock</td></tr><tr><td>Docker Engine (using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr><tr><td>Mirantis Container Runtime (MCR)(using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr></tbody></table><p>By default, Kubernetes uses the Container Runtime Interface (CRI) to interface with your chosen container runtime.</p><p>默认情况下，kubernetes会用CRI找到选择的容器运行时。在我们安装docker时，安装了containerd，因此k8s找到了containerd作为容器运行时。在kubeadm.yam文件中也能看到相应的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>为什么k8s不选用docker engine作为容器运行时？因为如果使用docker engine, 还需要安装cri-dockerd，才能作为容器时被k8s识别。而如上操作并未安装。</p><p>此外，k8s推荐直接使用containerd作为容器运行时。</p><h2><span id="5-初始化工作节点"><strong>5. 初始化工作节点</strong></span></h2><h3><span id="51-运行kubeadm-join将工作节点加入集群"><strong>5.1 运行kubeadm join将工作节点加入集群</strong></span></h3><p>在master节点kubeadm init安装完成后，会有如下类似log</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.. ... </span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p>将上述命令粘贴到工作节点，将工作节点添加到集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slave ~]# kubeadm join 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot; could not be reached</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot;: lookup slave.k8s on 192.168.246.2:53: no such host</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><h3><span id="52-验证"><strong>5.2 验证</strong></span></h3><p>到master节点运行kubelet get node,可以看到加进来的node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl get nodes</span><br><span class="line">NAME        STATUS     ROLES           AGE    VERSION</span><br><span class="line">node        NotReady   control-plane   121m   v1.28.2</span><br><span class="line">slave.k8s   NotReady   &lt;none&gt;          28s    v1.28.2</span><br></pre></td></tr></table></figure><p>当前STATUS都是NotReady，这是因为还没有安装网络插件CNI</p><h3><span id="53-忘记token怎么办"><strong>5.3 忘记token怎么办</strong></span></h3><p>如果master节点安装时，没有记录下token，或token超时(默认24小时)，可以运行如下命令重新生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubeadm token create --print-join-command</span><br><span class="line">kubeadm join 192.168.246.133:6443 --token by8q23.65btteq9iud7ypso --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><h2><span id="6-安装cni网络插件"><strong>6. 安装CNI网络插件</strong></span></h2><p>Kubernetes 它需要网络插件来提供集群内部和集群外部的网络通信。以下是一些常用的 k8s 网络插件：</p><ul><li>Flannel：Flannel 是最常用的 k8s 网络插件之一，它使用了虚拟网络技术来实现容器之间的通信，支持多种网络后端，如 VXLAN、UDP 和 Host-GW。</li><li>Calico：Calico 是一种基于 BGP 的网络插件，它使用路由表来路由容器之间的流量，支持多种网络拓扑结构，并提供了安全性和网络策略功能。</li><li>Canal：Canal 是一个组合了 Flannel 和 Calico 的网络插件，它使用 Flannel 来提供容器之间的通信，同时使用 Calico 来提供网络策略和安全性功能。</li><li>Weave Net：Weave Net 是一种轻量级的网络插件，它使用虚拟网络技术来为容器提供 IP 地址，并支持多种网络后端，如 VXLAN、UDP 和 TCP&#x2F;IP，同时还提供了网络策略和安全性功能。</li><li>Cilium：Cilium 是一种基于 eBPF (Extended Berkeley Packet Filter) 技术的网络插件，它使用 Linux 内核的动态插件来提供网络功能，如路由、负载均衡、安全性和网络策略等。</li><li>Contiv：Contiv 是一种基于 SDN 技术的网络插件，它提供了多种网络功能，如虚拟网络、网络隔离、负载均衡和安全策略等。</li><li>Antrea：Antrea 是一种基于 OVS (Open vSwitch) 技术的网络插件，它提供了容器之间的通信、网络策略和安全性等功能，还支持多种网络拓扑结构。</li></ul><table><thead><tr><th>提供商</th><th>网络模型</th><th>路线分发</th><th>网络策略</th><th>网格</th><th>外部数据存储</th><th>加密</th><th>Ingress&#x2F;Egress 策略</th></tr></thead><tbody><tr><td>Canal</td><td>封装 (VXLAN)</td><td>否</td><td>是</td><td>否</td><td>K8s API</td><td>是</td><td>是</td></tr><tr><td>Flannel</td><td>封装 (VXLAN)</td><td>否</td><td>否</td><td>否</td><td>K8s API</td><td>是</td><td>否</td></tr><tr><td>Calico</td><td>封装（VXLAN，IPIP）或未封装</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr><tr><td>Weave</td><td>封装</td><td>是</td><td>是</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Cilium</td><td>封装 (VXLAN)</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr></tbody></table><p>Calico 和 Flannel都是常用的CNI，如下介绍如何安装flannel网络插件</p><h3><span id="61-安装flannel网络插件"><strong>6.1 安装flannel网络插件</strong></span></h3><ol><li>下载kube-flannel.yml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. 下载kube-flannel.yml</span></span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p><code>kube-flannel.yaml</code>文件中，需要注意，net-conf.json里的network要和kubeadm.yaml里配置的networking.podSubnet相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      ### 这里的network和kubeadm.yaml里配置的networking.podSubnet相同 </span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><ol start="2"><li>容器部署flannel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl apply -f kube-flannel.yml</span><br><span class="line">namespace/kube-flannel created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure><h3><span id="62-验证cni"><strong>6.2 验证CNI</strong></span></h3><p>安装后，运行<code>kubectl -n kube-system get pod -o wide</code>， 可以看到在master节点和slave节点分别运行了一个kube-proxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 每个节点上都运行了kube-proxy</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl -n kube-system get pod -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE     IP                NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66f779496c-d8rws       1/1     Running   0          4h40m   10.244.0.3        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66f779496c-fzmjm       1/1     Running   0          4h40m   10.244.0.2        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-node                      1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-node   1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-bpv8d               1/1     Running   0          160m    192.168.246.132   slave.k8s   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-kp9kw               1/1     Running   0          4h40m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># node状态显示为Ready</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME        STATUS   ROLES           AGE     VERSION</span><br><span class="line">node        Ready    control-plane   4h38m   v1.28.2</span><br><span class="line">slave.k8s   Ready    &lt;none&gt;          158m    v1.28.2</span><br></pre></td></tr></table></figure><p>自此，集群搭建完成。</p><h2><span id="其他说明"><strong>其他说明</strong></span></h2><p>另外，在初始安装的Master节点上也启动了<code>kubelet</code>和<code>kube-proxy</code>，在默认情况下并不参与工作负载的调度。如果希望Master节点也作为Node角色，则可以运行下面的命令（删除Master节点的：<code>node-role.kubernetes.io/control-plane:NoSchedule</code>），让Master节点也成为一个Node：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-IPVS概念原理以及应用</title>
    <link href="https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://smartxia.github.io/blog/2024/03/18/tech/devops/k8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2024-03-18T03:24:31.000Z</published>
    <updated>2024-04-12T02:34:47.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="ipvs的概念-原理及应用">IPVS的概念、原理及应用</span></h3><h3><span id="一-什么是ipvs">一、什么是IPVS</span></h3><p>LVS（Linux 虚拟服务器）和 IPVS（IP 虚拟服务器）是 Linux 中用于构建可扩展和高性能网络服务的两种相关技术。</p><p>LVS 是 Linux 系统的内核级负载均衡解决方案。 它允许您在多个服务器之间分配传入的网络流量，创建一个服务器集群，在客户端看来就像一个虚拟服务器。 LVS 中的负载均衡算法可以根据各种因素（例如循环法、最少连接数和源 IP 哈希）来分配流量。 </p><h3><span id="二-ipvs的工作原理">二、IPVS的工作原理</span></h3><p>IPVS的工作原理基于网络地址转换（Network Address Translation，NAT）和端口转换（Port Translation）。</p><p>当一个网络请求到达IPVS，IPVS会根据预设的调度算法选择一个后端服务器，然后修改网络请求的目标IP地址和端口，使其指向选择的后端服务器。</p><p>当后端服务器处理完请求后，IPVS会将服务器的响应转发回原始请求的客户端。</p><p>在这个过程中，客户端并不知道实际上是哪个后端服务器处理了它的请求。</p><h3><span id="三-ipvs的主要特性">三、IPVS的主要特性</span></h3><p>丰富的调度算法：IPVS支持多种调度算法，包括最小连接（Least-Connection）、轮询（Round-Robin）和加权轮询（Weighted Round-Robin）等，满足不同应用场景的需求。<br>健康检查：IPVS能够定期对后端服务器进行健康检查，当检测到某个服务器故障时，可以将其从服务列表中移除，防止向故障服务器发送请求。<br>高性能：由于IPVS是Linux内核的一部分，因此处理网络请求的效率非常高。IPVS支持大规模并发连接，能够处理每秒数以万计的网络请求。<br>易于集成：IPVS可以与其他Linux内核模块和用户空间工具一起使用，如iptables和keepalived等，提供更加强大和灵活的网络服务。</p><h3><span id="四-ipvs的应用场景">四、IPVS的应用场景</span></h3><p>IPVS广泛应用于大规模的互联网服务，如网站、在线视频和游戏等，提供高可用性和高性能的网络服务。</p><p>此外，IPVS也在云计算、大数据和容器技术等领域有广泛的应用，例如在Kubernetes中，IPVS作为服务代理的一种模式，为集群内的服务提供负载均衡。</p><p>综上所述，LVS 是 Linux 系统的综合负载均衡解决方案，而 IPVS 是 LVS 中专门处理 IP 负载均衡的组件。 LVS 利用 IPVS 在多个真实服务器之间分发流量，并为各种网络服务提供可扩展性和容错性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>PHP-析构函数-destruct</title>
    <link href="https://smartxia.github.io/blog/2024/03/12/tech/backend/php/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
    <id>https://smartxia.github.io/blog/2024/03/12/tech/backend/php/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</id>
    <published>2024-03-12T03:55:12.845Z</published>
    <updated>2024-03-12T03:55:12.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3><span id="析构函数destruct">析构函数destruct</span></h3><p><img src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：__construct()在初始化对象的时候默认执行的<br>析构函数：__destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data = [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#x27;appkey&#x27;] = getAppkey();</span><br><span class="line">        $data[&#x27;channel&#x27;] = getChannel();</span><br><span class="line">        $this-&gt;data[] = $data;</span><br><span class="line">        //这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id = $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#x27;id &lt;&#x27; =&gt; $id - 50000</span><br><span class="line">            ], &#x27;&#x27;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend=new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
    <category term="php" scheme="https://smartxia.github.io/blog/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2024/03/12/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
    <id>https://smartxia.github.io/blog/2024/03/12/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</id>
    <published>2024-03-12T03:55:12.820Z</published>
    <updated>2024-03-12T03:55:12.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. := = ==</span><br><span class="line"></span><br><span class="line">:= 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">= 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">== 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 := make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val := make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">ch := make(chan int, 100) // make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">// 并把值赋给 v</span><br><span class="line">​```</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>darp Docs</title>
    <link href="https://smartxia.github.io/blog/2022/03/16/tech/devops/darp-Docs/"/>
    <id>https://smartxia.github.io/blog/2022/03/16/tech/devops/darp-Docs/</id>
    <published>2022-03-16T06:59:18.000Z</published>
    <updated>2024-03-12T03:55:12.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>dapr 文档贡献<br>dapr 文档贡献规则：<a href="https://docs.dapr.io/zh-hans/contributing/contributing-docs/">https://docs.dapr.io/zh-hans/contributing/contributing-docs/</a></p><p>dapr 文档网站使用hugo 开发工具：</p><p>Windows：安装流程<br>安装scoope<br>powerSheel ：执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br><span class="line"></span><br><span class="line">iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)</span><br><span class="line"></span><br><span class="line">执行scoope help 查看是否安装正常</span><br><span class="line"></span><br><span class="line">执行   scoop install hugo</span><br><span class="line">      scoop install hugo-extended</span><br><span class="line">这两部即可 完成对其安装</span><br><span class="line"></span><br><span class="line">文档：https://gohugo.io/getting-started/installing/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="1执行doc仓库下载和安装依赖">1.执行doc仓库下载和安装依赖</span></h3><p>仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https://github.com.cnpmjs.org/dapr/docs.git</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">这步可能遇到下载不下来情况，可以按照此步骤进行操作</span><br><span class="line"></span><br><span class="line">1.执行 git submodule update --init</span><br><span class="line">2.去.gitmodules文件 进行编辑将所有的https://github.com  后缀加上 cnpmjs.org</span><br><span class="line">(这个原理可以参考:谷歌插件---GitHub加速1.3.5)</span><br><span class="line">3.然后利用git submodule sync更新子项目对应的url</span><br><span class="line">4.git submodule update --init --recursive，最后执行</span><br><span class="line"></span><br><span class="line">//s2-cdn.oneitfarm.com/6d3518411d074f9eae604f77da39da83.png</span><br></pre></td></tr></table></figure><p><img src="//s2-cdn.oneitfarm.com/a23f2220daff4375ba97522c7edc552c.png"></p><p>错误1.</p><p><img src="//s2-cdn.oneitfarm.com/c036d24abc364f00be0870faec874818.png" alt="image-20220316151455745"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用git代理：</span><br><span class="line">git config *--global https.proxy*</span><br><span class="line">执行命令后取消代理</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>错误2：</p><p><img src="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png" alt="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是因为没有执行git module的 下载</span><br></pre></td></tr></table></figure><h3><span id="2安装依赖">2.安装依赖</span></h3><p>此项目使用的还是npm </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install （很慢） </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="dapr" scheme="https://smartxia.github.io/blog/categories/dapr/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc-2</title>
    <link href="https://smartxia.github.io/blog/2021/12/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B013grpc-2/"/>
    <id>https://smartxia.github.io/blog/2021/12/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B013grpc-2/</id>
    <published>2021-12-09T07:05:54.000Z</published>
    <updated>2024-03-12T03:55:12.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>脑图：</p><p><a href="https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5">https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5</a></p><p>服务端的操作：</p><p>取出server</p><p>挂载方法</p><p>注册服务</p><p>创建监听</p><p>客户端：</p><p>创建链接</p><p>new 一个client</p><p>调用client方法</p><p>获取返回值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>x86和arm架构区别</title>
    <link href="https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-12-02T08:22:44.000Z</published>
    <updated>2024-03-12T03:55:12.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是arm架构">什么是arm架构</span></h3><p>ARM架构过去称之为进阶精简指令集机器，是一个32位的精简指令集（RISC）处理器架构，其广泛的使用在嵌入式系统设计，由于节能的特点，ARM非常适合处理移动通讯领域，符合其设计目标低消耗 电量的特性，在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.</p><p>arm架构图</p><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据&#x2F;地址寄存器组成.</p><p><img src="http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg"></p><p>1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</p><p>2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移&#x2F;右移n位、环移n位和算术右移n位等都可以一次完成。</p><p>3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1&#x2F;3）。</p><p>4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</p><p>5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</p><p>6、寄存器</p><h2><span id="x86架构"><strong>x86架构</strong></span></h2><p><img src="http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg"></p><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><p>   1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</p><p>　2： 北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</p><p>　3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I&#x2F;O总线较多，离处理器远一点有利于布线。</p><p>　4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p><p>　5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</p><p>　6：显示j接口</p><p>　7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>　8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</p><p>　9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</p><p>　10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</p><p>　11：总线</p><h2><span id="arm架构和x86架构有什么区别"><strong>arm架构和x86架构有什么区别</strong></span></h2><p><strong>一、性能</strong> </p><p>​    X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。</p><p>　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.</p><p><strong>二、扩展能力</strong></p><p>​    X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.</p><p>　　ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.</p><p> <strong>三、操作系统的兼容性</strong></p><p>​    X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。</p><p>　　ARM系统几乎都采用<strong>Linux</strong>的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的<strong>Android</strong>系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.</p><p><strong>四、软件开发的方便性及可使用工具的多样性</strong></p><p>​    X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。</p><p>　　Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。</p><p>　　对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。</p><p>　　从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：<strong>功耗.</strong></p><p><strong>五、功耗</strong> </p><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>x86和arm架构区别</title>
    <link href="https://smartxia.github.io/blog/2021/12/02/tech/devops/site/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://smartxia.github.io/blog/2021/12/02/tech/devops/site/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-12-02T08:22:44.000Z</published>
    <updated>2025-10-15T09:32:54.183Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是arm架构">什么是arm架构</span></h3><p>ARM架构过去称之为进阶精简指令集机器，是一个32位的精简指令集（RISC）处理器架构，其广泛的使用在嵌入式系统设计，由于节能的特点，ARM非常适合处理移动通讯领域，符合其设计目标低消耗 电量的特性，在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.</p><p>arm架构图</p><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据&#x2F;地址寄存器组成.</p><p><img src="http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg"></p><p>1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</p><p>2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移&#x2F;右移n位、环移n位和算术右移n位等都可以一次完成。</p><p>3、高速乘法器：乘法器一般采用”加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现”加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1&#x2F;3）。</p><p>4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</p><p>5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</p><p>6、寄存器</p><h2><span id="x86架构"><strong>x86架构</strong></span></h2><p><img src="http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg"></p><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><p>   1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</p><p>　2： 北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</p><p>　3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I&#x2F;O总线较多，离处理器远一点有利于布线。</p><p>　4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p><p>　5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</p><p>　6：显示j接口</p><p>　7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>　8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</p><p>　9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</p><p>　10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</p><p>　11：总线</p><h2><span id="arm架构和x86架构有什么区别"><strong>arm架构和x86架构有什么区别</strong></span></h2><p><strong>一、性能</strong> </p><p>​    X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。</p><p>　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.</p><p><strong>二、扩展能力</strong></p><p>​    X86结构的电脑采用”桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.</p><p>　　ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行”够用就好”的原则.</p><p> <strong>三、操作系统的兼容性</strong></p><p>​    X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。</p><p>　　ARM系统几乎都采用<strong>Linux</strong>的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的<strong>Android</strong>系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.</p><p><strong>四、软件开发的方便性及可使用工具的多样性</strong></p><p>​    X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。</p><p>　　Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。</p><p>　　对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。</p><p>　　从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：<strong>功耗.</strong></p><p><strong>五、功耗</strong> </p><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="运维部署" scheme="https://smartxia.github.io/blog/categories/%E8%BF%90%E7%BB%B4%E9%83%A8%E7%BD%B2/"/>
    
    
  </entry>
  
  <entry>
    <title>HTTP 请求方法之CONNECT method</title>
    <link href="https://smartxia.github.io/blog/2021/11/25/tech/network/http/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/"/>
    <id>https://smartxia.github.io/blog/2021/11/25/tech/network/http/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/</id>
    <published>2021-11-25T01:36:06.000Z</published>
    <updated>2024-03-12T03:55:12.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>HTTP1.1 中的connect<br>1.http请求代理就是connect这个方法，connect网页开发中不会使用<br>2.connect的作用将服务器作为代理，让服务器提用户访问其他网页（翻墙），之后将数据返回用户<br>3.connect是将通过TCP代理链接服务器的，假如我想让代理服务器访问，<a href="https://baidu.com网站,首先要简历一条客户端到代理服务器的tcp的链接/">https://baidu.com网站，首先要简历一条客户端到代理服务器的tcp的链接</a><br>然后给代理服务器发送一个http报文</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECT https://www.jianshu.com/u/f67233ce6c0c:80 HTTP/1.1</span><br><span class="line">Host: www.web-tinker.com:80</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Proxy-Authorization: Basic *</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>在发送完这个请求之后，代理服务器会响应请求，返回一个200的信息，但这个200并不同于我们平时见到的OK，而是Connection Established</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="HTTP" scheme="https://smartxia.github.io/blog/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>弱势文化</title>
    <link href="https://smartxia.github.io/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/"/>
    <id>https://smartxia.github.io/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/</id>
    <published>2021-11-22T05:37:08.000Z</published>
    <updated>2024-03-12T03:55:12.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="https://pic1.zhimg.com/v2-bb213c477bc9d02350862acc72395838_720w.jpg?source=3af55fa1" alt="preview"></p><p>知识的快餐：我们为什么要懂点哲学<br>什么是哲学，哲学可不可以理解成为人的认知的差异，哲学里的文化属性到底代表着什么</p><blockquote><p>闲暇产生思辨，思辨消解教条主义和陈腐习俗，发展出敏锐的感知，让人丧失行动的决断。</p><p>思想，在分析迷宫冒险前行，发现社会背后的个体，玻璃其正常的社会功能，转向内在，发现自我</p><p>共同的利益，和共同体的意识衰退，如今没有公民只有个人</p><p>个体通过思索意识到自己本身就是生存的目的，他要求国际从此以往加强而不是利用他的能力，以此为代价，个人将维持国家的持续</p></blockquote><p><strong>社会经济的发展带来的我们物质和生活的增长，被冠以着数十年来通过个体努力的结果，于是国家造就了弱势文化的典型思想:误以为将自己的生活水平的提高，是通过自己勤劳获取的，殊不知这是吃着国家的红利，而并非自己真的可以通过真正的努力获取的温饱</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-GPM的深入理解</title>
    <link href="https://smartxia.github.io/blog/2021/11/18/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B012-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>https://smartxia.github.io/blog/2021/11/18/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B012-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-11-18T02:08:03.000Z</published>
    <updated>2024-03-12T03:55:12.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>深入golang runtime的调度</p><h3><span id="理解调度器的启动">理解调度器的启动</span></h3><p>runtime：</p><p>scheduler:</p><p>TLS:</p><p>spinning:</p><p>systemstack,mcall,asmcgocall</p><p>主要源码文件:</p><p>调度基本组件：</p><p>**G(goroutine)**：调度器的基本单位，存储的goroutine的执行stack信息，状态以及任务函数</p><p>在g的眼中只有p,p就是运行的G的“CPU”</p><p>相当于两级线程</p><blockquote><p>g的任务函数</p></blockquote><p>每个g的实例都有任务函数，如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userFun:=func()&#123;fmt.Println(&quot;111&quot;)&#125;</span><br><span class="line">go userFunc();</span><br></pre></td></tr></table></figure><p>go的关键词创建了一个goroutine,此时gouroutine的任务函数userFun</p><p><strong>P（processor）</strong></p><p>p表示逻辑processor，代表M执行的上下文</p><p>p的最大作用是拥有各种G的对象队列，链表，cache,和状态</p><p>p的数量也代表go的执行并发度，即多少个goroutine可以同时执行</p><p>这里的p虽然表示逻辑处理器，但是p并不代表任何执行代码，对于g来说，p相当于cpu的核，g只有绑定p才能调度。对于M来说，p提供了执行环境（Context），如分配内存状态（mcache）,任务队列G等</p><p><strong>M(machine)</strong></p><p>M代表真正的执行计算资源，可以任务他就是os thread(系统线程)</p><p>M是真正的执行者，每个M就像一个勤劳的工作者，总是从各种队列找到可运行的G,而且这样的M的可以同时存在多个</p><p>M在绑定有效P，可以进行调度循环，而且M并不保留G状态，这个是g可以跨M调度的基础</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-纯纯的语法仔的没落</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B09-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B09-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/</id>
    <published>2021-11-17T03:57:39.000Z</published>
    <updated>2024-03-12T03:55:12.821Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="基础">基础</span></h2><h3><span id="1-对于已经关闭的channel的处理">1. 对于已经关闭的channel的处理</span></h3><p>读已经关闭的channel，一直能读到东西，但是读到的东西根据通道内关闭前是否有元素而不同，</p><ul><li>关闭前，buffer有还未读取的，会读取到chan内的值，且返回是否读取成功的bool值为true</li><li>关闭前，buffer的值读完，channel元素值为0，bool值为false</li></ul><p>写入：直接panic</p><h3><span id="2-make和new区别">2. Make和new区别</span></h3><p>make：返回特定类型channel，slice,map</p><p>new: 开辟新内存和指针，泛化类型</p><h3><span id="3-nil-切片和空切片一不一样">3. nil 切片和空切片一不一样</span></h3><p>指向的地址不一样。nill引用指针地址为0，空切片执行数组指针地址，且为一个固定值</p><p>数据结构：data,len,cap</p><h3><span id="4-字符串转byte数组会发生内存拷贝吗">4. 字符串转byte数组，会发生内存拷贝吗</span></h3><p>严格来说，只要发生类型强转，都会发生内存拷贝。</p><p>那么go有个很强的包叫 <code>unsafe</code> 。先获取变量地址，字符串转成底层结构，通过unsafe包，转为切片数组,再通过指针指向实际内容</p><p>string 数据结构 {data,len} </p><h3><span id="5-json包变量不加tag会怎么样">5. json包变量不加tag会怎么样</span></h3><p>和key的大小写有关</p><h3><span id="6-gpm">6. GPM</span></h3><p>指向另一篇详细（）</p><h3><span id="7docker-的网络通信模式">7.Docker 的网络通信模式。</span></h3><p>四种：</p><p>1.host模式：和宿主机公用一个network NameSpace 。容器不会配置任何自己网卡，而是使用自己宿主机的IP和端口</p><p>2.container模式：指定和其他容器共享network nameSpace,而不是和宿主机共享</p><p>3.none模式：告诉容器放到自己网站堆里，但是不要配置他的网络</p><p>4.brideg模式：docker默认的网络模式，此模式会将主机docker链接到虚拟网桥上</p><h3><span id="8访问私有成员">8.访问私有成员</span></h3><blockquote><p>调用其他包共有结构的私有成员变<strong>量</strong></p></blockquote><p><strong>绕过小写不公开</strong></p><p>用unsafe包中的unsafe.Pointer获取到结构体对象的首地址，然后加上想访问的私有变量的偏移地址就是私有变量的地址</p><h3><span id="9-数组和切片的区别">9、数组和切片的区别</span></h3><p>长度，容量，数组指针</p><p>切片是指针类型，数组是是值类型</p><p>数据长度固定，切片不固定</p><p>切片比数组多个属性（cap）,切片底层是数组</p><ul><li>扩容：小于1024 每次cap翻倍，超过变成1.25</li><li>扩容后没触及原数组容量，那么切片指针指向的位置，还是原数组，扩容后，超过原数组容量，会开辟一块新内存，原来的值拷贝过来，也不会影响原来数组</li><li>append:</li></ul><h3><span id="10介绍-rune-类型">10.介绍 rune 类型</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var str = &quot;hello 你好&quot;</span><br><span class="line">    fmt.Println(&quot;len(str):&quot;, len(str))</span><br><span class="line">    //12个 </span><br><span class="line">    //中文字符在unicode下占2个字节，在utf-8编码下占3个字节 go默认utf-8 5+1+3*2</span><br><span class="line">    //通过rune类型处理unicode字符</span><br><span class="line">    fmt.Println(&quot;rune:&quot;, len([]rune(str))) //8个</span><br><span class="line">    fmt.Println(&quot;RuneCountInString:&quot;, utf8.RuneCountInString(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>byte等同于uint8，而不是int8</p><p>rune 等同于int32,常用来处理unicode或utf-8字符</p><h3><span id="11-panic-defer-recover">11 panic defer recover</span></h3><p>panic() 函数</p><p>函数中遇到panic语句，会立即终止当前函数的执行，在panic所在函数内如果存在要执行的defer函数列表，按照defer的逆序执行</p><p>recover() 函数</p><p>recover函数的返回值报告协程是否正在遭遇panic</p><p>有异常时，recover()只能调用一次，后面再次调用则捕获不到任何异常</p><p>通常办法：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理，从而恢复正常代码的执行</p><h3><span id="12-读写锁和互斥锁">12 读写锁和互斥锁</span></h3><p>总结：</p><ol><li>1.在单纯的只是获取锁和释放锁时，互斥锁的用时要少一些，这主要是因为多个线程同时获取读写锁的情况比较少出现。</li><li>golang底层实现上，互斥锁确实要比读写锁的性能要好一些，这主要是因为读写锁的底层实现其实是互斥锁加上计数器</li><li>在 增 强 协 程 互 相 冲 突 的 效 果 后 ， 读 写 锁 的 性 能 要 明 显 高 于 互 斥 锁</li></ol><h3><span id="13结构体是否可以比较">13.结构体是否可以比较</span></h3><p>回到上面的划重点部分，在总结中我们可以知道，golang中 <em>Slice</em>，<em>Map</em>，<em>Function</em> 这三种数据类型是不可以直接比较的。我们再看看S结构体，该结构体并没有包含不可比较的成员变量，所以该结构体是可以直接比较的。</p><p> <em>reflect.DeepEqual 函数</em> 来对两个变量进行比较。</p><h3><span id="14golang-channel是线程安全的吗">14.golang channel是线程安全的吗</span></h3><p>如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的。不需要在并发读写同一个channe时加锁。</p><h3><span id="15channel数据结构">15.channel数据结构</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="type">uint16</span></span><br><span class="line">    closed   <span class="type">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B014grpc/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B014grpc/</id>
    <published>2021-11-17T02:28:40.000Z</published>
    <updated>2024-03-12T03:55:12.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>grpc 官网：<a href="https://grpc.io/docs/languages/go/basics/">https://grpc.io/docs/languages/go/basics/</a> 中文翻译版本：<a href="http://doc.oschina.net/grpc?t=56831">http://doc.oschina.net/grpc?t=56831</a></p></blockquote><p>1、下载protobuf的编译器protoc</p><p>地址：</p><p>1、<code>https://github.com/google/protobuf/releases</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window：</span><br><span class="line">  下载: protoc-3.3.0-win32.zip</span><br><span class="line">  解压，把bin目录下的protoc.exe复制到GOPATH/bin下，GOPATH/bin加入环境变量。</span><br><span class="line">当然也可放在其他目录，需加入环境变量，能让系统找到protoc.exe</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">    下载：protoc-3.3.0-linux-x86_64.zip 或 protoc-3.3.0-linux-x86_32.zip</span><br><span class="line">解压，把bin目录下的protoc复制到GOPATH/bin下，GOPATH/bin加入环境变量。</span><br><span class="line">如果喜欢编译安装的，也可下载源码自行安装，最后将可执行文件加入环境变量。</span><br></pre></td></tr></table></figure><p>2、获取protobuf的编译器插件<code>protoc-gen-go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  进入GOPATH目录</span><br><span class="line">  运行</span><br><span class="line">&gt; go get -u github.com/golang/protobuf/protoc-gen-go</span><br><span class="line">  如果成功，会在GOPATH/bin下生成protoc-gen-go.exe文件</span><br></pre></td></tr></table></figure><p>3、创建一个<code>test.proto</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//指定版本</span><br><span class="line">//注意proto3与proto2的写法有些不同</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"> </span><br><span class="line">//包名，通过protoc生成时go文件时</span><br><span class="line">package test;</span><br><span class="line"> </span><br><span class="line">//手机类型</span><br><span class="line">//枚举类型第一个字段必须为0</span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    HOME = 0;</span><br><span class="line">    WORK = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//手机</span><br><span class="line">message Phone &#123;</span><br><span class="line">    PhoneType type = 1;</span><br><span class="line">    string number = 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//人</span><br><span class="line">message Person &#123;</span><br><span class="line">    //后面的数字表示标识号</span><br><span class="line">    int32 id = 1;</span><br><span class="line">    string name = 2;</span><br><span class="line">    //repeated表示可重复</span><br><span class="line">    //可以有多个手机</span><br><span class="line">    repeated Phone phones = 3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//联系簿</span><br><span class="line">message ContactBook &#123;</span><br><span class="line">    repeated Person persons = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; protoc --go_out=. *.proto</span><br><span class="line">会生成一个test.pb.go的文件，具体的文件内容我就不截图了。</span><br></pre></td></tr></table></figure><p>5、在go语言中使用protobuf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">    &quot;protobuf/test&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func write() &#123;</span><br><span class="line">    p1 := &amp;test.Person&#123;</span><br><span class="line">        Id:   1,</span><br><span class="line">        Name: &quot;小张&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;111111111&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;222222222&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    p2 := &amp;test.Person&#123;</span><br><span class="line">        Id:   2,</span><br><span class="line">        Name: &quot;小王&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;333333333&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;444444444&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    //创建地址簿</span><br><span class="line">    book := &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    book.Persons = append(book.Persons, p1);</span><br><span class="line">    book.Persons = append(book.Persons, p2);</span><br><span class="line"> </span><br><span class="line">    //编码数据</span><br><span class="line">    data, _ := proto.Marshal(book);</span><br><span class="line">    //把数据写入文件</span><br><span class="line">    ioutil.WriteFile(&quot;./test.txt&quot;, data, os.ModePerm);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func read() &#123;</span><br><span class="line">    //读取文件数据</span><br><span class="line">    data, _ := ioutil.ReadFile(&quot;./test.txt&quot;);</span><br><span class="line">    book := &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    //解码数据</span><br><span class="line">    proto.Unmarshal(data, book);</span><br><span class="line">    for _, v := range book.Persons &#123;</span><br><span class="line">        fmt.Println(v.Id, v.Name);</span><br><span class="line">        for _, vv := range v.Phones &#123;</span><br><span class="line">            fmt.Println(vv.Type, vv.Number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    write();</span><br><span class="line">    read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5367714-2eb580ad8e2e7a93.png" alt="img"></p><p>image.png</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//go:generate protoc -I ../routeguide --go_out=plugins=grpc:../routeguide ../routeguide/route_guide.proto protoc</span><br></pre></td></tr></table></figure><p><code>-I</code> 参数：指定import路径，可以指定多个-I参数，编译时按顺序查找，不指定时默认查找当前目录</p><p><code>--go_out</code> ：golang编译支持，支持以下参数<br>plugins&#x3D;plugin1+plugin2 - 指定插件，目前只支持grpc，即：plugins&#x3D;grpc</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
</feed>
