<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Some</title>
  <icon>https://www.gravatar.com/avatar/df6fc96953fb3fc0fe9399149caa86b8</icon>
  <subtitle>https://smartxia.github.io/blog</subtitle>
  <link href="https://smartxia.github.io/blog/atom.xml" rel="self"/>
  
  <link href="https://smartxia.github.io/blog/"/>
  <updated>2024-07-17T03:12:24.348Z</updated>
  <id>https://smartxia.github.io/blog/</id>
  
  <author>
    <name>夏夏天</name>
    <email>xiapeifu@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s中如何做到动态分配网络域名</title>
    <link href="https://smartxia.github.io/blog/2024/07/17/K8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/"/>
    <id>https://smartxia.github.io/blog/2024/07/17/K8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/</id>
    <published>2024-07-17T03:00:56.000Z</published>
    <updated>2024-07-17T03:12:24.348Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s中关于服务网络的使用</title>
    <link href="https://smartxia.github.io/blog/2024/07/17/K8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://smartxia.github.io/blog/2024/07/17/K8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2024-07-17T02:59:54.000Z</published>
    <updated>2024-07-17T03:02:37.629Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>golang Context上下文</title>
    <link href="https://smartxia.github.io/blog/2024/07/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
    <id>https://smartxia.github.io/blog/2024/07/15/GOLANG/GOLANG-Context%E4%B8%8A%E4%B8%8B%E6%96%87/</id>
    <published>2024-07-15T10:56:27.000Z</published>
    <updated>2024-07-31T07:15:10.346Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="/blog/image.png" alt="alt text"></p><p><a href="https://zhuanlan.zhihu.com/p/68792989">https://zhuanlan.zhihu.com/p/68792989</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>k8s-有状态服务无状态服务和对外访问服务</title>
    <link href="https://smartxia.github.io/blog/2024/04/12/K8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://smartxia.github.io/blog/2024/04/12/K8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2024-04-12T08:43:25.000Z</published>
    <updated>2024-04-12T08:46:22.286Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol><li>基本概念<br>无状态服务<br>无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.</li></ol><p>有状态服务<br>有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.</p><ol start="2"><li>Deployment部署的问题?</li></ol><p>Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?</p><p>无状态服务内的多个Pod创建的顺序是没有顺序的.<br>无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化.<br>无状态服务内的多个Pod背后是共享存储的.<br>2.1.新的问题</p><p>对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了.<br>比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致.<br>所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master&#x2F;slave角色)必须有自己独立的持久化存储组件.<br>有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储.<br>所以K8S提供了一个新的工具——StatefulSet来统一解决问题.</p><ol start="3"><li>Stateful如何解决问题?<br>Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.</li></ol><p>而Stateful管理有状态的应用,它的Pod有如下特征:</p><p>唯一性: 每个Pod会被分配一个唯一序号.<br>顺序性: Pod启动,更新,销毁是按顺序进行.<br>稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化.<br>稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.</p><p>3.1. 如何理解稳定网络标识?</p><p>创建名为test-redis-pod的Stateful模型,根据你配置的Replica&#x3D;3的设置,K8S会创建三个Pod,依次命名为: test-redis-pod-0; test-redis-pod-1; test-redis-pod-2</p><p>K8S为有状态的服务Pod分配稳定的网络标识,具体实现基于test-redis-pod-0名称,借助Headless DNS进行如下解析,获取后端其中一个Pod的地址.</p><p>$(pod name).$(service name).$(namespace).svc.cluster.local<br>下面是一个通过Pod名称访问Redis集群的Master节点地址的方法.</p><p>session.save_path &#x3D; “tcp:&#x2F;&#x2F;test-redis-pod-0.test-redis-service.default.svc.cluster.local:6379”<br>现在回答如下二个问题:</p><p>在Redis Pod内部,主从节点之间数据同步的需求,Slave节点对应的配置文件中需要一个稳定的Master地址.下边脚本就是稳定访问test-redis-pod-0 名称来间接获得Redis Master节点IP地址,然后写入到Redis Slave的配置文件中,这样后续Slave节点与Master节点才能完成增量数据的同步.<br>if [ “${server_host}” !&#x3D; “test-redis-pod-0” ];then<br>        #echo “server-count: ${server_counts}” &gt;&gt; &#x2F;data&#x2F;test.log</p><pre><code>    while [ -z &quot;$&#123;master_address&#125;&quot; ];do        echo &quot;master_address is not available, $&#123;master_address&#125; waiting for redis master...&quot; &gt;&gt; /data/test.log        master_address=$(replication_master_address)        sleep 1s    donefiecho &quot;master_address: $(master_address)&quot; &gt;&gt; /data/test.logif [ ! -z &quot;$master_address&quot; ]; then    printf &quot;\nslaveof %s 6379\n&quot; &quot;$master_address&quot; &gt;&gt; $conffi</code></pre><p>在Redis Pod外部, 可以通过$(pod name).$(service name).$(namespace).svc.cluster.local方式来访问具体的Pod服务.<br>3.2. 如何理解稳定持久化存储?</p><p>每个Redis Pod对应一个自己的PVC&#x2F;PV.当Pod发生调度时,需要在别的节点启动时,根据Pod背后关联的存储信息保证其名称的稳定性.</p><p>Pod还是会attach挂载到原来的PV&#x2F;PVC中,从而确定每个Pod有自己专用的存储卷.</p><ol start="4"><li>总结<br>本文主要介绍了无状态和有状态服务在K8S中的典型应用场景.</li></ol><p>通过对Deployment部署无状态服务所遇到问题的分析,引出了Stateful新的部署组件.它是通过支持Pod一些特性(e.g. 名称唯一性,稳定的网络标识, 稳定的持久化存储等)来实现在K8S中部署运维有状态服务.</p><p>牢记: Stateful有状态服务,每个Pod有独立的PVC&#x2F;PV存储组件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-StorageClass PV PVC 概念和使用</title>
    <link href="https://smartxia.github.io/blog/2024/04/12/K8s/k8s-4-StorageClass%20PV%20PVC/"/>
    <id>https://smartxia.github.io/blog/2024/04/12/K8s/k8s-4-StorageClass%20PV%20PVC/</id>
    <published>2024-04-12T02:25:53.000Z</published>
    <updated>2024-04-12T07:59:31.963Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>负责把PVC绑定到PV的是一个持久化存储卷控制循环，这个控制器也是kube-manager-controller的一部分运行在master上。而真正把目录挂载到容器上的操作是在POD所在主机上发生的，所以通过kubelet来完成。而且创建PV以及PVC的绑定是在POD被调度到某一节点之后进行的，完成这些操作，POD就可以运行了。下面梳理一下挂载一个PV的过程：</p><p>用户提交一个包含PVC的POD</p><p>调度器把根据各种调度算法把该POD分配到某个节点，比如node01</p><p>Node01上的kubelet等待Volume Manager准备存储设备</p><p>PV控制器调用存储插件创建PV并与PVC进行绑定</p><p>Attach&#x2F;Detach Controller或Volume Manager通过存储插件实现设备的attach。（这一步是针对块设备存储）</p><p>Volume Manager等待存储设备变为可用后，挂载该设备到&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;&lt;Pod 的 ID&gt;&#x2F;volumes&#x2F;kubernetes.io~&lt;Volume 类型 &gt;&#x2F;&lt;Volume 名字 &gt;目录上</p><p>Kubelet被告知卷已经准备好，开始启动POD，通过映射方式挂载到容器中</p><p>总结：本地卷也就是LPV不支持动态供给的方式，延迟绑定，就是为了综合考虑所有因素再进行POD调度。其根本原因是动态供给是先调度POD到节点，然后动态创建PV以及绑定PVC最后运行POD；而LPV是先创建与某一节点关联的PV，然后在调度的时候综合考虑各种因素而且要包括PV在哪个节点，然后再进行调度，到达该节点后在进行PVC的绑定。也就说动态供给不考虑节点，LPV必须考虑节点。所以这两种机制有冲突导致无法在动态供给策略下使用LPV。换句话说动态供给是PV跟着POD走，而LPV是POD跟着PV走。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记7-error.group用法</title>
    <link href="https://smartxia.github.io/blog/2024/03/26/GOLANG/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/"/>
    <id>https://smartxia.github.io/blog/2024/03/26/GOLANG/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/</id>
    <published>2024-03-26T06:18:21.000Z</published>
    <updated>2024-03-26T07:02:26.582Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4><span id="1-先看下数据结构">1 .先看下数据结构</span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">sem <span class="keyword">chan</span> token</span><br><span class="line"></span><br><span class="line">errOnce sync.Once</span><br><span class="line">err     <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="2在并发编程里-syncwaitgroup">2.在并发编程里 sync.WaitGroup</span></h4><p>并发原语的使用频率非常高，它经常用于协同等待的场景 gorouting 都完成后才能继续执行。</p><p>如果在woker goroutine的执行过程中遇到错误并想要处理该怎么办？</p><p>WaitGroup并没有提供传播错误的功能，遇到这种场景我们该怎么办？Go语言在扩展库提供了ErrorGroup并发原语正好适合在这种场景下使用，它在WaitGroup的基础上还提供了，错误传播以及上下文取消的功能。</p><p>扩展库通过errorgroup.Group提供ErrorGroup原语的功能，它有三个方法可调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func WithContext(ctx context.Context) (*Group, context.Context)</span><br><span class="line">func (g *Group) Go(f func() error)</span><br><span class="line">func (g *Group) Wait() error</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ErrorGroup有一个特点是会返回所以执行任务的goroutine遇到的第一个错误</span></span><br></pre></td></tr></table></figure><h4><span id="3想让程序遇到错误就终止其他子任务">3.想让程序遇到错误就终止其他子任务</span></h4><p>最早执行遇到错误的goroutine输出了Error: 98但是所有未执行完的其他任务并没有停止执行，那么想让程序遇到错误就终止其他子任务该怎么办呢？我们可以用errgroup.Group提供的WithContext方法创建一个带可取消上下文功能的ErrorGroup。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用errorgroup.Group时注意它的两个特点：</span><br><span class="line">- errgroup.Group在出现错误或者等待结束后都会调用 Context对象 的 cancel 方法同步取消信号。</span><br><span class="line">- 只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</span><br><span class="line">*/</span><br><span class="line">func main() &#123;</span><br><span class="line">   eg, ctx := errgroup.WithContext(context.Background())</span><br><span class="line"></span><br><span class="line">   for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">      i := i</span><br><span class="line">      eg.Go(func() error &#123;</span><br><span class="line">         time.Sleep(2 * time.Second)</span><br><span class="line"></span><br><span class="line">         select &#123;</span><br><span class="line">         case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;Canceled:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         default:</span><br><span class="line">            if i &gt; 90 &#123;</span><br><span class="line">               fmt.Println(&quot;Error:&quot;, i)</span><br><span class="line">               return fmt.Errorf(&quot;Error: %d&quot;, i)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(&quot;End:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   if err := eg.Wait(); err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="4cancle到其他的子任务">4.cancle到其他的子任务</span></h4><p>在上面的例子中，子goroutine出现错误后，会cancle到其他的子任务，但是我们并没有看到调用ctx的cancel方法，下面我们看下源码，看看内部是怎么处理的。<br> errgroup 的设计非常精练，全部代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package errgroup</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// A Group is a collection of goroutines working on subtasks that are part of</span><br><span class="line">// the same overall task.</span><br><span class="line">//</span><br><span class="line">// A zero Group is valid and does not cancel on error.</span><br><span class="line">type Group struct &#123;</span><br><span class="line">    cancel func()</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    errOnce sync.Once</span><br><span class="line">    err     error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WithContext returns a new Group and an associated Context derived from ctx.</span><br><span class="line">//</span><br><span class="line">// The derived Context is canceled the first time a function passed to Go</span><br><span class="line">// returns a non-nil error or the first time Wait returns, whichever occurs</span><br><span class="line">// first.</span><br><span class="line">func WithContext(ctx context.Context) (*Group, context.Context) &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    return &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Wait blocks until all function calls from the Go method have returned, then</span><br><span class="line">// returns the first non-nil error (if any) from them.</span><br><span class="line">func (g *Group) Wait() error &#123;</span><br><span class="line">    g.wg.Wait()</span><br><span class="line">    if g.cancel != nil &#123;</span><br><span class="line">        g.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    return g.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Go calls the given function in a new goroutine.</span><br><span class="line">//</span><br><span class="line">// The first call to return a non-nil error cancels the group; its error will be</span><br><span class="line">// returned by Wait.</span><br><span class="line">func (g *Group) Go(f func() error) &#123;</span><br><span class="line">    g.wg.Add(1)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer g.wg.Done()</span><br><span class="line"></span><br><span class="line">        if err := f(); err != nil &#123;</span><br><span class="line">            g.errOnce.Do(func() &#123;</span><br><span class="line">                g.err = err</span><br><span class="line">                if g.cancel != nil &#123;</span><br><span class="line">                    g.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，errgroup 的实现依靠于结构体 Group，它通过封装 sync.WaitGroup，继承了 WaitGroup 的特性，在 Go() 方法中新起一个子任务 goroutine，并在 Wait() 方法中通过 sync.WaitGroup 的 Wait 进行阻塞等待。</p><p>同时 Group 利用 sync.Once 保证了它有且仅会保留第一个子 goroutine 错误。<br> Group 通过嵌入 context.WithCancel 方法产生的 <code>cancel</code> 函数（对于 Context 不熟悉的读者，推荐阅读 <a href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&mid=2247484553&idx=1&sn=ce4c7e052bacf69c38e27d71187726c8&scene=21%23wechat_redirect">理解Context机制</a> 一文），能够<strong>在子 goroutine 发生错误时，及时通过调用 cancle 函数，将 Context 的取消信号及时传播出去。</strong></p><h4><span id="5总结">5.总结:</span></h4><p>使用errorgroup.Group时注意它的特点：</p><ul><li>继承了 WaitGroup 的功能</li><li>errgroup.Group在出现错误或者等待结束后都会调用Context对象 的 cancel 方法同步取消信号。</li><li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</li><li>context 信号传播：如果子任务 goroutine 中有循环逻辑，则可以添加 ctx.Done 逻辑，此时通过 context 的取消信号，提前结束子任务执行。</li></ul><p>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="error.group" scheme="https://smartxia.github.io/blog/tags/error-group/"/>
    
  </entry>
  
  <entry>
    <title>k8s-kubeadmin安装</title>
    <link href="https://smartxia.github.io/blog/2024/03/18/K8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/"/>
    <id>https://smartxia.github.io/blog/2024/03/18/K8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/</id>
    <published>2024-03-18T03:30:15.000Z</published>
    <updated>2024-04-12T02:34:54.583Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>通过kubeadm工具，部署k8s集群。操作步骤如下：</p><ol><li><p>准备工作：</p></li><li><ol><li>配置yum源，repo(防被墙)</li><li>安装常用工具，同步时间</li><li>关闭防火墙，将SELinux配置为Permissive模式，关闭swap</li><li>加载ipvs模块，优化内核</li></ol></li><li><p>在所有机器上安装docker</p></li><li><p>在所有机器上安装kubeadm, kubelet, kubectl</p></li><li><p>部署集群Master节点</p></li><li><p>部署集群工作节点</p></li><li><p>安装CNI网络插件</p></li></ol><ul><li>一个Kubernetes集群Master节点。k8s官网现在将master节点称为control plane node(控制平面节点)</li><li>一个Kubernetes集群Slave节点。k8s官网叫worker node(工作节点)。下文中Slave节点和工作节点含义含义相同。</li></ul><table><thead><tr><th>hostname</th><th>ip</th><th>备注</th><th></th></tr></thead><tbody><tr><td>master</td><td>master.k8s</td><td>192.168.246.133</td><td>k8s主节点(control plane node)</td></tr><tr><td>slave</td><td>slave.k8s</td><td>192.168.246.132</td><td>k8s 工作节点(worker node)</td></tr></tbody></table><h2><span id="0-系统要求">0. <strong>系统要求</strong></span></h2><p>安装之前，请确保操作系统满足如下要求：</p><ol><li>Linux内核操作系统，如CentOS，Ubuntu等</li><li>至少2 CPU， 2GB</li><li>集群中所有机器之间的网络必须是通的(公共或私有网络都可以)。</li><li>每个节点都有唯一的主机名、MAC地址和product_uuid</li><li>部署时要保证能连外网</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看操作系统</span></span></span><br><span class="line">cat /proc/version</span><br><span class="line">hostnamectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看IP和MAC命令</span></span></span><br><span class="line">ip link</span><br><span class="line">ifconfig -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看product_uuid</span></span></span><br><span class="line">sudo cat /sys/class/dmi/id/product_uuid</span><br></pre></td></tr></table></figure><h2><span id="1-准备工作"><strong>1. 准备工作</strong></span></h2><p><strong>在所有节点上运行</strong></p><h3><span id="11-配置yum源repo"><strong>1.1 配置yum源，repo</strong></span></h3><p>由于众所周知的原因，为防止在安装时出现资源下载失败的问题，在所有节点上配置yum源，repo。shell如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum源</span></span><br><span class="line">curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker repo</span></span><br><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes repo</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure><h3><span id="12-安装常用的工具同步时间"><strong>1.2 安装常用的工具，同步时间</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum -y install tree vim wget bash-completion bash-completion-extras lrzsz net-tools sysstat iotop iftop htop unzip nc nmap telnet bc  psmisc httpd-tools ntpdate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时区修改,如果/etc/localtime有软连接,不是Shanghai,可以直接删除,在软链接</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate ntp2.aliyun.com            # 同步阿里云服务器上的时间.</span><br><span class="line">/sbin/hwclock --systohc            # 写入到bios系统    </span><br></pre></td></tr></table></figure><h3><span id="13-检查防火墙是否关闭将selinux配置为permissive模式关闭swap"><strong>1.3 检查防火墙是否关闭，将SELinux配置为Permissive模式，关闭swap</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看防火墙状态</span></span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果防火墙是running，关闭防火墙</span></span></span><br><span class="line">sudo systemctl disable firewalld &amp;&amp; systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Set SELinux to permissive mode.将SELinux配置为Permissive模式</span></span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 也可以直接关闭SELinux</span></span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo setenforce 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo sed -ri <span class="string">&#x27;s#(SELINUX=).*#\1disabled#&#x27;</span> /etc/selinux/config</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时关闭swap。如果不关闭，kubelet会启动失败</span></span><br><span class="line">sudo swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久防止开机自动挂载swap</span></span><br><span class="line">sudo sed -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h3><span id="14-加载ipvs模块优化内核"><strong>1.4 加载ipvs模块，优化内核</strong></span></h3><p>如下参数不修改，会导致<code>kubeadm init</code>运行失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载ipvs模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证ip_vs模块</span></span><br><span class="line">lsmod |grep ip_vs</span><br><span class="line">ip_vs_wrr              12697  0 </span><br><span class="line">ip_vs_rr               12600  0 </span><br><span class="line">ip_vs_sh               12688  0 </span><br><span class="line">ip_vs                 145458  6 ip_vs_rr,ip_vs_sh,ip_vs_wrr</span><br><span class="line">nf_conntrack          139264  2 ip_vs,nf_conntrack_ipv4</span><br><span class="line">libcrc32c              12644  3 xfs,ip_vs,nf_conntrack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核文件</span> </span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效并验证内核优化</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><h2><span id="2-安装docker"><strong>2. 安装docker</strong></span></h2><p><em>在所有节点上运行</em></p><h3><span id="21-安装启动docker"><strong>2.1 安装启动docker</strong></span></h3><p>注意：安装docker需要root权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. yum 安装</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 运行sudo yum install docker-ce 也是可以的，docker-ce依赖了docker-ce-cli, containerd.io, docker-buildx-plugin, docker-compose-plugin。这些依赖会同步install</span></span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 配置docker</span></span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://registry.hub.docker.com&quot;,</span><br><span class="line">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 启动docker</span></span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>验证是否安装正确</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4. docker运行正常</span></span><br><span class="line">[shirley@master k8s_install]$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2023-10-10 09:23:41 CST; 19s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 16381 (dockerd)</span><br><span class="line">    Tasks: 8</span><br><span class="line">   Memory: 27.4M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─16381 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/con...</span><br><span class="line">[shirley@master k8s_install]$</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行docker命令，验证镜像下载正常，容器运行正常</span></span><br><span class="line">[shirley@slave k8s_install]$ sudo docker run hello-world</span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">719385e32844: Pull complete</span><br><span class="line">Digest: sha256:4f53e2564790c8e7856ec08e384732aa38dc43c52f02952483e3f003afbf23db</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h3><span id="22-配置containerd中pause镜像地址"><strong>2.2 配置containerd中pause镜像地址</strong></span></h3><p>为了防止安装过程中出现pause镜像下载失败的问题，建议运行<code>containerd config dump &gt; /etc/containerd/config.toml </code>命令，将当前配置导出到文件，并修改<code>sandbox_image</code>配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果没有/etc/containerd/config.toml文件，将默认配置导出到/etc/containerd/config.toml。</span></span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置</span></span></span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># PS: 如果生成的/etc/containerd/config.toml中没有如上配置项，可以运行如下命令导出当前所有配置项后再修改文件/etc/containerd/config.toml</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">containerd config dump &gt; /etc/containerd/config.toml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重启containerd</span></span></span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h2><span id="3-部署kubeadm-kubelet-kubectl"><strong>3. 部署kubeadm, kubelet, kubectl</strong></span></h2><p>kubeadm：启动k8s集群的工具</p><p>kubelet: 该组件在集群中的所有机器上运行，并执行启动pod和容器之类的任务。</p><p>kubectl: 与集群通信的工具。可以只在master节点上安装。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">## 开机启动kubelet</span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看kubeadm版本</span></span><br><span class="line">[root@master ~]<span class="comment"># sudo kubeadm version</span></span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:<span class="string">&quot;1&quot;</span>, Minor:<span class="string">&quot;28&quot;</span>, GitVersion:<span class="string">&quot;v1.28.2&quot;</span>, GitCommit:<span class="string">&quot;89a4ea3e1e4ddd7f7572286090359983e0387b2f&quot;</span>, GitTreeState:<span class="string">&quot;clean&quot;</span>, BuildDate:<span class="string">&quot;2023-09-13T09:34:32Z&quot;</span>, GoVersion:<span class="string">&quot;go1.20.8&quot;</span>, Compiler:<span class="string">&quot;gc&quot;</span>, Platform:<span class="string">&quot;linux/amd64&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2><span id="4-初始化master节点kubeadm-init"><strong>4.</strong> 初始化Master节点（kubeadm init）</span></h2><p><em>在Master节点运行</em></p><h3><span id="41-更改配置文件"><strong>4.1. 更改配置文件</strong></span></h3><p><code>kubeadm init</code>命令用于初始化master节点。kubeadm init 的参数可以通过<strong>命令行</strong>或<strong>yaml文件</strong>进行配置。本文介绍如何通过yaml文件进行配置。可以通过<code>kubeadm config print init-defaults</code>命令得到一份默认配置，然后对其进行修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm.yaml</span><br></pre></td></tr></table></figure><p>对kubeadm.yaml进行编辑，修改内容如下：</p><ol><li>修改<code>advertiseAddress</code>为master IP地址</li><li><code>imageRepository</code>修改为<code>registry.aliyuncs.com/google_containers</code>，防止镜像拉不下来</li><li>建议将<code>networking.podSubnet</code>修改为<code>10.244.0.0/16</code>， 和后续安装的flannel CNI 插件的默认配置保持一致。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.246.133    ## change the IP of apiserver.</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: node</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers   ## change imageRepository to aliyun.</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.28.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  podSubnet: 10.244.0.0/16  ## add this line to config POD network. Same with CNI config.</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure><p>如上配置文件等价于命令行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.246.133 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.28.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 </span><br></pre></td></tr></table></figure><ul><li>–apiserver-advertise-address 集群通告地址</li><li>–image-repository 由于默认拉取镜像地址<a href="https://link.zhihu.com/?target=http://k8s.gcr.io">http://k8s.gcr.io</a>国内无法访问，这里指定阿里云镜像仓库地址</li><li>–kubernetes-version K8s版本，与上面安装的一致</li><li>–service-cidr 集群内部虚拟网络，Pod统一访问入口</li><li>–pod-network-cidr Pod网络，<strong>与下面部署的CNI网络组件yaml中保持一致</strong></li></ul><h3><span id="42-提前pull镜像可选"><strong>4.2 提前pull镜像（可选）</strong></span></h3><p>为了使后续安装更快，建议先把安装需要的镜像pull下来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 验证配置文件格式是否正确</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config validate --config kubeadm.yaml</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看需要下载哪些镜像。需要关注下载的repository地址是否正确。</span></span><br><span class="line"><span class="comment">## 如上在kubeadm.yaml文件配置了imageRepository：registry.aliyuncs.com/google_containers，因此images会从aliyun的repo下载。</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config images list --config kubeadm.yaml</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">## pull镜像。pull镜像有点慢，第一个镜像pull成功后才有日志输出。命令运行后发现没有日志不要着急，多等一会。</span></span><br><span class="line">[shirley@master k8s_install]$ sudo kubeadm config images pull --config kubeadm.yaml</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><h3><span id="43-kubeadm-init初始化"><strong>4.3 kubeadm init初始化</strong></span></h3><p>运行<code>kubeadm init --config kubeadm.yaml</code>， 当看到<code>Your Kubernetes control-plane has initialized successfully!</code>时表示安装成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master k8s_install]<span class="comment"># kubeadm init --config kubeadm.yaml</span></span><br><span class="line">... ...</span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p><strong>PS：最好将最后一行log需要记下来，worker节点安装会用到。</strong></p><p>根据提示，退出root账户后运行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><h3><span id="44-验证"><strong>4.4 验证</strong></span></h3><p>验证master节点是否部署成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## kubectl 运行正常. STATUS=NotReady是因为CNI插件还没装。</span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME   STATUS     ROLES           AGE   VERSION</span><br><span class="line">node   NotReady   control-plane   20m   v1.28.2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 通过crictl命令可以查看到运行的container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo crictl ps -a</span><br><span class="line">CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID              POD</span><br><span class="line">955b0c87ad621       ea1030da44aa1       26 minutes ago      Running             kube-proxy                0                   78efbee65dfac       kube-proxy-kp9kw</span><br><span class="line">f69d8c3246904       73deb9a3f7025       26 minutes ago      Running             etcd                      0                   77180bc7ff0a8       etcd-node</span><br><span class="line">3efba65f263d3       f6f496300a2ae       26 minutes ago      Running             kube-scheduler            0                   f89fb4bb60e2e       kube-scheduler-node</span><br><span class="line">5dfb28390f30b       4be79c38a4bab       26 minutes ago      Running             kube-controller-manager   0                   b716cb4652e1c       kube-controller-manager-node</span><br><span class="line">b8cfce31fa842       bb5e0dde9054c       26 minutes ago      Running             kube-apiserver            0                   006db1ce43cfe       kube-apiserver-node</span><br></pre></td></tr></table></figure><p>这里有大家可能有个疑惑，为什么docker ps看不到运行的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 运行docker命令，发现没有container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><p>这是因为kubernetes使用的containerd作为容器运行时，而不是Docker engine. kubernetes支持4中容器运行时：</p><table><thead><tr><th>Runtime</th><th>Path to Unix domain socket（CRI socket）</th></tr></thead><tbody><tr><td>containerd</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock</td></tr><tr><td>CRI-O</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;crio&#x2F;crio.sock</td></tr><tr><td>Docker Engine (using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr><tr><td>Mirantis Container Runtime (MCR)(using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr></tbody></table><p>By default, Kubernetes uses the Container Runtime Interface (CRI) to interface with your chosen container runtime.</p><p>默认情况下，kubernetes会用CRI找到选择的容器运行时。在我们安装docker时，安装了containerd，因此k8s找到了containerd作为容器运行时。在kubeadm.yam文件中也能看到相应的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>为什么k8s不选用docker engine作为容器运行时？因为如果使用docker engine, 还需要安装cri-dockerd，才能作为容器时被k8s识别。而如上操作并未安装。</p><p>此外，k8s推荐直接使用containerd作为容器运行时。</p><h2><span id="5-初始化工作节点"><strong>5. 初始化工作节点</strong></span></h2><h3><span id="51-运行kubeadm-join将工作节点加入集群"><strong>5.1 运行kubeadm join将工作节点加入集群</strong></span></h3><p>在master节点kubeadm init安装完成后，会有如下类似log</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.. ... </span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p>将上述命令粘贴到工作节点，将工作节点添加到集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slave ~]# kubeadm join 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot; could not be reached</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot;: lookup slave.k8s on 192.168.246.2:53: no such host</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><h3><span id="52-验证"><strong>5.2 验证</strong></span></h3><p>到master节点运行kubelet get node,可以看到加进来的node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl get nodes</span><br><span class="line">NAME        STATUS     ROLES           AGE    VERSION</span><br><span class="line">node        NotReady   control-plane   121m   v1.28.2</span><br><span class="line">slave.k8s   NotReady   &lt;none&gt;          28s    v1.28.2</span><br></pre></td></tr></table></figure><p>当前STATUS都是NotReady，这是因为还没有安装网络插件CNI</p><h3><span id="53-忘记token怎么办"><strong>5.3 忘记token怎么办</strong></span></h3><p>如果master节点安装时，没有记录下token，或token超时(默认24小时)，可以运行如下命令重新生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubeadm token create --print-join-command</span><br><span class="line">kubeadm join 192.168.246.133:6443 --token by8q23.65btteq9iud7ypso --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><h2><span id="6-安装cni网络插件"><strong>6. 安装CNI网络插件</strong></span></h2><p>Kubernetes 它需要网络插件来提供集群内部和集群外部的网络通信。以下是一些常用的 k8s 网络插件：</p><ul><li>Flannel：Flannel 是最常用的 k8s 网络插件之一，它使用了虚拟网络技术来实现容器之间的通信，支持多种网络后端，如 VXLAN、UDP 和 Host-GW。</li><li>Calico：Calico 是一种基于 BGP 的网络插件，它使用路由表来路由容器之间的流量，支持多种网络拓扑结构，并提供了安全性和网络策略功能。</li><li>Canal：Canal 是一个组合了 Flannel 和 Calico 的网络插件，它使用 Flannel 来提供容器之间的通信，同时使用 Calico 来提供网络策略和安全性功能。</li><li>Weave Net：Weave Net 是一种轻量级的网络插件，它使用虚拟网络技术来为容器提供 IP 地址，并支持多种网络后端，如 VXLAN、UDP 和 TCP&#x2F;IP，同时还提供了网络策略和安全性功能。</li><li>Cilium：Cilium 是一种基于 eBPF (Extended Berkeley Packet Filter) 技术的网络插件，它使用 Linux 内核的动态插件来提供网络功能，如路由、负载均衡、安全性和网络策略等。</li><li>Contiv：Contiv 是一种基于 SDN 技术的网络插件，它提供了多种网络功能，如虚拟网络、网络隔离、负载均衡和安全策略等。</li><li>Antrea：Antrea 是一种基于 OVS (Open vSwitch) 技术的网络插件，它提供了容器之间的通信、网络策略和安全性等功能，还支持多种网络拓扑结构。</li></ul><table><thead><tr><th>提供商</th><th>网络模型</th><th>路线分发</th><th>网络策略</th><th>网格</th><th>外部数据存储</th><th>加密</th><th>Ingress&#x2F;Egress 策略</th></tr></thead><tbody><tr><td>Canal</td><td>封装 (VXLAN)</td><td>否</td><td>是</td><td>否</td><td>K8s API</td><td>是</td><td>是</td></tr><tr><td>Flannel</td><td>封装 (VXLAN)</td><td>否</td><td>否</td><td>否</td><td>K8s API</td><td>是</td><td>否</td></tr><tr><td>Calico</td><td>封装（VXLAN，IPIP）或未封装</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr><tr><td>Weave</td><td>封装</td><td>是</td><td>是</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Cilium</td><td>封装 (VXLAN)</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr></tbody></table><p>Calico 和 Flannel都是常用的CNI，如下介绍如何安装flannel网络插件</p><h3><span id="61-安装flannel网络插件"><strong>6.1 安装flannel网络插件</strong></span></h3><ol><li>下载kube-flannel.yml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. 下载kube-flannel.yml</span></span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p><code>kube-flannel.yaml</code>文件中，需要注意，net-conf.json里的network要和kubeadm.yaml里配置的networking.podSubnet相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      ### 这里的network和kubeadm.yaml里配置的networking.podSubnet相同 </span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><ol start="2"><li>容器部署flannel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl apply -f kube-flannel.yml</span><br><span class="line">namespace/kube-flannel created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure><h3><span id="62-验证cni"><strong>6.2 验证CNI</strong></span></h3><p>安装后，运行<code>kubectl -n kube-system get pod -o wide</code>， 可以看到在master节点和slave节点分别运行了一个kube-proxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 每个节点上都运行了kube-proxy</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl -n kube-system get pod -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE     IP                NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66f779496c-d8rws       1/1     Running   0          4h40m   10.244.0.3        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66f779496c-fzmjm       1/1     Running   0          4h40m   10.244.0.2        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-node                      1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-node   1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-bpv8d               1/1     Running   0          160m    192.168.246.132   slave.k8s   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-kp9kw               1/1     Running   0          4h40m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># node状态显示为Ready</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME        STATUS   ROLES           AGE     VERSION</span><br><span class="line">node        Ready    control-plane   4h38m   v1.28.2</span><br><span class="line">slave.k8s   Ready    &lt;none&gt;          158m    v1.28.2</span><br></pre></td></tr></table></figure><p>自此，集群搭建完成。</p><h2><span id="其他说明"><strong>其他说明</strong></span></h2><p>另外，在初始安装的Master节点上也启动了<code>kubelet</code>和<code>kube-proxy</code>，在默认情况下并不参与工作负载的调度。如果希望Master节点也作为Node角色，则可以运行下面的命令（删除Master节点的：<code>node-role.kubernetes.io/control-plane:NoSchedule</code>），让Master节点也成为一个Node：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>k8s-IPVS概念原理以及应用</title>
    <link href="https://smartxia.github.io/blog/2024/03/18/K8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
    <id>https://smartxia.github.io/blog/2024/03/18/K8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</id>
    <published>2024-03-18T03:24:31.000Z</published>
    <updated>2024-04-12T02:34:47.746Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="ipvs的概念-原理及应用">IPVS的概念、原理及应用</span></h3><h3><span id="一-什么是ipvs">一、什么是IPVS</span></h3><p>LVS（Linux 虚拟服务器）和 IPVS（IP 虚拟服务器）是 Linux 中用于构建可扩展和高性能网络服务的两种相关技术。</p><p>LVS 是 Linux 系统的内核级负载均衡解决方案。 它允许您在多个服务器之间分配传入的网络流量，创建一个服务器集群，在客户端看来就像一个虚拟服务器。 LVS 中的负载均衡算法可以根据各种因素（例如循环法、最少连接数和源 IP 哈希）来分配流量。 </p><h3><span id="二-ipvs的工作原理">二、IPVS的工作原理</span></h3><p>IPVS的工作原理基于网络地址转换（Network Address Translation，NAT）和端口转换（Port Translation）。</p><p>当一个网络请求到达IPVS，IPVS会根据预设的调度算法选择一个后端服务器，然后修改网络请求的目标IP地址和端口，使其指向选择的后端服务器。</p><p>当后端服务器处理完请求后，IPVS会将服务器的响应转发回原始请求的客户端。</p><p>在这个过程中，客户端并不知道实际上是哪个后端服务器处理了它的请求。</p><h3><span id="三-ipvs的主要特性">三、IPVS的主要特性</span></h3><p>丰富的调度算法：IPVS支持多种调度算法，包括最小连接（Least-Connection）、轮询（Round-Robin）和加权轮询（Weighted Round-Robin）等，满足不同应用场景的需求。<br>健康检查：IPVS能够定期对后端服务器进行健康检查，当检测到某个服务器故障时，可以将其从服务列表中移除，防止向故障服务器发送请求。<br>高性能：由于IPVS是Linux内核的一部分，因此处理网络请求的效率非常高。IPVS支持大规模并发连接，能够处理每秒数以万计的网络请求。<br>易于集成：IPVS可以与其他Linux内核模块和用户空间工具一起使用，如iptables和keepalived等，提供更加强大和灵活的网络服务。</p><h3><span id="四-ipvs的应用场景">四、IPVS的应用场景</span></h3><p>IPVS广泛应用于大规模的互联网服务，如网站、在线视频和游戏等，提供高可用性和高性能的网络服务。</p><p>此外，IPVS也在云计算、大数据和容器技术等领域有广泛的应用，例如在Kubernetes中，IPVS作为服务代理的一种模式，为集群内的服务提供负载均衡。</p><p>综上所述，LVS 是 Linux 系统的综合负载均衡解决方案，而 IPVS 是 LVS 中专门处理 IP 负载均衡的组件。 LVS 利用 IPVS 在多个真实服务器之间分发流量，并为各种网络服务提供可扩展性和容错性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/categories/k8s/"/>
    
    
    <category term="k8s" scheme="https://smartxia.github.io/blog/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>PHP-析构函数-destruct</title>
    <link href="https://smartxia.github.io/blog/2024/03/12/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
    <id>https://smartxia.github.io/blog/2024/03/12/PHP/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</id>
    <published>2024-03-12T03:55:12.845Z</published>
    <updated>2024-03-12T03:55:12.845Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3><span id="析构函数destruct">析构函数destruct</span></h3><p><img src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：__construct()在初始化对象的时候默认执行的<br>析构函数：__destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data = [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#x27;appkey&#x27;] = getAppkey();</span><br><span class="line">        $data[&#x27;channel&#x27;] = getChannel();</span><br><span class="line">        $this-&gt;data[] = $data;</span><br><span class="line">        //这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id = $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#x27;id &lt;&#x27; =&gt; $id - 50000</span><br><span class="line">            ], &#x27;&#x27;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend=new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="PHP" scheme="https://smartxia.github.io/blog/categories/PHP/"/>
    
    
    <category term="php" scheme="https://smartxia.github.io/blog/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-笔记-ArrayMapSlice</title>
    <link href="https://smartxia.github.io/blog/2024/03/12/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
    <id>https://smartxia.github.io/blog/2024/03/12/GOLANG/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</id>
    <published>2024-03-12T03:55:12.820Z</published>
    <updated>2024-03-12T03:55:12.820Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. := = ==</span><br><span class="line"></span><br><span class="line">:= 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">= 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">== 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 := make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val := make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">ch := make(chan int, 100) // make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">// 并把值赋给 v</span><br><span class="line">​```</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="Slice" scheme="https://smartxia.github.io/blog/tags/Slice/"/>
    
  </entry>
  
  <entry>
    <title>darp Docs</title>
    <link href="https://smartxia.github.io/blog/2022/03/16/darp-Docs/"/>
    <id>https://smartxia.github.io/blog/2022/03/16/darp-Docs/</id>
    <published>2022-03-16T06:59:18.000Z</published>
    <updated>2024-03-12T03:55:12.897Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>dapr 文档贡献<br>dapr 文档贡献规则：<a href="https://docs.dapr.io/zh-hans/contributing/contributing-docs/">https://docs.dapr.io/zh-hans/contributing/contributing-docs/</a></p><p>dapr 文档网站使用hugo 开发工具：</p><p>Windows：安装流程<br>安装scoope<br>powerSheel ：执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br><span class="line"></span><br><span class="line">iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)</span><br><span class="line"></span><br><span class="line">执行scoope help 查看是否安装正常</span><br><span class="line"></span><br><span class="line">执行   scoop install hugo</span><br><span class="line">      scoop install hugo-extended</span><br><span class="line">这两部即可 完成对其安装</span><br><span class="line"></span><br><span class="line">文档：https://gohugo.io/getting-started/installing/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="1执行doc仓库下载和安装依赖">1.执行doc仓库下载和安装依赖</span></h3><p>仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https://github.com.cnpmjs.org/dapr/docs.git</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">这步可能遇到下载不下来情况，可以按照此步骤进行操作</span><br><span class="line"></span><br><span class="line">1.执行 git submodule update --init</span><br><span class="line">2.去.gitmodules文件 进行编辑将所有的https://github.com  后缀加上 cnpmjs.org</span><br><span class="line">(这个原理可以参考:谷歌插件---GitHub加速1.3.5)</span><br><span class="line">3.然后利用git submodule sync更新子项目对应的url</span><br><span class="line">4.git submodule update --init --recursive，最后执行</span><br><span class="line"></span><br><span class="line">//s2-cdn.oneitfarm.com/6d3518411d074f9eae604f77da39da83.png</span><br></pre></td></tr></table></figure><p><img src="//s2-cdn.oneitfarm.com/a23f2220daff4375ba97522c7edc552c.png"></p><p>错误1.</p><p><img src="//s2-cdn.oneitfarm.com/c036d24abc364f00be0870faec874818.png" alt="image-20220316151455745"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用git代理：</span><br><span class="line">git config *--global https.proxy*</span><br><span class="line">执行命令后取消代理</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>错误2：</p><p><img src="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png" alt="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是因为没有执行git module的 下载</span><br></pre></td></tr></table></figure><h3><span id="2安装依赖">2.安装依赖</span></h3><p>此项目使用的还是npm </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install （很慢） </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="dapr" scheme="https://smartxia.github.io/blog/categories/dapr/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc-2</title>
    <link href="https://smartxia.github.io/blog/2021/12/09/GOLANG/GOLANG-grpc-2/"/>
    <id>https://smartxia.github.io/blog/2021/12/09/GOLANG/GOLANG-grpc-2/</id>
    <published>2021-12-09T07:05:54.000Z</published>
    <updated>2024-03-12T03:55:12.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>脑图：</p><p><a href="https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5">https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5</a></p><p>服务端的操作：</p><p>取出server</p><p>挂载方法</p><p>注册服务</p><p>创建监听</p><p>客户端：</p><p>创建链接</p><p>new 一个client</p><p>调用client方法</p><p>获取返回值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>x86和arm架构区别</title>
    <link href="https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://smartxia.github.io/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-12-02T08:22:44.000Z</published>
    <updated>2024-03-12T03:55:12.898Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是arm架构">什么是arm架构</span></h3><p>ARM架构过去称之为进阶精简指令集机器，是一个32位的精简指令集（RISC）处理器架构，其广泛的使用在嵌入式系统设计，由于节能的特点，ARM非常适合处理移动通讯领域，符合其设计目标低消耗 电量的特性，在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.</p><p>arm架构图</p><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据&#x2F;地址寄存器组成.</p><p><img src="http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg"></p><p>1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</p><p>2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移&#x2F;右移n位、环移n位和算术右移n位等都可以一次完成。</p><p>3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1&#x2F;3）。</p><p>4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</p><p>5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</p><p>6、寄存器</p><h2><span id="x86架构"><strong>x86架构</strong></span></h2><p><img src="http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg"></p><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><p>   1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</p><p>　2： 北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</p><p>　3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I&#x2F;O总线较多，离处理器远一点有利于布线。</p><p>　4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p><p>　5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</p><p>　6：显示j接口</p><p>　7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>　8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</p><p>　9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</p><p>　10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</p><p>　11：总线</p><h2><span id="arm架构和x86架构有什么区别"><strong>arm架构和x86架构有什么区别</strong></span></h2><p><strong>一、性能</strong> </p><p>​    X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。</p><p>　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.</p><p><strong>二、扩展能力</strong></p><p>​    X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.</p><p>　　ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.</p><p> <strong>三、操作系统的兼容性</strong></p><p>​    X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。</p><p>　　ARM系统几乎都采用<strong>Linux</strong>的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的<strong>Android</strong>系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.</p><p><strong>四、软件开发的方便性及可使用工具的多样性</strong></p><p>​    X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。</p><p>　　Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。</p><p>　　对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。</p><p>　　从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：<strong>功耗.</strong></p><p><strong>五、功耗</strong> </p><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>HTTP 请求方法之CONNECT method</title>
    <link href="https://smartxia.github.io/blog/2021/11/25/HTTP/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/"/>
    <id>https://smartxia.github.io/blog/2021/11/25/HTTP/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/</id>
    <published>2021-11-25T01:36:06.000Z</published>
    <updated>2024-03-12T03:55:12.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>HTTP1.1 中的connect<br>1.http请求代理就是connect这个方法，connect网页开发中不会使用<br>2.connect的作用将服务器作为代理，让服务器提用户访问其他网页（翻墙），之后将数据返回用户<br>3.connect是将通过TCP代理链接服务器的，假如我想让代理服务器访问，<a href="https://baidu.com网站,首先要简历一条客户端到代理服务器的tcp的链接/">https://baidu.com网站，首先要简历一条客户端到代理服务器的tcp的链接</a><br>然后给代理服务器发送一个http报文</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECT https://www.jianshu.com/u/f67233ce6c0c:80 HTTP/1.1</span><br><span class="line">Host: www.web-tinker.com:80</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Proxy-Authorization: Basic *</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>在发送完这个请求之后，代理服务器会响应请求，返回一个200的信息，但这个200并不同于我们平时见到的OK，而是Connection Established</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="HTTP" scheme="https://smartxia.github.io/blog/categories/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>弱势文化</title>
    <link href="https://smartxia.github.io/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/"/>
    <id>https://smartxia.github.io/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/</id>
    <published>2021-11-22T05:37:08.000Z</published>
    <updated>2024-03-12T03:55:12.916Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="https://pic1.zhimg.com/v2-bb213c477bc9d02350862acc72395838_720w.jpg?source=3af55fa1" alt="preview"></p><p>知识的快餐：我们为什么要懂点哲学<br>什么是哲学，哲学可不可以理解成为人的认知的差异，哲学里的文化属性到底代表着什么</p><blockquote><p>闲暇产生思辨，思辨消解教条主义和陈腐习俗，发展出敏锐的感知，让人丧失行动的决断。</p><p>思想，在分析迷宫冒险前行，发现社会背后的个体，玻璃其正常的社会功能，转向内在，发现自我</p><p>共同的利益，和共同体的意识衰退，如今没有公民只有个人</p><p>个体通过思索意识到自己本身就是生存的目的，他要求国际从此以往加强而不是利用他的能力，以此为代价，个人将维持国家的持续</p></blockquote><p><strong>社会经济的发展带来的我们物质和生活的增长，被冠以着数十年来通过个体努力的结果，于是国家造就了弱势文化的典型思想:误以为将自己的生活水平的提高，是通过自己勤劳获取的，殊不知这是吃着国家的红利，而并非自己真的可以通过真正的努力获取的温饱</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="diary" scheme="https://smartxia.github.io/blog/categories/diary/"/>
    
    
  </entry>
  
  <entry>
    <title>GOLANG-GPM的深入理解</title>
    <link href="https://smartxia.github.io/blog/2021/11/18/GOLANG/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>https://smartxia.github.io/blog/2021/11/18/GOLANG/GOLANG-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2021-11-18T02:08:03.000Z</published>
    <updated>2024-03-12T03:55:12.806Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>深入golang runtime的调度</p><h3><span id="理解调度器的启动">理解调度器的启动</span></h3><p>runtime：</p><p>scheduler:</p><p>TLS:</p><p>spinning:</p><p>systemstack,mcall,asmcgocall</p><p>主要源码文件:</p><p>调度基本组件：</p><p>**G(goroutine)**：调度器的基本单位，存储的goroutine的执行stack信息，状态以及任务函数</p><p>在g的眼中只有p,p就是运行的G的“CPU”</p><p>相当于两级线程</p><blockquote><p>g的任务函数</p></blockquote><p>每个g的实例都有任务函数，如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userFun:=func()&#123;fmt.Println(&quot;111&quot;)&#125;</span><br><span class="line">go userFunc();</span><br></pre></td></tr></table></figure><p>go的关键词创建了一个goroutine,此时gouroutine的任务函数userFun</p><p><strong>P（processor）</strong></p><p>p表示逻辑processor，代表M执行的上下文</p><p>p的最大作用是拥有各种G的对象队列，链表，cache,和状态</p><p>p的数量也代表go的执行并发度，即多少个goroutine可以同时执行</p><p>这里的p虽然表示逻辑处理器，但是p并不代表任何执行代码，对于g来说，p相当于cpu的核，g只有绑定p才能调度。对于M来说，p提供了执行环境（Context），如分配内存状态（mcache）,任务队列G等</p><p><strong>M(machine)</strong></p><p>M代表真正的执行计算资源，可以任务他就是os thread(系统线程)</p><p>M是真正的执行者，每个M就像一个勤劳的工作者，总是从各种队列找到可运行的G,而且这样的M的可以同时存在多个</p><p>M在绑定有效P，可以进行调度循环，而且M并不保留G状态，这个是g可以跨M调度的基础</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-纯纯的语法仔的没落</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/</id>
    <published>2021-11-17T03:57:39.000Z</published>
    <updated>2024-03-12T03:55:12.821Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="基础">基础</span></h2><h3><span id="1-对于已经关闭的channel的处理">1. 对于已经关闭的channel的处理</span></h3><p>读已经关闭的channel，一直能读到东西，但是读到的东西根据通道内关闭前是否有元素而不同，</p><ul><li>关闭前，buffer有还未读取的，会读取到chan内的值，且返回是否读取成功的bool值为true</li><li>关闭前，buffer的值读完，channel元素值为0，bool值为false</li></ul><p>写入：直接panic</p><h3><span id="2-make和new区别">2. Make和new区别</span></h3><p>make：返回特定类型channel，slice,map</p><p>new: 开辟新内存和指针，泛化类型</p><h3><span id="3-nil-切片和空切片一不一样">3. nil 切片和空切片一不一样</span></h3><p>指向的地址不一样。nill引用指针地址为0，空切片执行数组指针地址，且为一个固定值</p><p>数据结构：data,len,cap</p><h3><span id="4-字符串转byte数组会发生内存拷贝吗">4. 字符串转byte数组，会发生内存拷贝吗</span></h3><p>严格来说，只要发生类型强转，都会发生内存拷贝。</p><p>那么go有个很强的包叫 <code>unsafe</code> 。先获取变量地址，字符串转成底层结构，通过unsafe包，转为切片数组,再通过指针指向实际内容</p><p>string 数据结构 {data,len} </p><h3><span id="5-json包变量不加tag会怎么样">5. json包变量不加tag会怎么样</span></h3><p>和key的大小写有关</p><h3><span id="6-gpm">6. GPM</span></h3><p>指向另一篇详细（）</p><h3><span id="7docker-的网络通信模式">7.Docker 的网络通信模式。</span></h3><p>四种：</p><p>1.host模式：和宿主机公用一个network NameSpace 。容器不会配置任何自己网卡，而是使用自己宿主机的IP和端口</p><p>2.container模式：指定和其他容器共享network nameSpace,而不是和宿主机共享</p><p>3.none模式：告诉容器放到自己网站堆里，但是不要配置他的网络</p><p>4.brideg模式：docker默认的网络模式，此模式会将主机docker链接到虚拟网桥上</p><h3><span id="8访问私有成员">8.访问私有成员</span></h3><blockquote><p>调用其他包共有结构的私有成员变<strong>量</strong></p></blockquote><p><strong>绕过小写不公开</strong></p><p>用unsafe包中的unsafe.Pointer获取到结构体对象的首地址，然后加上想访问的私有变量的偏移地址就是私有变量的地址</p><h3><span id="9-数组和切片的区别">9、数组和切片的区别</span></h3><p>长度，容量，数组指针</p><p>切片是指针类型，数组是是值类型</p><p>数据长度固定，切片不固定</p><p>切片比数组多个属性（cap）,切片底层是数组</p><ul><li>扩容：小于1024 每次cap翻倍，超过变成1.25</li><li>扩容后没触及原数组容量，那么切片指针指向的位置，还是原数组，扩容后，超过原数组容量，会开辟一块新内存，原来的值拷贝过来，也不会影响原来数组</li><li>append:</li></ul><h3><span id="10介绍-rune-类型">10.介绍 rune 类型</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var str = &quot;hello 你好&quot;</span><br><span class="line">    fmt.Println(&quot;len(str):&quot;, len(str))</span><br><span class="line">    //12个 </span><br><span class="line">    //中文字符在unicode下占2个字节，在utf-8编码下占3个字节 go默认utf-8 5+1+3*2</span><br><span class="line">    //通过rune类型处理unicode字符</span><br><span class="line">    fmt.Println(&quot;rune:&quot;, len([]rune(str))) //8个</span><br><span class="line">    fmt.Println(&quot;RuneCountInString:&quot;, utf8.RuneCountInString(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>byte等同于uint8，而不是int8</p><p>rune 等同于int32,常用来处理unicode或utf-8字符</p><h3><span id="11-panic-defer-recover">11 panic defer recover</span></h3><p>panic() 函数</p><p>函数中遇到panic语句，会立即终止当前函数的执行，在panic所在函数内如果存在要执行的defer函数列表，按照defer的逆序执行</p><p>recover() 函数</p><p>recover函数的返回值报告协程是否正在遭遇panic</p><p>有异常时，recover()只能调用一次，后面再次调用则捕获不到任何异常</p><p>通常办法：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理，从而恢复正常代码的执行</p><h3><span id="12-读写锁和互斥锁">12 读写锁和互斥锁</span></h3><p>总结：</p><ol><li>1.在单纯的只是获取锁和释放锁时，互斥锁的用时要少一些，这主要是因为多个线程同时获取读写锁的情况比较少出现。</li><li>golang底层实现上，互斥锁确实要比读写锁的性能要好一些，这主要是因为读写锁的底层实现其实是互斥锁加上计数器</li><li>在 增 强 协 程 互 相 冲 突 的 效 果 后 ， 读 写 锁 的 性 能 要 明 显 高 于 互 斥 锁</li></ol><h3><span id="13结构体是否可以比较">13.结构体是否可以比较</span></h3><p>回到上面的划重点部分，在总结中我们可以知道，golang中 <em>Slice</em>，<em>Map</em>，<em>Function</em> 这三种数据类型是不可以直接比较的。我们再看看S结构体，该结构体并没有包含不可比较的成员变量，所以该结构体是可以直接比较的。</p><p> <em>reflect.DeepEqual 函数</em> 来对两个变量进行比较。</p><h3><span id="14golang-channel是线程安全的吗">14.golang channel是线程安全的吗</span></h3><p>如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的。不需要在并发读写同一个channe时加锁。</p><h3><span id="15channel数据结构">15.channel数据结构</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="type">uint16</span></span><br><span class="line">    closed   <span class="type">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>GOLANG-grpc</title>
    <link href="https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-grpc/"/>
    <id>https://smartxia.github.io/blog/2021/11/17/GOLANG/GOLANG-grpc/</id>
    <published>2021-11-17T02:28:40.000Z</published>
    <updated>2024-03-12T03:55:12.807Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>grpc 官网：<a href="https://grpc.io/docs/languages/go/basics/">https://grpc.io/docs/languages/go/basics/</a> 中文翻译版本：<a href="http://doc.oschina.net/grpc?t=56831">http://doc.oschina.net/grpc?t=56831</a></p></blockquote><p>1、下载protobuf的编译器protoc</p><p>地址：</p><p>1、<code>https://github.com/google/protobuf/releases</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window：</span><br><span class="line">  下载: protoc-3.3.0-win32.zip</span><br><span class="line">  解压，把bin目录下的protoc.exe复制到GOPATH/bin下，GOPATH/bin加入环境变量。</span><br><span class="line">当然也可放在其他目录，需加入环境变量，能让系统找到protoc.exe</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">    下载：protoc-3.3.0-linux-x86_64.zip 或 protoc-3.3.0-linux-x86_32.zip</span><br><span class="line">解压，把bin目录下的protoc复制到GOPATH/bin下，GOPATH/bin加入环境变量。</span><br><span class="line">如果喜欢编译安装的，也可下载源码自行安装，最后将可执行文件加入环境变量。</span><br></pre></td></tr></table></figure><p>2、获取protobuf的编译器插件<code>protoc-gen-go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  进入GOPATH目录</span><br><span class="line">  运行</span><br><span class="line">&gt; go get -u github.com/golang/protobuf/protoc-gen-go</span><br><span class="line">  如果成功，会在GOPATH/bin下生成protoc-gen-go.exe文件</span><br></pre></td></tr></table></figure><p>3、创建一个<code>test.proto</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//指定版本</span><br><span class="line">//注意proto3与proto2的写法有些不同</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"> </span><br><span class="line">//包名，通过protoc生成时go文件时</span><br><span class="line">package test;</span><br><span class="line"> </span><br><span class="line">//手机类型</span><br><span class="line">//枚举类型第一个字段必须为0</span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    HOME = 0;</span><br><span class="line">    WORK = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//手机</span><br><span class="line">message Phone &#123;</span><br><span class="line">    PhoneType type = 1;</span><br><span class="line">    string number = 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//人</span><br><span class="line">message Person &#123;</span><br><span class="line">    //后面的数字表示标识号</span><br><span class="line">    int32 id = 1;</span><br><span class="line">    string name = 2;</span><br><span class="line">    //repeated表示可重复</span><br><span class="line">    //可以有多个手机</span><br><span class="line">    repeated Phone phones = 3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//联系簿</span><br><span class="line">message ContactBook &#123;</span><br><span class="line">    repeated Person persons = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; protoc --go_out=. *.proto</span><br><span class="line">会生成一个test.pb.go的文件，具体的文件内容我就不截图了。</span><br></pre></td></tr></table></figure><p>5、在go语言中使用protobuf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">    &quot;protobuf/test&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func write() &#123;</span><br><span class="line">    p1 := &amp;test.Person&#123;</span><br><span class="line">        Id:   1,</span><br><span class="line">        Name: &quot;小张&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;111111111&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;222222222&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    p2 := &amp;test.Person&#123;</span><br><span class="line">        Id:   2,</span><br><span class="line">        Name: &quot;小王&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;333333333&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;444444444&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    //创建地址簿</span><br><span class="line">    book := &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    book.Persons = append(book.Persons, p1);</span><br><span class="line">    book.Persons = append(book.Persons, p2);</span><br><span class="line"> </span><br><span class="line">    //编码数据</span><br><span class="line">    data, _ := proto.Marshal(book);</span><br><span class="line">    //把数据写入文件</span><br><span class="line">    ioutil.WriteFile(&quot;./test.txt&quot;, data, os.ModePerm);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func read() &#123;</span><br><span class="line">    //读取文件数据</span><br><span class="line">    data, _ := ioutil.ReadFile(&quot;./test.txt&quot;);</span><br><span class="line">    book := &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    //解码数据</span><br><span class="line">    proto.Unmarshal(data, book);</span><br><span class="line">    for _, v := range book.Persons &#123;</span><br><span class="line">        fmt.Println(v.Id, v.Name);</span><br><span class="line">        for _, vv := range v.Phones &#123;</span><br><span class="line">            fmt.Println(vv.Type, vv.Number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    write();</span><br><span class="line">    read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5367714-2eb580ad8e2e7a93.png" alt="img"></p><p>image.png</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//go:generate protoc -I ../routeguide --go_out=plugins=grpc:../routeguide ../routeguide/route_guide.proto protoc</span><br></pre></td></tr></table></figure><p><code>-I</code> 参数：指定import路径，可以指定多个-I参数，编译时按顺序查找，不指定时默认查找当前目录</p><p><code>--go_out</code> ：golang编译支持，支持以下参数<br>plugins&#x3D;plugin1+plugin2 - 指定插件，目前只支持grpc，即：plugins&#x3D;grpc</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>数据四层七层</title>
    <link href="https://smartxia.github.io/blog/2021/11/10/REDIS/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/"/>
    <id>https://smartxia.github.io/blog/2021/11/10/REDIS/%E6%95%B0%E6%8D%AE%E5%9B%9B%E5%B1%82%E4%B8%83%E5%B1%82/</id>
    <published>2021-11-10T07:08:25.000Z</published>
    <updated>2024-03-12T03:55:12.870Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="reids" scheme="https://smartxia.github.io/blog/categories/reids/"/>
    
    
  </entry>
  
  <entry>
    <title>golang里的进程线程携程的调度方式</title>
    <link href="https://smartxia.github.io/blog/2021/10/10/GOLANG/golang%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/"/>
    <id>https://smartxia.github.io/blog/2021/10/10/GOLANG/golang%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/</id>
    <published>2021-10-10T10:56:27.000Z</published>
    <updated>2024-03-12T03:55:12.824Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>找工作本来想靠实力和经验，奈何仍需背面试题，刷算法，可以说是可恶了<br>作者：腾讯技术工程<br>链接：<a href="https://www.zhihu.com/question/20862617/answer/921061289">https://www.zhihu.com/question/20862617/answer/921061289</a><br>来源：知乎</p><h2><span id="goroutine-实现">goroutine 实现:</span></h2><p><img src="https://pic1.zhimg.com/50/v2-5f7f337c089077babfbe296e8a82c88a_720w.jpg?source=1940ef5c" alt="img"></p><p>我们去看调度的一个进化, 从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程. go 实现的协程为有栈协程, go 协程的用法和线程的用法基本类似. 很多人会疑问, 协程到底是个什么东西? 用户态的调度感觉很陌生, 很抽象, 到底是个什么东西?</p><p>我觉得要理解调度, 要理解两个概念: 运行和阻塞. 特别是在协程中, 这两个概念不容易被正确理解. 我们理解概念时往往会代入自身感受, 觉得线程或协程运行就是像我们吭哧吭哧的处理事情, 线程或协程阻塞就是做事情时我们需要等待其他人. 然后就在这等着了. 要是其他人搞好了, 那我们就继续做当前的事.</p><p>其实主体对象搞错了.正确的理解应该是我们处理事情时就像 CPU, 而不是像线程或者协程. 假如我当前在写某个服务, 发现依赖别人的函数还没有 ready, 那就把写服务这件事放一边. 点开企业微信, 我去和产品沟通一些问题了. 我和产品沟通了一会后, 检查一下, 发现别人已经把依赖的函数提交了, 然后我就最小化企业微信, 切到 IDE, 继续写服务 A 了.</p><p>对操作系统有过一些了解, 知道 linux 下的线程其实是 task_struct 结构, 线程其实并不是真正运行的实体, 线程只是代表一个执行流和其状态.真正运行驱动流程往前的其实是 CPU. CPU 在时钟的驱动下, 根据 PC 寄存器从程序中取指令和操作数, 从 RAM 中取数据, 进行计算, 处理, 跳转, 驱动执行流往前. CPU 并不关注处理的是线程还是协程, 只需要设置 PC 寄存器, 设置栈指针等(这些称为上下文), 那么 CPU 就可以欢快的运行这个线程或者这个协程了.</p><p>线程的运行, 其实是被运行.其阻塞, 其实是切换出调度队列, 不再去调度执行这个执行流. 其他执行流满足其条件, 便会把被移出调度队列的执行流重新放回调度队列.协程同理, 协程其实也是一个数据结构, 记录了要运行什么函数, 运行到哪里了.<br>go 在用户态实现调度, 所以 go 要有代表协程这种执行流的结构体, 也要有保存和恢复上下文的函数, 运行队列. 理解了阻塞的真正含义, 也就知道能够比较容易理解, 为什么 go 的锁, channel 这些不阻塞线程.</p><p>对于实现的同步执行流效果, 又不阻塞线程的网络, 接下来也会介绍.</p><h3><span id="协程结构体和切换函数"><strong>协程结构体和切换函数</strong></span></h3><p><img src="https://pic1.zhimg.com/50/v2-85a56b6e215d2b427ac4f5252ce3c619_720w.jpg?source=1940ef5c" alt="img"></p><p>我们 go 一个 func 时一般这样写</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func1(arg1 type1,arg2 type2)&#123;....&#125;(a1,a2)</span><br></pre></td></tr></table></figure><p>一个协程代表了一个执行流, 执行流有需要执行的函数(对应上面的 func1), 有函数的入参(a1, a2), 有当前执行流的状态和进度(对应 CPU 的 PC 寄存器和 SP 寄存器), 当然也需要有保存状态的地方, 用于执行流恢复.</p><p>真正代表协程的是 runtime.g 结构体. 每个 go func 都会编译成 runtime.newproc 函数, 最终有一个 runtime.g 对象放入调度队列. 上面的 func1 函数的指针设置在 runtime.g 的 startfunc 字段, 参数会在 newproc 函数里拷贝到 stack 中, sched 用于保存协程切换时的 pc 位置和栈位置.</p><p>协程切换出去和恢复回来需要保存上下文, 恢复上下文, 这些由以下两个汇编函数实现. 以上就能实现协程这种执行流, 并能进行切换和恢复.(下图中的 struct 和函数都做了精简)</p><h3><span id="gm-模型及-gpm-模型"><strong>GM 模型及 GPM 模型</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-836e26770ed9489f835605529e608c37_720w.jpg?source=1940ef5c" alt="img"></p><p>有了协程的这种执行流形式, 那待运行的协程放在哪呢?<br>在 Go1.0 的时候:</p><ol><li>调度队列 schedt 是全局的, 对该队列的操作均需要竞争同一把锁, 导致伸缩性不好.</li><li>新生成的协程也会放入全局的队列, 大概率是被其他 m(可以理解为底层线程的一个表示)运行了, 内存亲和性不好. 当前协程 A 新生成了协程 B, 然后协程 A 比较大概率会结束或者阻塞, 这样 m 直接去执行协程 B, 内存的亲和性也会好很多.</li><li>因为 mcache 与 m 绑定, 在一些应用中(比如文件操作或其他可能会阻塞线程的系统调用比较多), m 的个数可能会远超过活跃的 m 个数, 导致比较大的内存浪费.</li></ol><p>那是不是可以给 m 分配一个队列, 把阻塞的 m 的 mcache 给执行 go 代码的 m 使用? Go 1.1 及以后就是这样做的.</p><p><img src="https://pic1.zhimg.com/50/v2-a06db1f245421b17c64d7bc4f338b71e_720w.jpg?source=1940ef5c" alt="img"></p><p>再 1.1 中调度模型更改为 GPM 模型, 引入逻辑 Process 的概念, 表示执行 Go 代码所需要的资源, 同时也是执行 Go 代码的最大的并行度.</p><p>这个概念可能很多人不知道怎么理解. P 涉及到几点, 队列和 mcache, 还有 P 的个数的选取.</p><p>首先为什么把全局队列打散, 以及 mcache 为什么跟随 P, 这个在 GM 模型那一页就讲的比较清楚了.然后为什么 P 的个数默认是 CPU 核数: Go 尽量提升性能, 那么在一个 n 核机器上, 如何能够最大利用 CPU 性能呢? 当然是同时有 n 个线程在并行运行中, 把 CPU 喂饱, 即所有核上一直都有代码在运行.</p><p>在 go 里面, 一个协程运行到阻塞系统调用, 那么这个协程和运行它的线程 m, 自然是不再需要 CPU 的, 也不需要分配 go 层面的内存. 只有一直在并行运行的 go 代码才需要这些资源, 即同时有 n 个 go 协程在并行执行, 那么就能最大的利用 CPU, 这个时候需要的 P 的个数就是 CPU 核数. (注意并行和并发的区别)</p><h2><span id="协程状态及流转"><strong>协程状态及流转</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-95c62d2ff20b8a75e0ec2eddddaf4bd2_720w.jpg?source=1940ef5c" alt="img"></p><p>协程的状态其实和线程状态类似,状态转换和发生状态转换的时机如图所示. 还是需要注意: 协程只是一个执行流, 并不是运行实体.</p><h2><span id="调度"><strong>调度</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-0328b09cc3dd5537bd463e10ef17db6e_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有一个一直在运行调度的调度器实体. 当一个协程切换出去或新生成的 m, go 的运行时从 stw 中恢复等情况时, 那么接下来就需要发生调度. go 的调度是通过线程(m)执行 runtime.schedule 函数来完成的.</p><h2><span id="sysmon-协程"><strong>sysmon 协程</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-28f751cb1c56fcc275bc545d7f82d869_720w.jpg?source=1940ef5c" alt="img"></p><p>在 linux 内核中有一些执行定时任务的线程, 比如定时写回脏页的 pdflush, 定期回收内存的 kswapd0, 以及每个 cpu 上都有一个负责负载均衡的 migration 线程等.在 go 运行时中也有类似的协程, sysmon.功能比较多: 定时从 netpoll 中获取 ready 的协程, 进行抢占, 定时 GC,打印调度信息,归还内存等定时任务.</p><h2><span id="协作式抢占"><strong>协作式抢占</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-d8baadb9a783032443d3d2fd6b0b5227_720w.jpg?source=1940ef5c" alt="img"></p><p>go 目前(1.12)还没有实现非协作的抢占. 基本流程是 sysmon 协程标记某个协程运行过久, 需要切换出去, 该协程在运行函数时会检查栈标记, 然后进行切换.</p><h2><span id="同步执行流不阻塞线程的网络的实现"><strong>同步执行流不阻塞线程的网络的实现</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-7bed4181eb6bbcba7be4a6b43a604c3e_720w.jpg?source=1940ef5c" alt="img"></p><p>go 写后台最舒服的就是能够以同步写代码的方式操作网络, 但是网络操作不阻塞线程.主要是结合了非阻塞的 fd, epoll 以及协程的切换和恢复.linux 提供了网络 fd 的非阻塞模式, 对于没有 ready 的非阻塞 fd 执行网络操作时, linux 内核不阻塞线程, 会直接返回 EAGAIN, 这个时候将协程状态设置为 wait, 然后 m 去调度其他协程.</p><p>go 在初始化一个网络 fd 的时候, 就会把这个 fd 使用 epollctl 加入到全局的 epoll 节点中. 同时放入 epoll 中的还有 polldesc 的指针.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func netpollopen(fd uintptr, pd *pollDesc) int32 &#123;</span><br><span class="line">    var ev epollevent</span><br><span class="line">    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sysmon 中, schedule 函数中, start the world 中等情况下, 会执行 netpoll 调用 epollwait 系统调用, 把 ready 的网络事件从 epoll 中取出来, 每个网络事件可以通过前面传入的 polldesc 获取到阻塞在其上的协程, 以此恢复协程为 runnable.</p><h2><span id="调度相关结构体"><strong>调度相关结构体</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-85359486219d4ce31b93fa450b592083_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="调度综述"><strong>调度综述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7f7ea37737a8e4ac2809a8122ba62c1c_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic1.zhimg.com/50/v2-8d5f447993ab105b88eac9fb827b2a3c_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="内存分配"><strong>内存分配</strong></span></h2><h2><span id="内存分配简介"><strong>内存分配简介</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-eb6d4ba5968ebe8a0a86318c2ef35ca6_720w.jpg?source=1940ef5c" alt="img"></p><p>Go 的分配采用了类似 tcmalloc 的结构.特点: 使用一小块一小块的连续内存页, 进行分配某个范围大小的内存需求. 比如某个连续 8KB 专门用于分配 17-24 字节,以此减少内存碎片. 线程拥有一定的 cache, 可用于无锁分配.</p><p>同时 Go 对于 GC 后回收的内存页, 并不是马上归还给操作系统, 而是会延迟归还, 用于满足未来的内存需求.</p><h2><span id="内存空间结构"><strong>内存空间结构</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-c1b2977bf1d33669bb9c2774c7b6d8d8_720w.jpg?source=1940ef5c" alt="img"></p><p>在 1.10 以前 go 的堆地址空间是线性连续扩展的, 比如在 1.10(linux amd64)中, 最大可扩展到 512GB. 因为 go 在 gc 的时候会根据拿到的指针地址来判断是否位于 go 的 heap 的, 以及找到其对应的 span, 其判断机制需要 gc heap 是连续的. 但是连续扩展有个问题, cgo 中的代码(尤其是 32 位系统上)可能会占用未来会用于 go heap 的内存. 这样在扩展 go heap 时, mmap 出现不连续的地址, 导致运行时 throw.</p><p>在 1.11 中, 改用了稀疏索引的方式来管理整体的内存. 可以超过 512G 内存, 也可以允许内存空间扩展时不连续.在全局的 mheap struct 中有个 arenas 二阶数组, 在 linux amd64 上,一阶只有一个 slot, 二阶有 4M 个 slot, 每个 slot 指向一个 heapArena 结构, 每个 heapArena 结构可以管理 64M 内存, 所以在新的版本中, go 可以管理 4M*64M&#x3D;256TB 内存, 即目前 64 位机器中 48bit 的寻址总线全部 256TB 内存.</p><h2><span id="span-机制"><strong>span 机制</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-84e72feda2d2cd49aaad59bb6f72837c_720w.jpg?source=1940ef5c" alt="img"></p><p>前面提到了 go 的内存分配类似于 tcmalloc, 采用了 span 机制来减少内存碎片. 每个 span 管理 8KB 整数倍的内存, 用于分配一定范围的内存需求.</p><h2><span id="内存分配全景"><strong>内存分配全景</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-11756712c78ee841873eb9aa22198f3c_720w.jpg?source=1940ef5c" alt="img"></p><p>多层次的分配 Cache, 每个 P 上有一个 mcache, mcache 会为每个 size 最多缓存一个 span, 用于无锁分配. 全局每个 size 的 span 都有一个 mcentral, 锁的粒度相对于全局的 heap 小很多, 每个 mcentral 可以看成是每个 size 的 span 的一个全局后备 cache.</p><p>在 gc 完成后, 会把 P 中的 span 都 flush 到 mcentral 中, 用于清扫后再分配. P 有需要 span 时, 从对应 size 的 mcentral 获取. 获取不到再上升到全局的 heap.</p><h2><span id="几种特殊的分配器"><strong>几种特殊的分配器</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-e35ffea692133cbe86898cdf3eb55352_720w.jpg?source=1940ef5c" alt="img"></p><p>对于很小的对象分配, go 做了个优化, 把小对象合并, 以移动指针的方式分配.对于栈内存有 stackcache 分配, 也有多个层次的分配, 同时 stack 也有多个不同 size. 用于分配 stack 的内存也是位于 go gc heap, 用 mspan 管理, 不过这个 span 的状态和用于分配对象的 mspan 状态不太一样, 为 mSpanManual.</p><p>我们可以思考一个问题, go 的对象是分配在 go gc heap 中, 并由 mcache, mspan, mcentral 这些结构管理, 那么 mcache, mspan, mcentral 这些结构又是哪里管理和分配的呢? 肯定不是自己管理自己. 这些都是由特殊的分配 fixalloc 分配的, 每种类型有一个 fixalloc, 大致原理就是通过 mmap 从进程空间获取一小块内存(百 KB 的样子), 然后用来分配这个固定大小的结构.</p><h2><span id="内存分配综合"><strong>内存分配综合</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-1a3d04db061c92d10bed0e5ab0df1c16_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc"><strong>GC</strong></span></h2><h2><span id="golang-gc-简述"><strong>Golang GC 简述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7eb346f748153072b454b9b78759e067_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc-简介"><strong>GC 简介</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-ecebbf99b365d076f7076b31a30fc3e8_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 并不是个新事物, 使得 GC 大放光彩的是 Java 语言.</p><p><img src="https://pica.zhimg.com/50/v2-05266f76d410fe9d90fd1dbd23570953_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic3.zhimg.com/50/v2-291b501f005c3958111daf30bcec1a2b_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="golang-gc-发展"><strong>Golang GC 发展</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-558037836bb253c0777a4a822516d27e_720w.jpg?source=1940ef5c" alt="img"></p><p>上面是几个比较重要的版本.左图是根据 twitter 工程师的数据绘制的(堆比较大), 从 1.4 的百 ms 级别的停顿到 1.8 以后的小于 1ms.右图是我对线上服务(Go 1.11 编译)测试的一个结果, 是一个批量拉取数据的服务, 大概 3000qps, 服务中发起的 rpc 调用大概在 2w&#x2F;s. 可以看到大部分情况下 GC 停顿小于 1ms, 偶尔超过一点点.</p><p>整体来说 golang gc 用起来是很舒心的, 几乎不用你关心.</p><h2><span id="三色标记"><strong>三色标记</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-652acc8ca5d0f04c455c68d1084cd309_720w.jpg?source=1940ef5c" alt="img"></p><p>go 采用的是并发三色标记清除法. 图展示的是一个简单的原理.有几个问题可以思考一下:</p><ul><li>并发情况下, 会不会漏标记对象?</li><li>对象的三色状态存放在哪?</li><li>如何根据一个对象来找到它引用的对象?</li></ul><h3><span id="写屏障"><strong>写屏障</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-8c43a67a0eba214a81f56c873504c884_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 最基本的就是正确性: 不漏标记对象, 程序还在用的对象都被清除了, 那程序就错误了. 有一点浮动垃圾是允许的.<br>在并发情况下, 如果没有一些措施来保障, 那可能会有什么问题呢?</p><p>看左边的代码和图示, 第 2 步标记完 A 对象, A 又没有引用对象, 那 A 变成黑色对象. 在第 3 步的时候, muator(程序)运行, 把对象 C 从 B 转到了 A, 第 4 步, GC 继续标记, 扫描 B, 此时 B 没有引用对象, 变成了黑色对象. 我们会发现 C 对象被漏标记了.</p><p>如何解决这个问题? go 使用了写屏障, 这里的写屏障是指由编译器生成的一小段代码. 在 gc 时对指针操作前执行的一小段代码, 和 CPU 中维护内存一致性的写屏障不太一样哈.所以有了写屏障后, 第 3 步, A.obj&#x3D;C 时, 会把 C 加入写屏障 buf. 最终还是会被扫描的.</p><p><img src="https://pic3.zhimg.com/50/v2-69b05d315557f599251e091a0d4a00d9_720w.jpg?source=1940ef5c" alt="img"></p><p>这里感受一下写屏障具体生成的代码. 我们可以看到在写入指针 slot 时, 对写屏障是否开启做了判断, 如果开启了, 会跳转到写屏障函数, 执行加入写屏障 buf 的逻辑. 1.8 中写屏障由 Dijkstra 写屏障改成了混合式写屏障, 使得 GC 停顿达到了 1ms 以下.</p><h3><span id="三色状态"><strong>三色状态</strong></span></h3><p><img src="https://pic2.zhimg.com/50/v2-4dd9c75a72c82eaf3690386dcf286cdb_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有这样一个集合把不同状态对象放到对应集合中. 只是一个逻辑上的意义.</p><h3><span id="扫描和元信息"><strong>扫描和元信息</strong></span></h3><p><img src="https://pica.zhimg.com/50/v2-ee14e9737cbb929bc95ec3af883e5474_720w.jpg?source=1940ef5c" alt="img"></p><p>gc 拿到一个指针, 如何把这个指针指向的对象其引用的子对象都加到扫描队列呢? 而且 go 还允许内部指针, 似乎更麻烦了. 我们分析一下, 要知道对象引用的子对象, 从对象开始到对象结尾, 把对象那一块内存上是指针的放到扫描队列就好了. 那我们是不是得知道对象有多大, 从哪开始到哪结束, 同时要知道内存上的 8 个字节, 哪里是指针, 哪里是普通的数据.</p><p>首先 go 的对象是 mspan 管理的, 我们如果能知道对象属于哪个 mspan, 就知道对象多大, 从哪开始, 到哪结束了. 前面我们讲到了 areans 结构, 可以通过指针加上一定得偏移量, 就知道属于哪个 heap arean 64M 块. 再通过对 64M 求余, 结合 spans 数组, 即可知道属于哪个 mspan 了.</p><p>结合 heapArean 的 bitmap 和每 8 个字节在 heapArean 中的偏移, 就可知道对象每 8 个字节是指针还是普通数据(这里的 bitmap 是在分配对象时根据 type 信息就设置了, type 信息来源于编译器生成)</p><h2><span id="gc-流程"><strong>GC 流程</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-e0eef1afbfa873db4b0faa21a4741c5f_720w.jpg?source=1940ef5c" alt="img"></p><p>1.5 和 1.12 的 GC 大致流程相同. 上图是 golang 官方的 ppt 里的图, 下图是我根据 1.12 源码绘制的.从最坏可能会有百 ms 的 gc 停顿到能够稳定在 1ms 以下, 这之间 GC 做了很多改进. 右边是我根据官方 issues 整理的一些比较重要的改进. 1.6 的分布式检测, 1.7 将栈收缩放到了并发扫描阶段, 1.8 的混合写屏障, 1.12 更改了 mark termination 检测算法, mcache flush 移除出 mark termination 等等.</p><h2><span id="golang-gc-pacer"><strong>Golang GC Pacer</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-e5d325ee3dbdf9b2911520651798a872_720w.jpg?source=1940ef5c" alt="img"></p><p>大家对并发 GC 除了怎么保证不漏指针有疑问外, 可能还会疑问, 并发 GC 如何保证能够跟得上应用程序的分配速度? 会不会分配太快了, GC 完全跟不上, 然后 OOM?</p><p>这个就是 Golang GC Pacer 的作用.</p><p>Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 以此类推.</p><p>假如上一次 GC 完成时, 存活对象 1000M, 默认 GOGC 100, 那么下次 GC 会在比较接近但小于 2000M 的时候(比如 1900M)开始, 争取在堆大小达到 2000M 的时候结束. 这之间留有一定的裕度, 会计算待扫描对象大小(根据历史数据计算)与可分配的裕度的比例, 应用程序分配内存根据该比例进行辅助 GC, 如果应用程序分配太快了, 导致 credit 不够, 那么会被阻塞, 直到后台的 mark 跟上来了,该比例会随着 GC 进行不断调整.</p><p>GC 结束后, 会根据这一次 GC 的情况来进行负反馈计算, 计算下一次 GC 开始的阈值.</p><p>如何保证按时完成 GC 呢? GC 完了后, 所有的 mspan 都需要 sweep, 类似于 GC 的比例, 从 GC 结束到下一次 GC 开始之间有一定的堆分配裕度, 会根据还有多少的内存需要清扫, 来计算分配内存时需要清扫的 span 数这样的一个比例.</p><p><img src="https://pic2.zhimg.com/50/v2-92218cc498cc9ae159ba9e95df29f4c9_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="实践与总结"><strong>实践与总结</strong></span></h2><h2><span id="观察调度"><strong>观察调度</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-78cd3a12e7aecf54c56eabca2c879f78_720w.jpg?source=1940ef5c" alt="img"></p><p>观察一下调度, 加一些请求. 我们可以看到虽然有 1000 个连接, 但是 go 只用了几个线程就能处理了, 表明 go 的网络的确是由 epoll 管理的. runqueue 表示的是全局队列待运行协程数量, 后面的数字表示每个 P 上的待运行协程数. 可以看到待处理的任务并没有增加, 表示虽然请求很多, 但完全能 hold 住.</p><p>同时可以看到, 不同 P 上有的时候可能任务不均衡, 但是一会后, 任务又均衡了, 表示 go 的 work stealing 是有效的.</p><h2><span id="观察-gc"><strong>观察 GC</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-596836ab3923ed21c32a4a961264d7d8_720w.jpg?source=1940ef5c" alt="img"></p><p>其中一些数据的含义, 在分享的时候没有怎么解释, 不过网上的解释几乎没有能完全解释正确. 我这里敲一下.<br>其实一般关注堆大小和两个 stw 的 wall time 即可.</p><p>gc 8913(第 8913 次 gc) @2163.341s(在程序运行的第 2163s) 1%(gc 所有 work 消耗的历史累计 CPU 比例, 所以其实这个数据没太大意义) 0.13(第一个 stw 的 wall time)+14(并发 mark 的 wall time)+0.20(第二个 stw 的 wall time) ms clock, 1.1(第一个 stw 消耗的 CPU 时间)+21(用户程序辅助扫描消耗的 cpu 时间)&#x2F;22(分配用于 mark 的 P 消耗的 cpu 时间)&#x2F;0(空闲的 P 用于 mark 的 cpu 时间)+1.6ms(第 2 个 stw 的 cpu 时间) cpu, 147(gc 开始时的堆大小)-&gt;149(gc 结束的堆大小)-&gt;75MB(gc 结束时的存活堆大小), 151 MB goal(本次 gc 预计结束的堆大小), 8P(8 个 P).</p><h2><span id="优化"><strong>优化</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-dd28c6e140bbcd27d737f61e980b562b_720w.jpg?source=1940ef5c" alt="img"></p><p>个人建议, 没事不要总想着优化, 好好 curd 就好.</p><p><img src="https://pica.zhimg.com/50/v2-2e0bbec8ffca844876195af2e970e8a6_720w.jpg?source=1940ef5c" alt="img"></p><p>当然还是有一些优化方法的.</p><h2><span id="一点实践"><strong>一点实践</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-827fe7197304383f74f774d3c23d8df7_720w.jpg?source=1940ef5c" alt="img"></p><p>我们将 pprof 的开启集成到模板中, 并自动选择端口, 并集成了 gops 工具, 方便查询 runtime 信息, 同时在浏览器上可直接点击生成火焰图, pprof 图, 非常的方便, 也不需要使用者关心.</p><h2><span id="问题排查的一点思路"><strong>问题排查的一点思路</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-eb8dc800c3390a55be87d142cee862f2_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="一次有意思的问题排查"><strong>一次有意思的问题排查</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-8360b4e634560ca5ac314b7b76181b98_720w.jpg?source=1940ef5c" alt="img"></p><p>负载, 依赖服务都很正常, CPU 利用率也不高, 请求也不多, 就是有很多超时.</p><p><img src="https://pic1.zhimg.com/50/v2-8a0e06b128b6f2316d8462b9dbc30e0b_720w.jpg?source=1940ef5c" alt="img"></p><p>该服务在线上打印了 debug 日志, 因为早期的服务模板开启了 gctrace, 框架把 stdout 重定向到一个文件了. 而输出 gctrace 时本来是到 console 的, 输出到文件了, 而磁盘跟不上, 导致 gctrace 日志被阻塞了.</p><p>这里更正一下 ppt 中的内容, 并不是因为 gc 没完成而导致其他协程不能运行, 而是后续 gc 无法开启, 导致实质上的 stw.<br>打印 gc trace 日志时, 已经 start the world 了, 其他协程可以开始运行了. 但是在打印 gctrace 日志时, 还保持着开启 gc 需要的锁, 所以, 打印 gc trace 日志一直没完成, 而 gc 又比较频繁, 比如 0.1s 一次, 这样会导致下一次 gc 开始时无法获取锁, 每一个进入 gc 检查的 p 阻塞, 实际上就造成了 stw.</p><h2><span id="runtime-的一点个人总结"><strong>Runtime 的一点个人总结</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-2c598eec44a5909786868950c5224a6c_720w.jpg?source=1940ef5c" alt="img"></p><p>并行, 纵向多层次, 横向多个 class, 缓存, 缓冲, 均衡.</p><h2><span id="参考文档"><strong>参考文档</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-406faead2e6957e16a50c5b42f58053a_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>本文完整 PPT 可点击下方图片获得。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;blog&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;blog&#92;assets&#92;js&#92;APlayer.m</summary>
      
    
    
    
    <category term="GOLANG" scheme="https://smartxia.github.io/blog/categories/GOLANG/"/>
    
    
    <category term="golang" scheme="https://smartxia.github.io/blog/tags/golang/"/>
    
  </entry>
  
</feed>
