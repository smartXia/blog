<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis技术总结</title>
      <link href="/blog/2025/10/15/tech/backend/database/redis/Redis-%E7%AE%80%E5%8C%96%E7%89%88%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2025/10/15/tech/backend/database/redis/Redis-%E7%AE%80%E5%8C%96%E7%89%88%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis技术总结">Redis技术总结</span></h1><h2><span id="基础概念">基础概念</span></h2><p>Redis是内存数据库，数据存储在内存中，读写速度快。</p><p>主要特点：</p><ul><li>内存存储，速度快</li><li>支持数据持久化</li><li>支持多种数据类型</li><li>单线程模型</li></ul><h2><span id="数据类型">数据类型</span></h2><h3><span id="1-string">1. String</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET key value</span><br><span class="line">GET key</span><br><span class="line">INCR key</span><br></pre></td></tr></table></figure><h3><span id="2-hash">2. Hash</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HSET <span class="built_in">hash</span> field value</span><br><span class="line">HGET <span class="built_in">hash</span> field</span><br><span class="line">HGETALL <span class="built_in">hash</span></span><br></pre></td></tr></table></figure><h3><span id="3-list">3. List</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LPUSH list item</span><br><span class="line">RPOP list</span><br><span class="line">LRANGE list 0 -1</span><br></pre></td></tr></table></figure><h3><span id="4-set">4. Set</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SADD <span class="built_in">set</span> member</span><br><span class="line">SMEMBERS <span class="built_in">set</span></span><br><span class="line">SINTER set1 set2</span><br></pre></td></tr></table></figure><h3><span id="5-sorted-set">5. Sorted Set</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD zset score member</span><br><span class="line">ZRANGE zset 0 -1</span><br><span class="line">ZREVRANGE zset 0 9</span><br></pre></td></tr></table></figure><h2><span id="持久化">持久化</span></h2><h3><span id="rdb">RDB</span></h3><ul><li>数据快照</li><li>文件小，恢复快</li><li>可能丢失数据</li></ul><h3><span id="aof">AOF</span></h3><ul><li>记录每个写操作</li><li>数据完整性高</li><li>文件大，恢复慢</li></ul><h3><span id="配置">配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><h2><span id="高级特性">高级特性</span></h2><h3><span id="事务">事务</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MULTI</span><br><span class="line">SET key1 value1</span><br><span class="line">SET key2 value2</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><h3><span id="发布订阅">发布订阅</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH channel message</span><br><span class="line">SUBSCRIBE channel</span><br></pre></td></tr></table></figure><h3><span id="管道">管道</span></h3><ul><li>批量发送命令</li><li>减少网络往返</li><li>提高性能</li></ul><h2><span id="实战应用">实战应用</span></h2><h3><span id="缓存">缓存</span></h3><ul><li>热点数据缓存</li><li>减少数据库压力</li><li>提升响应速度</li></ul><h3><span id="分布式锁">分布式锁</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock:order:123 <span class="string">&quot;locked&quot;</span> EX 30 NX</span><br></pre></td></tr></table></figure><h3><span id="消息队列">消息队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LPUSH queue:email <span class="string">&quot;email1&quot;</span></span><br><span class="line">RPOP queue:email</span><br></pre></td></tr></table></figure><h3><span id="计数器">计数器</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR page:views:article:123</span><br></pre></td></tr></table></figure><h3><span id="限流">限流</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL <span class="string">&quot;限流脚本&quot;</span> 1 key <span class="built_in">limit</span> window</span><br></pre></td></tr></table></figure><h2><span id="性能优化">性能优化</span></h2><ol><li>使用Pipeline减少网络往返</li><li>合理设置过期时间</li><li>选择合适的数据类型</li><li>避免大key</li><li>使用连接池</li></ol><h2><span id="监控">监控</span></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INFO                    <span class="comment"># 查看Redis信息</span></span><br><span class="line">INFO memory             <span class="comment"># 查看内存使用</span></span><br><span class="line">SLOWLOG GET 10          <span class="comment"># 查看慢查询</span></span><br></pre></td></tr></table></figure><h2><span id="配置建议">配置建议</span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1</span><br><span class="line">port 6379</span><br><span class="line">maxmemory 256mb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br><span class="line">save 900 1</span><br><span class="line">appendonly yes</span><br><span class="line">requirepass yourpassword</span><br></pre></td></tr></table></figure><h2><span id="常见问题">常见问题</span></h2><h3><span id="缓存穿透">缓存穿透</span></h3><ul><li>缓存空值</li><li>使用布隆过滤器</li></ul><h3><span id="缓存击穿">缓存击穿</span></h3><ul><li>使用分布式锁</li><li>设置热点数据永不过期</li></ul><h3><span id="缓存雪崩">缓存雪崩</span></h3><ul><li>设置随机过期时间</li><li>使用多级缓存</li></ul><h2><span id="总结">总结</span></h2><p>Redis是高性能的内存数据库，适合用作缓存、消息队列、分布式锁等场景。掌握基本数据类型、持久化机制和高级特性，可以大大提高系统性能。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis实战应用</title>
      <link href="/blog/2025/10/15/tech/backend/database/redis/Redis-05-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/"/>
      <url>/blog/2025/10/15/tech/backend/database/redis/Redis-05-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis实战应用">Redis实战应用</span></h1><p>Redis在实际项目中有很多应用场景，包括缓存、分布式锁、消息队列、计数器等。本文将介绍Redis在实际开发中的常见应用模式和最佳实践。</p><h2><span id="1-缓存应用">1. 缓存应用</span></h2><h3><span id="缓存穿透">缓存穿透</span></h3><p>缓存穿透是指查询一个不存在的数据，由于缓存中没有，请求会直接到达数据库。</p><h4><span id="解决方案">解决方案</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 缓存空值</span></span><br><span class="line">SET user:999999 <span class="string">&quot;&quot;</span> EX 300</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用布隆过滤器</span></span><br><span class="line"><span class="comment"># 在查询前先检查布隆过滤器</span></span><br></pre></td></tr></table></figure><h4><span id="实现示例">实现示例</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.redis_client = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">self, user_id</span>):</span><br><span class="line">        <span class="comment"># 先查缓存</span></span><br><span class="line">        cache_key = <span class="string">f&quot;user:<span class="subst">&#123;user_id&#125;</span>&quot;</span></span><br><span class="line">        cached_user = self.redis_client.get(cache_key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cached_user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cached_user == <span class="string">b&quot;&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">None</span>  <span class="comment"># 缓存空值</span></span><br><span class="line">            <span class="keyword">return</span> cached_user.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 查数据库</span></span><br><span class="line">        user = self.database.get_user(user_id)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 缓存空值，防止缓存穿透</span></span><br><span class="line">            self.redis_client.setex(cache_key, <span class="number">300</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 缓存用户数据</span></span><br><span class="line">            self.redis_client.setex(cache_key, <span class="number">3600</span>, user)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><h3><span id="缓存击穿">缓存击穿</span></h3><p>缓存击穿是指热点数据过期，大量请求直接访问数据库。</p><h4><span id="解决方案">解决方案</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用分布式锁</span></span><br><span class="line">SET lock:user:1001 <span class="string">&quot;locked&quot;</span> EX 10 NX</span><br></pre></td></tr></table></figure><h4><span id="实现示例">实现示例</span></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CacheService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_hot_data</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="comment"># 先查缓存</span></span><br><span class="line">        data = self.redis_client.get(key)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">            <span class="keyword">return</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取分布式锁</span></span><br><span class="line">        lock_key = <span class="string">f&quot;lock:<span class="subst">&#123;key&#125;</span>&quot;</span></span><br><span class="line">        lock_value = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> self.redis_client.<span class="built_in">set</span>(lock_key, lock_value, ex=<span class="number">10</span>, nx=<span class="literal">True</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 双重检查</span></span><br><span class="line">                data = self.redis_client.get(key)</span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    <span class="keyword">return</span> data.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 查询数据库</span></span><br><span class="line">                data = self.database.get_data(key)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 更新缓存</span></span><br><span class="line">                self.redis_client.setex(key, <span class="number">3600</span>, data)</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> data</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                <span class="comment"># 释放锁</span></span><br><span class="line">                <span class="keyword">if</span> self.redis_client.get(lock_key) == lock_value.encode():</span><br><span class="line">                    self.redis_client.delete(lock_key)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 等待一段时间后重试</span></span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">return</span> self.get_hot_data(key)</span><br></pre></td></tr></table></figure><h3><span id="缓存雪崩">缓存雪崩</span></h3><p>缓存雪崩是指大量缓存同时过期，导致请求直接访问数据库。</p><h4><span id="解决方案">解决方案</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 设置随机过期时间</span></span><br><span class="line">SET key1 <span class="string">&quot;value1&quot;</span> EX 3600</span><br><span class="line">SET key2 <span class="string">&quot;value2&quot;</span> EX 3650</span><br><span class="line">SET key3 <span class="string">&quot;value3&quot;</span> EX 3700</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 使用多级缓存</span></span><br><span class="line"><span class="comment"># 3. 缓存预热</span></span><br></pre></td></tr></table></figure><h2><span id="2-分布式锁">2. 分布式锁</span></h2><h3><span id="基本实现">基本实现</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取锁</span></span><br><span class="line">SET lock:order:123 <span class="string">&quot;locked&quot;</span> EX 30 NX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁</span></span><br><span class="line">DEL lock:order:123</span><br></pre></td></tr></table></figure><h3><span id="改进实现防止误删">改进实现（防止误删）</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取锁时设置唯一值</span></span><br><span class="line">SET lock:order:123 <span class="string">&quot;uuid-12345&quot;</span> EX 30 NX</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁时检查值</span></span><br><span class="line">EVAL <span class="string">&quot;</span></span><br><span class="line"><span class="string">if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">    return redis.call(&#x27;DEL&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    return 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&quot;</span> 1 lock:order:123 uuid-12345</span><br></pre></td></tr></table></figure><h3><span id="完整实现">完整实现</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DistributedLock</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, lock_name, timeout=<span class="number">30</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.lock_name = <span class="string">f&quot;lock:<span class="subst">&#123;lock_name&#125;</span>&quot;</span></span><br><span class="line">        self.timeout = timeout</span><br><span class="line">        self.identifier = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        self.lock_time = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">acquire</span>(<span class="params">self, blocking=<span class="literal">True</span>, blocking_timeout=<span class="literal">None</span></span>):</span><br><span class="line">        end = time.time() + (blocking_timeout <span class="keyword">or</span> self.timeout)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> self.redis_client.<span class="built_in">set</span>(self.lock_name, self.identifier, ex=self.timeout, nx=<span class="literal">True</span>):</span><br><span class="line">                self.lock_time = time.time()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> blocking <span class="keyword">or</span> time.time() &gt; end:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            time.sleep(<span class="number">0.001</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.lock_time <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">            return redis.call(&#x27;DEL&#x27;, KEYS[1])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        result = self.redis_client.<span class="built_in">eval</span>(script, <span class="number">1</span>, self.lock_name, self.identifier)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            self.lock_time = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">extend</span>(<span class="params">self, additional_time</span>):</span><br><span class="line">        <span class="keyword">if</span> self.lock_time <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        if redis.call(&#x27;GET&#x27;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">            return redis.call(&#x27;EXPIRE&#x27;, KEYS[1], ARGV[2])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.redis_client.<span class="built_in">eval</span>(script, <span class="number">1</span>, self.lock_name, self.identifier, self.timeout + additional_time)</span><br></pre></td></tr></table></figure><h2><span id="3-消息队列">3. 消息队列</span></h2><h3><span id="简单队列">简单队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生产者</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email1&quot;</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者</span></span><br><span class="line">RPOP queue:email</span><br></pre></td></tr></table></figure><h3><span id="阻塞队列">阻塞队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阻塞式消费</span></span><br><span class="line">BLPOP queue:email 10</span><br></pre></td></tr></table></figure><h3><span id="延时队列">延时队列</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加延时任务</span></span><br><span class="line">ZADD delay_queue 1640995200 <span class="string">&quot;task1&quot;</span></span><br><span class="line">ZADD delay_queue 1640995260 <span class="string">&quot;task2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取到期任务</span></span><br><span class="line">ZRANGEBYSCORE delay_queue 0 1640995200</span><br></pre></td></tr></table></figure><h3><span id="完整实现">完整实现</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RedisQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, queue_name</span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.queue_name = queue_name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, message</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;推送消息&quot;&quot;&quot;</span></span><br><span class="line">        self.redis_client.lpush(self.queue_name, json.dumps(message))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self, timeout=<span class="number">0</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;消费消息&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> timeout &gt; <span class="number">0</span>:</span><br><span class="line">            result = self.redis_client.brpop(self.queue_name, timeout)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="keyword">return</span> json.loads(result[<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result = self.redis_client.rpop(self.queue_name)</span><br><span class="line">            <span class="keyword">if</span> result:</span><br><span class="line">                <span class="keyword">return</span> json.loads(result)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取队列长度&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.redis_client.llen(self.queue_name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DelayQueue</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, queue_name</span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.queue_name = queue_name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">push</span>(<span class="params">self, message, delay_seconds</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加延时任务&quot;&quot;&quot;</span></span><br><span class="line">        execute_time = time.time() + delay_seconds</span><br><span class="line">        self.redis_client.zadd(self.queue_name, &#123;json.dumps(message): execute_time&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pop</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取到期任务&quot;&quot;&quot;</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        result = self.redis_client.zrangebyscore(self.queue_name, <span class="number">0</span>, now, start=<span class="number">0</span>, num=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            message = json.loads(result[<span class="number">0</span>])</span><br><span class="line">            self.redis_client.zrem(self.queue_name, result[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> message</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2><span id="4-计数器应用">4. 计数器应用</span></h2><h3><span id="基本计数器">基本计数器</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 访问计数</span></span><br><span class="line">INCR page:views:article:123</span><br><span class="line">GET page:views:article:123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量计数</span></span><br><span class="line">INCRBY user:1001:score 10</span><br><span class="line">INCRBY user:1001:score -5</span><br></pre></td></tr></table></figure><h3><span id="限流器">限流器</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 滑动窗口限流</span></span><br><span class="line">EVAL <span class="string">&quot;</span></span><br><span class="line"><span class="string">local key = KEYS[1]</span></span><br><span class="line"><span class="string">local window = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">local limit = tonumber(ARGV[2])</span></span><br><span class="line"><span class="string">local now = tonumber(ARGV[3])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 清理过期数据</span></span><br><span class="line"><span class="string">redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, key, 0, now - window)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 获取当前计数</span></span><br><span class="line"><span class="string">local current = redis.call(&#x27;ZCARD&#x27;, key)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if current &lt; limit then</span></span><br><span class="line"><span class="string">    redis.call(&#x27;ZADD&#x27;, key, now, now)</span></span><br><span class="line"><span class="string">    redis.call(&#x27;EXPIRE&#x27;, key, window)</span></span><br><span class="line"><span class="string">    return 1</span></span><br><span class="line"><span class="string">else</span></span><br><span class="line"><span class="string">    return 0</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">&quot;</span> 1 rate_limit:user:1001 60 100 1640995200</span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RateLimiter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, key_prefix=<span class="string">&quot;rate_limit&quot;</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.key_prefix = key_prefix</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_allowed</span>(<span class="params">self, identifier, limit, window</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查是否允许请求&quot;&quot;&quot;</span></span><br><span class="line">        key = <span class="string">f&quot;<span class="subst">&#123;self.key_prefix&#125;</span>:<span class="subst">&#123;identifier&#125;</span>&quot;</span></span><br><span class="line">        now = time.time()</span><br><span class="line">        </span><br><span class="line">        script = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        local key = KEYS[1]</span></span><br><span class="line"><span class="string">        local window = tonumber(ARGV[1])</span></span><br><span class="line"><span class="string">        local limit = tonumber(ARGV[2])</span></span><br><span class="line"><span class="string">        local now = tonumber(ARGV[3])</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        redis.call(&#x27;ZREMRANGEBYSCORE&#x27;, key, 0, now - window)</span></span><br><span class="line"><span class="string">        local current = redis.call(&#x27;ZCARD&#x27;, key)</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        if current &lt; limit then</span></span><br><span class="line"><span class="string">            redis.call(&#x27;ZADD&#x27;, key, now, now)</span></span><br><span class="line"><span class="string">            redis.call(&#x27;EXPIRE&#x27;, key, window)</span></span><br><span class="line"><span class="string">            return 1</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">        result = self.redis_client.<span class="built_in">eval</span>(script, <span class="number">1</span>, key, window, limit, now)</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">1</span></span><br></pre></td></tr></table></figure><h2><span id="5-会话管理">5. 会话管理</span></h2><h3><span id="用户会话">用户会话</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 存储会话</span></span><br><span class="line">HSET session:abc123 user_id 1001</span><br><span class="line">HSET session:abc123 username <span class="string">&quot;张三&quot;</span></span><br><span class="line">HSET session:abc123 login_time 1640995200</span><br><span class="line">EXPIRE session:abc123 3600</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取会话</span></span><br><span class="line">HGETALL session:abc123</span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SessionManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, session_timeout=<span class="number">3600</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.session_timeout = session_timeout</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_session</span>(<span class="params">self, user_id, user_data</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;创建会话&quot;&quot;&quot;</span></span><br><span class="line">        session_id = <span class="built_in">str</span>(uuid.uuid4())</span><br><span class="line">        session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">        </span><br><span class="line">        session_data = &#123;</span><br><span class="line">            <span class="string">&#x27;user_id&#x27;</span>: user_id,</span><br><span class="line">            <span class="string">&#x27;created_at&#x27;</span>: time.time(),</span><br><span class="line">            **user_data</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        self.redis_client.hmset(session_key, session_data)</span><br><span class="line">        self.redis_client.expire(session_key, self.session_timeout)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> session_id</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_session</span>(<span class="params">self, session_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取会话&quot;&quot;&quot;</span></span><br><span class="line">        session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">        session_data = self.redis_client.hgetall(session_key)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> session_data:</span><br><span class="line">            <span class="comment"># 刷新过期时间</span></span><br><span class="line">            self.redis_client.expire(session_key, self.session_timeout)</span><br><span class="line">            <span class="keyword">return</span> &#123;k.decode(): v.decode() <span class="keyword">for</span> k, v <span class="keyword">in</span> session_data.items()&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">destroy_session</span>(<span class="params">self, session_id</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;销毁会话&quot;&quot;&quot;</span></span><br><span class="line">        session_key = <span class="string">f&quot;session:<span class="subst">&#123;session_id&#125;</span>&quot;</span></span><br><span class="line">        self.redis_client.delete(session_key)</span><br></pre></td></tr></table></figure><h2><span id="6-排行榜">6. 排行榜</span></h2><h3><span id="游戏排行榜">游戏排行榜</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新分数</span></span><br><span class="line">ZADD leaderboard 1000 <span class="string">&quot;player1&quot;</span></span><br><span class="line">ZADD leaderboard 950 <span class="string">&quot;player2&quot;</span></span><br><span class="line">ZADD leaderboard 1100 <span class="string">&quot;player3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取排行榜</span></span><br><span class="line">ZREVRANGE leaderboard 0 9 WITHSCORES</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取玩家排名</span></span><br><span class="line">ZREVRANK leaderboard <span class="string">&quot;player1&quot;</span></span><br><span class="line">ZSCORE leaderboard <span class="string">&quot;player1&quot;</span></span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaderboard</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, leaderboard_name</span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.leaderboard_name = leaderboard_name</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_score</span>(<span class="params">self, player, score</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;更新分数&quot;&quot;&quot;</span></span><br><span class="line">        self.redis_client.zadd(self.leaderboard_name, &#123;player: score&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_top_players</span>(<span class="params">self, limit=<span class="number">10</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取排行榜&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.redis_client.zrevrange(self.leaderboard_name, <span class="number">0</span>, limit-<span class="number">1</span>, withscores=<span class="literal">True</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_player_rank</span>(<span class="params">self, player</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取玩家排名&quot;&quot;&quot;</span></span><br><span class="line">        rank = self.redis_client.zrevrank(self.leaderboard_name, player)</span><br><span class="line">        score = self.redis_client.zscore(self.leaderboard_name, player)</span><br><span class="line">        <span class="keyword">return</span> rank + <span class="number">1</span> <span class="keyword">if</span> rank <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span> <span class="keyword">else</span> <span class="literal">None</span>, score</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_players_around</span>(<span class="params">self, player, range_size=<span class="number">5</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;获取玩家周围的排名&quot;&quot;&quot;</span></span><br><span class="line">        rank = self.redis_client.zrevrank(self.leaderboard_name, player)</span><br><span class="line">        <span class="keyword">if</span> rank <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        </span><br><span class="line">        start = <span class="built_in">max</span>(<span class="number">0</span>, rank - range_size)</span><br><span class="line">        end = rank + range_size</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.redis_client.zrevrange(self.leaderboard_name, start, end, withscores=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h2><span id="7-布隆过滤器">7. 布隆过滤器</span></h2><h3><span id="基本使用">基本使用</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加元素</span></span><br><span class="line">BF.ADD bloom_filter <span class="string">&quot;item1&quot;</span></span><br><span class="line">BF.ADD bloom_filter <span class="string">&quot;item2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查元素</span></span><br><span class="line">BF.EXISTS bloom_filter <span class="string">&quot;item1&quot;</span></span><br><span class="line">BF.EXISTS bloom_filter <span class="string">&quot;item3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量添加</span></span><br><span class="line">BF.MADD bloom_filter <span class="string">&quot;item4&quot;</span> <span class="string">&quot;item5&quot;</span> <span class="string">&quot;item6&quot;</span></span><br></pre></td></tr></table></figure><h3><span id="实现示例">实现示例</span></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BloomFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, redis_client, key, capacity=<span class="number">10000</span>, error_rate=<span class="number">0.01</span></span>):</span><br><span class="line">        self.redis_client = redis_client</span><br><span class="line">        self.key = key</span><br><span class="line">        self.capacity = capacity</span><br><span class="line">        self.error_rate = error_rate</span><br><span class="line">        self.bit_array_size = self._calculate_bit_array_size()</span><br><span class="line">        self.hash_functions = self._calculate_hash_functions()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calculate_bit_array_size</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算位数组大小&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(-(self.capacity * math.log(self.error_rate)) / (math.log(<span class="number">2</span>) ** <span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_calculate_hash_functions</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;计算哈希函数数量&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">import</span> math</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>((self.bit_array_size / self.capacity) * math.log(<span class="number">2</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_hash</span>(<span class="params">self, item, seed</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;哈希函数&quot;&quot;&quot;</span></span><br><span class="line">        hash_obj = hashlib.md5()</span><br><span class="line">        hash_obj.update(<span class="string">f&quot;<span class="subst">&#123;item&#125;</span><span class="subst">&#123;seed&#125;</span>&quot;</span>.encode())</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(hash_obj.hexdigest(), <span class="number">16</span>) % self.bit_array_size</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;添加元素&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_functions):</span><br><span class="line">            bit_index = self._<span class="built_in">hash</span>(item, i)</span><br><span class="line">            self.redis_client.setbit(self.key, bit_index, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">exists</span>(<span class="params">self, item</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;检查元素是否存在&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.hash_functions):</span><br><span class="line">            bit_index = self._<span class="built_in">hash</span>(item, i)</span><br><span class="line">            <span class="keyword">if</span> self.redis_client.getbit(self.key, bit_index) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2><span id="8-最佳实践">8. 最佳实践</span></h2><h3><span id="1-性能优化">1. 性能优化</span></h3><ul><li>使用Pipeline减少网络往返</li><li>合理设置过期时间</li><li>使用合适的数据类型</li><li>避免大key</li></ul><h3><span id="2-内存优化">2. 内存优化</span></h3><ul><li>定期清理过期数据</li><li>使用压缩</li><li>监控内存使用</li><li>设置合理的淘汰策略</li></ul><h3><span id="3-高可用">3. 高可用</span></h3><ul><li>使用主从复制</li><li>配置哨兵模式</li><li>定期备份数据</li><li>监控系统状态</li></ul><h3><span id="4-安全配置">4. 安全配置</span></h3><ul><li>设置密码</li><li>限制网络访问</li><li>禁用危险命令</li><li>定期更新版本</li></ul><h2><span id="总结">总结</span></h2><p>Redis在实际项目中有广泛的应用，从简单的缓存到复杂的分布式系统都能发挥重要作用。掌握这些实战应用模式，可以大大提高开发效率和系统性能。在实际使用中，需要根据具体业务场景选择合适的应用模式，并注意性能优化和安全性。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.md">Redis高级特性</a><br><strong>系列总结</strong>：Redis技术文档整理完成</p>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 缓存 </tag>
            
            <tag> 实战应用 </tag>
            
            <tag> 分布式锁 </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis高级特性</title>
      <link href="/blog/2025/10/15/tech/backend/database/redis/Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/blog/2025/10/15/tech/backend/database/redis/Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis高级特性">Redis高级特性</span></h1><p>Redis不仅是一个简单的键值存储，还提供了许多高级特性，包括事务、发布订阅、管道、Lua脚本等。这些特性使得Redis能够处理更复杂的应用场景。</p><h2><span id="1-事务transaction">1. 事务（Transaction）</span></h2><p>Redis事务是一组命令的集合，这些命令要么全部执行，要么全部不执行。</p><h3><span id="事务特性">事务特性</span></h3><ul><li><strong>原子性</strong>：事务中的所有命令要么全部执行，要么全部不执行</li><li><strong>隔离性</strong>：事务在执行过程中不会被其他客户端打断</li><li><strong>一致性</strong>：事务执行前后数据库状态保持一致</li><li><strong>不支持回滚</strong>：Redis事务不支持回滚操作</li></ul><h3><span id="事务命令">事务命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开始事务</span></span><br><span class="line">MULTI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行命令（命令会进入队列）</span></span><br><span class="line">SET key1 <span class="string">&quot;value1&quot;</span></span><br><span class="line">SET key2 <span class="string">&quot;value2&quot;</span></span><br><span class="line">INCR counter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行事务</span></span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消事务</span></span><br><span class="line">DISCARD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监视键</span></span><br><span class="line">WATCH key1 key2</span><br></pre></td></tr></table></figure><h3><span id="事务示例">事务示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本事务</span></span><br><span class="line">MULTI</span><br><span class="line">SET user:1001:name <span class="string">&quot;张三&quot;</span></span><br><span class="line">SET user:1001:age 25</span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带监视的事务</span></span><br><span class="line">WATCH user:1001:balance</span><br><span class="line">MULTI</span><br><span class="line">DECRBY user:1001:balance 100</span><br><span class="line">INCRBY user:1002:balance 100</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure><h3><span id="事务注意事项">事务注意事项</span></h3><ol><li><strong>命令错误</strong>：语法错误会导致整个事务失败</li><li><strong>运行时错误</strong>：运行时错误不会影响其他命令执行</li><li><strong>WATCH机制</strong>：被监视的键被修改时，事务会失败</li></ol><h2><span id="2-发布订阅pubx2fsub">2. 发布订阅（Pub&#x2F;Sub）</span></h2><p>Redis发布订阅是一种消息通信模式，发布者发送消息，订阅者接收消息。</p><h3><span id="基本概念">基本概念</span></h3><ul><li><strong>发布者（Publisher）</strong>：发送消息的客户端</li><li><strong>订阅者（Subscriber）</strong>：接收消息的客户端</li><li><strong>频道（Channel）</strong>：消息传递的通道</li></ul><h3><span id="发布订阅命令">发布订阅命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布消息</span></span><br><span class="line">PUBLISH channel message</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅频道</span></span><br><span class="line">SUBSCRIBE channel1 channel2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消订阅</span></span><br><span class="line">UNSUBSCRIBE channel1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模式订阅</span></span><br><span class="line">PSUBSCRIBE news.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消模式订阅</span></span><br><span class="line">PUNSUBSCRIBE news.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看活跃频道</span></span><br><span class="line">PUBSUB CHANNELS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看频道订阅数</span></span><br><span class="line">PUBSUB NUMSUB channel1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看模式订阅数</span></span><br><span class="line">PUBSUB NUMPAT</span><br></pre></td></tr></table></figure><h3><span id="发布订阅示例">发布订阅示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发布者</span></span><br><span class="line">PUBLISH news:sports <span class="string">&quot;足球比赛结果&quot;</span></span><br><span class="line">PUBLISH news:tech <span class="string">&quot;新技术发布&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者1</span></span><br><span class="line">SUBSCRIBE news:sports</span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅者2</span></span><br><span class="line">PSUBSCRIBE news:*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看活跃频道</span></span><br><span class="line">PUBSUB CHANNELS news:*</span><br></pre></td></tr></table></figure><h3><span id="发布订阅特点">发布订阅特点</span></h3><ul><li><strong>无持久化</strong>：消息不会持久化存储</li><li><strong>无确认机制</strong>：订阅者可能丢失消息</li><li><strong>实时性</strong>：消息实时传递</li><li><strong>一对多</strong>：一个发布者可以对应多个订阅者</li></ul><h2><span id="3-管道pipeline">3. 管道（Pipeline）</span></h2><p>Pipeline允许客户端一次性发送多个命令，减少网络往返次数，提高性能。</p><h3><span id="pipeline原理">Pipeline原理</span></h3><ol><li><strong>批量发送</strong>：将多个命令打包发送</li><li><strong>批量接收</strong>：一次性接收所有响应</li><li><strong>减少延迟</strong>：减少网络往返时间</li></ol><h3><span id="pipeline示例">Pipeline示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 不使用Pipeline</span></span><br><span class="line">SET key1 <span class="string">&quot;value1&quot;</span></span><br><span class="line">GET key1</span><br><span class="line">SET key2 <span class="string">&quot;value2&quot;</span></span><br><span class="line">GET key2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Pipeline（伪代码）</span></span><br><span class="line">pipeline = redis.pipeline()</span><br><span class="line">pipeline.set(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>)</span><br><span class="line">pipeline.get(<span class="string">&quot;key1&quot;</span>)</span><br><span class="line">pipeline.set(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>)</span><br><span class="line">pipeline.get(<span class="string">&quot;key2&quot;</span>)</span><br><span class="line">results = pipeline.execute()</span><br></pre></td></tr></table></figure><h3><span id="pipeline性能测试">Pipeline性能测试</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试脚本</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Pipeline测试</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -P 16 -q</span><br></pre></td></tr></table></figure><h3><span id="pipeline注意事项">Pipeline注意事项</span></h3><ul><li><strong>原子性</strong>：Pipeline中的命令不是原子性的</li><li><strong>错误处理</strong>：需要检查每个命令的执行结果</li><li><strong>内存使用</strong>：大量命令可能占用较多内存</li></ul><h2><span id="4-lua脚本">4. Lua脚本</span></h2><p>Redis支持Lua脚本，可以在服务器端执行复杂的逻辑。</p><h3><span id="lua脚本优势">Lua脚本优势</span></h3><ul><li><strong>原子性</strong>：脚本执行是原子性的</li><li><strong>减少网络开销</strong>：复杂逻辑在服务器端执行</li><li><strong>高性能</strong>：避免多次网络往返</li></ul><h3><span id="lua脚本命令">Lua脚本命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 执行Lua脚本</span></span><br><span class="line">EVAL script numkeys key [key ...] arg [arg ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行缓存的脚本</span></span><br><span class="line">EVALSHA sha1 numkeys key [key ...] arg [arg ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存脚本</span></span><br><span class="line">SCRIPT LOAD script</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查脚本是否存在</span></span><br><span class="line">SCRIPT EXISTS sha1 [sha1 ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 杀死正在执行的脚本</span></span><br><span class="line">SCRIPT KILL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新脚本缓存</span></span><br><span class="line">SCRIPT FLUSH</span><br></pre></td></tr></table></figure><h3><span id="lua脚本示例">Lua脚本示例</span></h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 限流脚本</span></span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> expire = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> current = redis.call(<span class="string">&#x27;GET&#x27;</span>, key)</span><br><span class="line"><span class="keyword">if</span> current == <span class="literal">false</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;SET&#x27;</span>, key, <span class="number">1</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, key, expire)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    current = <span class="built_in">tonumber</span>(current)</span><br><span class="line">    <span class="keyword">if</span> current &lt; limit <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;INCR&#x27;</span>, key)</span><br><span class="line">        <span class="keyword">return</span> current + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3><span id="执行lua脚本">执行Lua脚本</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接执行</span></span><br><span class="line">EVAL <span class="string">&quot;return redis.call(&#x27;GET&#x27;, KEYS[1])&quot;</span> 1 mykey</span><br><span class="line"></span><br><span class="line"><span class="comment"># 缓存后执行</span></span><br><span class="line">SCRIPT LOAD <span class="string">&quot;return redis.call(&#x27;GET&#x27;, KEYS[1])&quot;</span></span><br><span class="line">EVALSHA &lt;sha1&gt; 1 mykey</span><br></pre></td></tr></table></figure><h2><span id="5-慢查询日志">5. 慢查询日志</span></h2><p>Redis慢查询日志记录执行时间超过指定阈值的命令。</p><h3><span id="慢查询配置">慢查询配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 设置慢查询阈值（微秒）</span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"># 设置慢查询日志最大长度</span><br><span class="line">slowlog-max-len 128</span><br></pre></td></tr></table></figure><h3><span id="慢查询命令">慢查询命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看慢查询日志</span></span><br><span class="line">SLOWLOG GET 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取慢查询日志长度</span></span><br><span class="line">SLOWLOG LEN</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清空慢查询日志</span></span><br><span class="line">SLOWLOG RESET</span><br></pre></td></tr></table></figure><h3><span id="慢查询分析">慢查询分析</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看慢查询日志</span></span><br><span class="line">SLOWLOG GET 5</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 14</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1309448221</span><br><span class="line">   3) (<span class="built_in">integer</span>) 15</span><br><span class="line">   4) 1) <span class="string">&quot;ping&quot;</span></span><br><span class="line">2) 1) (<span class="built_in">integer</span>) 13</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1309448128</span><br><span class="line">   3) (<span class="built_in">integer</span>) 30</span><br><span class="line">   4) 1) <span class="string">&quot;slowlog&quot;</span></span><br><span class="line">      2) <span class="string">&quot;get&quot;</span></span><br><span class="line">      3) <span class="string">&quot;100&quot;</span></span><br></pre></td></tr></table></figure><h2><span id="6-内存优化">6. 内存优化</span></h2><h3><span id="内存使用分析">内存使用分析</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看内存使用情况</span></span><br><span class="line">INFO memory</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存使用详情</span></span><br><span class="line">MEMORY USAGE key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存统计</span></span><br><span class="line">MEMORY STATS</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存医生</span></span><br><span class="line">MEMORY DOCTOR</span><br></pre></td></tr></table></figure><h3><span id="内存优化策略">内存优化策略</span></h3><ol><li><strong>选择合适的数据类型</strong></li><li><strong>使用过期时间</strong></li><li><strong>定期清理无用数据</strong></li><li><strong>使用压缩</strong></li></ol><h3><span id="内存优化示例">内存优化示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置过期时间</span></span><br><span class="line">EXPIRE key 3600</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Hash存储对象</span></span><br><span class="line">HSET user:1001 name <span class="string">&quot;张三&quot;</span> age 25</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用BitMap存储状态</span></span><br><span class="line">SETBIT user:1001:online 0 1</span><br></pre></td></tr></table></figure><h2><span id="7-性能监控">7. 性能监控</span></h2><h3><span id="监控命令">监控命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看Redis信息</span></span><br><span class="line">INFO</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看统计信息</span></span><br><span class="line">INFO stats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看客户端信息</span></span><br><span class="line">INFO clients</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看CPU信息</span></span><br><span class="line">INFO cpu</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看复制信息</span></span><br><span class="line">INFO replication</span><br></pre></td></tr></table></figure><h3><span id="性能指标">性能指标</span></h3><ul><li><strong>QPS</strong>：每秒查询数</li><li><strong>延迟</strong>：命令执行时间</li><li><strong>内存使用率</strong>：内存占用情况</li><li><strong>连接数</strong>：客户端连接数</li></ul><h3><span id="性能测试">性能测试</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本性能测试</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定客户端数</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -c 50 -q</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定Pipeline</span></span><br><span class="line">redis-benchmark -t <span class="built_in">set</span>,get -n 100000 -P 16 -q</span><br></pre></td></tr></table></figure><h2><span id="8-安全配置">8. 安全配置</span></h2><h3><span id="基本安全">基本安全</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 设置密码</span><br><span class="line">requirepass yourpassword</span><br><span class="line"></span><br><span class="line"># 绑定IP</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 禁用危险命令</span><br><span class="line">rename-command FLUSHDB &quot;&quot;</span><br><span class="line">rename-command FLUSHALL &quot;&quot;</span><br><span class="line">rename-command KEYS &quot;&quot;</span><br><span class="line"></span><br><span class="line"># 设置最大内存</span><br><span class="line">maxmemory 2gb</span><br><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure><h3><span id="网络安全">网络安全</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 禁用外部访问</span><br><span class="line">bind 127.0.0.1</span><br><span class="line"></span><br><span class="line"># 设置超时</span><br><span class="line">timeout 300</span><br><span class="line"></span><br><span class="line"># 启用保护模式</span><br><span class="line">protected-mode yes</span><br></pre></td></tr></table></figure><h2><span id="9-最佳实践">9. 最佳实践</span></h2><h3><span id="1-性能优化">1. 性能优化</span></h3><ul><li>使用Pipeline减少网络往返</li><li>合理使用Lua脚本</li><li>监控慢查询日志</li><li>优化内存使用</li></ul><h3><span id="2-安全配置">2. 安全配置</span></h3><ul><li>设置强密码</li><li>限制网络访问</li><li>禁用危险命令</li><li>定期更新Redis版本</li></ul><h3><span id="3-监控告警">3. 监控告警</span></h3><ul><li>监控关键指标</li><li>设置告警阈值</li><li>定期检查日志</li><li>性能测试</li></ul><h2><span id="总结">总结</span></h2><p>Redis的高级特性为复杂应用场景提供了强大的支持。事务保证了数据一致性，发布订阅实现了消息通信，Pipeline提高了性能，Lua脚本提供了服务器端逻辑处理能力。合理使用这些特性可以大大提高Redis的应用价值。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6.md">Redis持久化机制</a><br><strong>下一篇</strong>：<a href="./Redis-05-%E5%AE%9E%E6%88%98%E5%BA%94%E7%94%A8.md">Redis实战应用</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 高级特性 </tag>
            
            <tag> 事务 </tag>
            
            <tag> 发布订阅 </tag>
            
            <tag> 管道 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化机制</title>
      <link href="/blog/2025/10/15/tech/backend/database/redis/Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
      <url>/blog/2025/10/15/tech/backend/database/redis/Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis持久化机制">Redis持久化机制</span></h1><p>Redis是内存数据库，数据存储在内存中，但Redis提供了持久化机制来保证数据的可靠性。Redis支持两种持久化方式：RDB（Redis Database）和AOF（Append Only File）。</p><h2><span id="1-rdb持久化">1. RDB持久化</span></h2><p>RDB是Redis的默认持久化方式，通过创建数据快照来保存数据。</p><h3><span id="rdb工作原理">RDB工作原理</span></h3><ol><li><strong>fork子进程</strong>：Redis主进程fork一个子进程</li><li><strong>数据快照</strong>：子进程将内存中的数据写入RDB文件</li><li><strong>替换文件</strong>：用新的RDB文件替换旧的RDB文件</li></ol><h3><span id="rdb配置">RDB配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># redis.conf配置</span><br><span class="line">save 900 1      # 900秒内至少1个key发生变化</span><br><span class="line">save 300 10     # 300秒内至少10个key发生变化</span><br><span class="line">save 60 10000   # 60秒内至少10000个key发生变化</span><br><span class="line"></span><br><span class="line"># 禁用RDB</span><br><span class="line">save &quot;&quot;</span><br><span class="line"></span><br><span class="line"># RDB文件位置</span><br><span class="line">dir /var/lib/redis</span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"># 压缩RDB文件</span><br><span class="line">rdbcompression yes</span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><h3><span id="rdb命令">RDB命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动保存</span></span><br><span class="line">SAVE          <span class="comment"># 同步保存，阻塞主进程</span></span><br><span class="line">BGSAVE        <span class="comment"># 异步保存，不阻塞主进程</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最后保存时间</span></span><br><span class="line">LASTSAVE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查RDB文件</span></span><br><span class="line">redis-check-rdb dump.rdb</span><br></pre></td></tr></table></figure><h3><span id="rdb优缺点">RDB优缺点</span></h3><p><strong>优点：</strong></p><ul><li>文件紧凑，适合备份和灾难恢复</li><li>恢复大数据集时速度很快</li><li>对Redis性能影响最小</li><li>适合大规模数据迁移</li></ul><p><strong>缺点：</strong></p><ul><li>可能丢失最后一次快照后的数据</li><li>数据量大时fork过程耗时较长</li><li>不适合对数据完整性要求很高的场景</li></ul><h2><span id="2-aof持久化">2. AOF持久化</span></h2><p>AOF通过记录每个写操作来持久化数据，类似于数据库的binlog。</p><h3><span id="aof工作原理">AOF工作原理</span></h3><ol><li><strong>记录命令</strong>：将每个写命令追加到AOF文件</li><li><strong>文件重写</strong>：定期重写AOF文件，去除冗余命令</li><li><strong>恢复数据</strong>：重启时重放AOF文件中的命令</li></ol><h3><span id="aof配置">AOF配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 启用AOF</span><br><span class="line">appendonly yes</span><br><span class="line">appendfilename &quot;appendonly.aof&quot;</span><br><span class="line"></span><br><span class="line"># AOF同步策略</span><br><span class="line">appendfsync always     # 每个写命令都同步</span><br><span class="line">appendfsync everysec   # 每秒同步一次（推荐）</span><br><span class="line">appendfsync no         # 由操作系统决定何时同步</span><br><span class="line"></span><br><span class="line"># AOF重写配置</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"># 混合持久化（Redis 4.0+）</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h3><span id="aof命令">AOF命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 手动重写AOF</span></span><br><span class="line">BGREWRITEAOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看AOF文件</span></span><br><span class="line">redis-check-aof appendonly.aof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看AOF状态</span></span><br><span class="line">INFO persistence</span><br></pre></td></tr></table></figure><h3><span id="aof优缺点">AOF优缺点</span></h3><p><strong>优点：</strong></p><ul><li>数据完整性高，最多丢失1秒数据</li><li>AOF文件可读性好，便于分析</li><li>支持混合持久化，兼顾性能和完整性</li></ul><p><strong>缺点：</strong></p><ul><li>文件体积较大</li><li>恢复速度比RDB慢</li><li>对性能有一定影响</li></ul><h2><span id="3-混合持久化redis-40">3. 混合持久化（Redis 4.0+）</span></h2><p>混合持久化结合了RDB和AOF的优点，在AOF重写时使用RDB格式。</p><h3><span id="工作原理">工作原理</span></h3><ol><li><strong>AOF重写时</strong>：先生成RDB快照</li><li><strong>追加增量</strong>：将重写期间的增量命令追加到RDB后</li><li><strong>文件格式</strong>：RDB数据 + AOF增量命令</li></ol><h3><span id="配置">配置</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启用混合持久化</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h2><span id="4-持久化策略选择">4. 持久化策略选择</span></h2><h3><span id="场景1缓存系统">场景1：缓存系统</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 只使用RDB</span><br><span class="line">save 900 1</span><br><span class="line">appendonly no</span><br></pre></td></tr></table></figure><h3><span id="场景2数据存储">场景2：数据存储</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 使用AOF</span><br><span class="line">save &quot;&quot;</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure><h3><span id="场景3高可用系统">场景3：高可用系统</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 混合持久化</span><br><span class="line">save 900 1</span><br><span class="line">appendonly yes</span><br><span class="line">appendfsync everysec</span><br><span class="line">aof-use-rdb-preamble yes</span><br></pre></td></tr></table></figure><h2><span id="5-持久化监控">5. 持久化监控</span></h2><h3><span id="监控命令">监控命令</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看持久化信息</span></span><br><span class="line">INFO persistence</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看最后保存时间</span></span><br><span class="line">LASTSAVE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看AOF文件大小</span></span><br><span class="line">INFO memory</span><br></pre></td></tr></table></figure><h3><span id="监控指标">监控指标</span></h3><ul><li><strong>RDB相关</strong>：last_save_time、rdb_last_bgsave_status</li><li><strong>AOF相关</strong>：aof_enabled、aof_last_rewrite_time_sec</li><li><strong>内存相关</strong>：used_memory、used_memory_peak</li></ul><h2><span id="6-备份与恢复">6. 备份与恢复</span></h2><h3><span id="备份策略">备份策略</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 自动备份脚本</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">BACKUP_DIR=<span class="string">&quot;/backup/redis&quot;</span></span><br><span class="line">DATE=$(<span class="built_in">date</span> +%Y%m%d_%H%M%S)</span><br><span class="line">redis-cli BGSAVE</span><br><span class="line"><span class="built_in">cp</span> /var/lib/redis/dump.rdb <span class="variable">$BACKUP_DIR</span>/dump_<span class="variable">$DATE</span>.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定期清理旧备份</span></span><br><span class="line">find <span class="variable">$BACKUP_DIR</span> -name <span class="string">&quot;dump_*.rdb&quot;</span> -mtime +7 -delete</span><br></pre></td></tr></table></figure><h3><span id="恢复数据">恢复数据</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 停止Redis服务</span></span><br><span class="line">systemctl stop redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 备份当前数据</span></span><br><span class="line"><span class="built_in">cp</span> /var/lib/redis/dump.rdb /var/lib/redis/dump.rdb.backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 恢复RDB文件</span></span><br><span class="line"><span class="built_in">cp</span> /backup/redis/dump_20231015_120000.rdb /var/lib/redis/dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 启动Redis服务</span></span><br><span class="line">systemctl start redis</span><br></pre></td></tr></table></figure><h2><span id="7-性能优化">7. 性能优化</span></h2><h3><span id="rdb优化">RDB优化</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 调整保存频率</span><br><span class="line">save 300 10    # 减少保存频率</span><br><span class="line"></span><br><span class="line"># 优化fork性能</span><br><span class="line">tcp-backlog 511</span><br><span class="line">timeout 0</span><br><span class="line">tcp-keepalive 300</span><br></pre></td></tr></table></figure><h3><span id="aof优化">AOF优化</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 调整同步策略</span><br><span class="line">appendfsync everysec  # 平衡性能和安全性</span><br><span class="line"></span><br><span class="line"># 优化重写</span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h2><span id="8-故障处理">8. 故障处理</span></h2><h3><span id="常见问题">常见问题</span></h3><ol><li><p><strong>RDB文件损坏</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查文件完整性</span></span><br><span class="line">redis-check-rdb dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从备份恢复</span></span><br><span class="line"><span class="built_in">cp</span> backup/dump.rdb /var/lib/redis/</span><br></pre></td></tr></table></figure></li><li><p><strong>AOF文件损坏</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查AOF文件</span></span><br><span class="line">redis-check-aof appendonly.aof</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修复AOF文件</span></span><br><span class="line">redis-check-aof --fix appendonly.aof</span><br></pre></td></tr></table></figure></li><li><p><strong>持久化失败</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查磁盘空间</span></span><br><span class="line"><span class="built_in">df</span> -h</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查权限</span></span><br><span class="line"><span class="built_in">ls</span> -la /var/lib/redis/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看日志</span></span><br><span class="line"><span class="built_in">tail</span> -f /var/log/redis/redis-server.log</span><br></pre></td></tr></table></figure></li></ol><h2><span id="9-最佳实践">9. 最佳实践</span></h2><h3><span id="1-配置建议">1. 配置建议</span></h3><ul><li>生产环境建议使用混合持久化</li><li>根据业务需求调整保存频率</li><li>定期监控持久化状态</li></ul><h3><span id="2-备份策略">2. 备份策略</span></h3><ul><li>定期备份RDB和AOF文件</li><li>异地备份重要数据</li><li>测试恢复流程</li></ul><h3><span id="3-监控告警">3. 监控告警</span></h3><ul><li>监控持久化状态</li><li>设置磁盘空间告警</li><li>监控持久化性能</li></ul><h2><span id="总结">总结</span></h2><p>Redis的持久化机制是保证数据可靠性的重要手段。RDB适合备份和快速恢复，AOF适合数据完整性要求高的场景，混合持久化则兼顾了两者的优点。在实际应用中，需要根据业务需求选择合适的持久化策略。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3.md">Redis数据结构详解</a><br><strong>下一篇</strong>：<a href="./Redis-04-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.md">Redis高级特性</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 持久化 </tag>
            
            <tag> RDB </tag>
            
            <tag> AOF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis数据结构详解</title>
      <link href="/blog/2025/10/15/tech/backend/database/redis/Redis-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2025/10/15/tech/backend/database/redis/Redis-02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis数据结构详解">Redis数据结构详解</span></h1><p>Redis支持五种基本数据类型：String、Hash、List、Set、Sorted Set。每种类型都有特定的使用场景。</p><h2><span id="1-string字符串">1. String（字符串）</span></h2><p>String是Redis最基本的数据类型，可以存储字符串、整数或浮点数。</p><p>基本操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SET key value           <span class="comment"># 设置和获取</span></span><br><span class="line">GET key</span><br><span class="line">MSET key1 value1 key2 value2  <span class="comment"># 批量操作</span></span><br><span class="line">MGET key1 key2</span><br><span class="line">INCR key               <span class="comment"># 数值操作</span></span><br><span class="line">DECR key</span><br><span class="line">INCRBY key 5</span><br><span class="line">APPEND key <span class="string">&quot;suffix&quot;</span>    <span class="comment"># 字符串操作</span></span><br><span class="line">STRLEN key</span><br></pre></td></tr></table></figure><p>使用场景：</p><ul><li>缓存：存储用户信息、商品信息</li><li>计数器：网站访问量、点赞数</li><li>分布式锁：使用SETNX实现</li><li>会话存储：存储用户登录状态</li></ul><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET user:1001 <span class="string">&#x27;&#123;&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:25&#125;&#x27;</span>  <span class="comment"># 用户信息缓存</span></span><br><span class="line">INCR page:views:article:123               <span class="comment"># 访问计数器</span></span><br><span class="line">SETNX lock:order:123 <span class="string">&quot;locked&quot;</span>             <span class="comment"># 分布式锁</span></span><br></pre></td></tr></table></figure><h2><span id="2-hash哈希">2. Hash（哈希）</span></h2><p>Hash是一个键值对集合，适合存储对象。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置和获取</span></span><br><span class="line">HSET <span class="built_in">hash</span> field value</span><br><span class="line">HGET <span class="built_in">hash</span> field</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line">HMSET <span class="built_in">hash</span> field1 value1 field2 value2</span><br><span class="line">HMGET <span class="built_in">hash</span> field1 field2</span><br><span class="line">HGETALL <span class="built_in">hash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line">HDEL <span class="built_in">hash</span> field        <span class="comment"># 删除字段</span></span><br><span class="line">HEXISTS <span class="built_in">hash</span> field     <span class="comment"># 检查字段是否存在</span></span><br><span class="line">HKEYS <span class="built_in">hash</span>             <span class="comment"># 获取所有字段名</span></span><br><span class="line">HVALS <span class="built_in">hash</span>             <span class="comment"># 获取所有字段值</span></span><br><span class="line">HLEN <span class="built_in">hash</span>              <span class="comment"># 获取字段数量</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>对象存储</strong>：用户信息、商品详情等</li><li><strong>配置管理</strong>：系统配置参数</li><li><strong>购物车</strong>：用户购物车商品</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户信息存储</span></span><br><span class="line">HSET user:1001 name <span class="string">&quot;张三&quot;</span></span><br><span class="line">HSET user:1001 age 25</span><br><span class="line">HSET user:1001 email <span class="string">&quot;zhangsan@example.com&quot;</span></span><br><span class="line">HGETALL user:1001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 购物车</span></span><br><span class="line">HSET cart:1001 product:001 2</span><br><span class="line">HSET cart:1001 product:002 1</span><br><span class="line">HGETALL cart:1001</span><br></pre></td></tr></table></figure><h2><span id="3-list列表">3. List（列表）</span></h2><p>List是一个双向链表，支持从两端进行插入和删除操作。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 左侧操作</span></span><br><span class="line">LPUSH list item1 item2    <span class="comment"># 左侧插入</span></span><br><span class="line">LPOP list                 <span class="comment"># 左侧弹出</span></span><br><span class="line">LINDEX list 0             <span class="comment"># 获取指定位置元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右侧操作</span></span><br><span class="line">RPUSH list item3 item4    <span class="comment"># 右侧插入</span></span><br><span class="line">RPOP list                 <span class="comment"># 右侧弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他操作</span></span><br><span class="line">LLEN list                 <span class="comment"># 获取列表长度</span></span><br><span class="line">LRANGE list 0 -1          <span class="comment"># 获取指定范围元素</span></span><br><span class="line">LREM list 2 <span class="string">&quot;item&quot;</span>        <span class="comment"># 删除指定元素</span></span><br><span class="line">LTRIM list 0 4            <span class="comment"># 截取列表</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>消息队列</strong>：FIFO队列</li><li><strong>最新列表</strong>：最新文章、最新评论</li><li><strong>栈结构</strong>：LIFO操作</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 消息队列</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email1&quot;</span></span><br><span class="line">LPUSH queue:email <span class="string">&quot;email2&quot;</span></span><br><span class="line">RPOP queue:email</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最新文章列表</span></span><br><span class="line">LPUSH articles:latest <span class="string">&quot;article:001&quot;</span></span><br><span class="line">LPUSH articles:latest <span class="string">&quot;article:002&quot;</span></span><br><span class="line">LRANGE articles:latest 0 9  <span class="comment"># 获取最新10篇文章</span></span><br></pre></td></tr></table></figure><h2><span id="4-set集合">4. Set（集合）</span></h2><p>Set是一个无序的、不重复的元素集合。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line">SADD <span class="built_in">set</span> member1 member2    <span class="comment"># 添加成员</span></span><br><span class="line">SREM <span class="built_in">set</span> member1            <span class="comment"># 删除成员</span></span><br><span class="line">SMEMBERS <span class="built_in">set</span>                <span class="comment"># 获取所有成员</span></span><br><span class="line">SISMEMBER <span class="built_in">set</span> member1       <span class="comment"># 检查成员是否存在</span></span><br><span class="line">SCARD <span class="built_in">set</span>                   <span class="comment"># 获取成员数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合运算</span></span><br><span class="line">SUNION set1 set2            <span class="comment"># 并集</span></span><br><span class="line">SINTER set1 set2            <span class="comment"># 交集</span></span><br><span class="line">SDIFF set1 set2             <span class="comment"># 差集</span></span><br><span class="line">SUNIONSTORE result set1 set2 <span class="comment"># 并集存储到新集合</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>标签系统</strong>：文章标签、用户兴趣</li><li><strong>好友关系</strong>：共同好友、推荐好友</li><li><strong>去重</strong>：IP黑名单、用户ID去重</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文章标签</span></span><br><span class="line">SADD article:001:tags <span class="string">&quot;技术&quot;</span> <span class="string">&quot;Redis&quot;</span> <span class="string">&quot;数据库&quot;</span></span><br><span class="line">SADD article:002:tags <span class="string">&quot;技术&quot;</span> <span class="string">&quot;MySQL&quot;</span> <span class="string">&quot;数据库&quot;</span></span><br><span class="line">SINTER article:001:tags article:002:tags  <span class="comment"># 共同标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户关注</span></span><br><span class="line">SADD user:1001:following 1002 1003</span><br><span class="line">SADD user:1002:following 1001 1003</span><br><span class="line">SINTER user:1001:following user:1002:following  <span class="comment"># 共同关注</span></span><br></pre></td></tr></table></figure><h2><span id="5-sorted-set有序集合">5. Sorted Set（有序集合）</span></h2><p>Sorted Set是有序的、不重复的元素集合，每个元素都有一个分数（score）。</p><h3><span id="基本操作">基本操作</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本操作</span></span><br><span class="line">ZADD zset score1 member1 score2 member2  <span class="comment"># 添加成员</span></span><br><span class="line">ZREM zset member1                        <span class="comment"># 删除成员</span></span><br><span class="line">ZSCORE zset member1                      <span class="comment"># 获取成员分数</span></span><br><span class="line">ZRANK zset member1                       <span class="comment"># 获取成员排名</span></span><br><span class="line">ZCARD zset                               <span class="comment"># 获取成员数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 范围操作</span></span><br><span class="line">ZRANGE zset 0 -1                         <span class="comment"># 按排名获取成员</span></span><br><span class="line">ZRANGEBYSCORE zset 80 100                <span class="comment"># 按分数获取成员</span></span><br><span class="line">ZREVRANGE zset 0 9                       <span class="comment"># 倒序获取前10名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分数操作</span></span><br><span class="line">ZINCRBY zset 5 member1                   <span class="comment"># 增加分数</span></span><br><span class="line">ZCOUNT zset 80 100                       <span class="comment"># 统计分数范围内的成员数</span></span><br></pre></td></tr></table></figure><h3><span id="使用场景">使用场景</span></h3><ul><li><strong>排行榜</strong>：游戏积分、文章热度</li><li><strong>延时队列</strong>：任务调度</li><li><strong>范围查询</strong>：按分数范围查询</li></ul><h3><span id="示例">示例</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 游戏排行榜</span></span><br><span class="line">ZADD leaderboard 1000 <span class="string">&quot;player1&quot;</span></span><br><span class="line">ZADD leaderboard 950 <span class="string">&quot;player2&quot;</span></span><br><span class="line">ZADD leaderboard 1100 <span class="string">&quot;player3&quot;</span></span><br><span class="line">ZREVRANGE leaderboard 0 9  <span class="comment"># 获取前10名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 延时队列</span></span><br><span class="line">ZADD delay_queue 1640995200 <span class="string">&quot;task1&quot;</span>  <span class="comment"># 2022-01-01执行</span></span><br><span class="line">ZADD delay_queue 1640995260 <span class="string">&quot;task2&quot;</span>  <span class="comment"># 2022-01-01 01:01执行</span></span><br><span class="line">ZRANGEBYSCORE delay_queue 0 1640995200  <span class="comment"># 获取到期的任务</span></span><br></pre></td></tr></table></figure><h2><span id="6-其他数据类型">6. 其他数据类型</span></h2><h3><span id="bitmap位图">Bitmap（位图）</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 位操作</span></span><br><span class="line">SETBIT bitmap 0 1        <span class="comment"># 设置第0位为1</span></span><br><span class="line">GETBIT bitmap 0          <span class="comment"># 获取第0位的值</span></span><br><span class="line">BITCOUNT bitmap          <span class="comment"># 统计1的个数</span></span><br><span class="line">BITOP AND result bitmap1 bitmap2  <span class="comment"># 位运算</span></span><br></pre></td></tr></table></figure><h3><span id="hyperloglog">HyperLogLog</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基数统计</span></span><br><span class="line">PFADD hll element1 element2  <span class="comment"># 添加元素</span></span><br><span class="line">PFCOUNT hll                  <span class="comment"># 统计基数</span></span><br><span class="line">PFMERGE result hll1 hll2     <span class="comment"># 合并多个HyperLogLog</span></span><br></pre></td></tr></table></figure><h3><span id="geo地理位置">Geo（地理位置）</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 地理位置操作</span></span><br><span class="line">GEOADD locations 116.397 39.916 <span class="string">&quot;北京&quot;</span></span><br><span class="line">GEODIST locations <span class="string">&quot;北京&quot;</span> <span class="string">&quot;上海&quot;</span> km</span><br><span class="line">GEORADIUS locations 116.397 39.916 100 km</span><br></pre></td></tr></table></figure><h2><span id="数据类型选择指南">数据类型选择指南</span></h2><table><thead><tr><th>数据类型</th><th>使用场景</th><th>优势</th><th>注意事项</th></tr></thead><tbody><tr><td>String</td><td>缓存、计数器</td><td>简单高效</td><td>内存占用较大</td></tr><tr><td>Hash</td><td>对象存储</td><td>结构化存储</td><td>不适合大对象</td></tr><tr><td>List</td><td>队列、栈</td><td>有序存储</td><td>随机访问效率低</td></tr><tr><td>Set</td><td>去重、集合运算</td><td>去重、运算</td><td>无序存储</td></tr><tr><td>Sorted Set</td><td>排行榜、范围查询</td><td>有序、范围查询</td><td>内存占用较大</td></tr></tbody></table><h2><span id="性能优化建议">性能优化建议</span></h2><h3><span id="1-选择合适的数据类型">1. 选择合适的数据类型</span></h3><ul><li>根据使用场景选择最合适的数据类型</li><li>避免使用String存储复杂对象</li></ul><h3><span id="2-控制数据大小">2. 控制数据大小</span></h3><ul><li>避免存储过大的单个值</li><li>合理设置过期时间</li></ul><h3><span id="3-批量操作">3. 批量操作</span></h3><ul><li>使用MSET、MGET等批量命令</li><li>减少网络往返次数</li></ul><h3><span id="4-内存优化">4. 内存优化</span></h3><ul><li>使用压缩列表等优化存储</li><li>定期清理过期数据</li></ul><h2><span id="总结">总结</span></h2><p>Redis的五种基本数据类型各有特点，选择合适的类型可以大大提高系统性能。在实际应用中，需要根据具体场景选择最合适的数据类型，并注意性能优化。</p><hr><p><strong>上一篇</strong>：<a href="./Redis-01-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.md">Redis基础入门</a><br><strong>下一篇</strong>：<a href="./Redis-03-%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6.md">Redis持久化机制</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis基础入门</title>
      <link href="/blog/2025/10/15/tech/backend/database/redis/Redis-01-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2025/10/15/tech/backend/database/redis/Redis-01-%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="redis基础入门">Redis基础入门</span></h1><h2><span id="什么是redis">什么是Redis</span></h2><p>Redis是一个高性能的键值对数据库，数据存储在内存中，读写速度很快。</p><p>主要特点：</p><ul><li>内存存储，速度快</li><li>支持数据持久化</li><li>支持多种数据类型</li><li>单线程模型</li><li>每秒可处理10万次读写操作</li></ul><h2><span id="redis应用场景">Redis应用场景</span></h2><ol><li>缓存系统 - 热点数据缓存，减少数据库压力</li><li>会话存储 - 分布式Session，用户登录状态管理</li><li>消息队列 - 异步任务处理，发布&#x2F;订阅模式</li><li>分布式锁 - 防止重复操作，保证数据一致性</li><li>计数器 - 网站访问统计，实时数据统计</li></ol><h2><span id="redis优缺点">Redis优缺点</span></h2><p>优点：</p><ul><li>读写速度极快</li><li>支持多种数据类型</li><li>支持数据持久化</li><li>支持主从复制</li><li>所有操作都是原子性的</li></ul><p>缺点：</p><ul><li>数据量受内存限制</li><li>CPU密集型任务性能有限</li><li>主从同步可能有延迟</li><li>在线扩容较复杂</li></ul><h2><span id="redis安装配置">Redis安装配置</span></h2><p>安装Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line">sudo apt install redis-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL</span></span><br><span class="line">sudo yum install redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># macOS</span></span><br><span class="line">brew install redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># Docker</span></span><br><span class="line">docker run -d -p 6379:6379 redis:latest</span><br></pre></td></tr></table></figure><p>启动Redis：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis-server                    <span class="comment"># 启动服务</span></span><br><span class="line">redis-server --daemonize <span class="built_in">yes</span>    <span class="comment"># 后台启动</span></span><br><span class="line">redis-cli                       <span class="comment"># 连接客户端</span></span><br><span class="line">redis-cli ping                  <span class="comment"># 测试连接</span></span><br></pre></td></tr></table></figure><h2><span id="基本命令">基本命令</span></h2><p>键值操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SET key value        <span class="comment"># 设置键值</span></span><br><span class="line">GET key              <span class="comment"># 获取值</span></span><br><span class="line">DEL key              <span class="comment"># 删除键</span></span><br><span class="line">EXISTS key           <span class="comment"># 检查键是否存在</span></span><br><span class="line">EXPIRE key seconds   <span class="comment"># 设置过期时间</span></span><br><span class="line">TTL key              <span class="comment"># 查看剩余过期时间</span></span><br></pre></td></tr></table></figure><p>数据类型操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 字符串</span></span><br><span class="line">SET name <span class="string">&quot;张三&quot;</span></span><br><span class="line">GET name</span><br><span class="line">APPEND name <span class="string">&quot;李四&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表</span></span><br><span class="line">LPUSH list <span class="string">&quot;item1&quot;</span>   <span class="comment"># 左侧插入</span></span><br><span class="line">RPUSH list <span class="string">&quot;item2&quot;</span>   <span class="comment"># 右侧插入</span></span><br><span class="line">LPOP list            <span class="comment"># 左侧弹出</span></span><br><span class="line">RPOP list            <span class="comment"># 右侧弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 集合</span></span><br><span class="line">SADD <span class="built_in">set</span> <span class="string">&quot;member1&quot;</span>   <span class="comment"># 添加成员</span></span><br><span class="line">SMEMBERS <span class="built_in">set</span>         <span class="comment"># 查看所有成员</span></span><br><span class="line">SREM <span class="built_in">set</span> <span class="string">&quot;member1&quot;</span>   <span class="comment"># 删除成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 哈希</span></span><br><span class="line">HSET <span class="built_in">hash</span> field1 <span class="string">&quot;value1&quot;</span>  <span class="comment"># 设置字段</span></span><br><span class="line">HGET <span class="built_in">hash</span> field1           <span class="comment"># 获取字段值</span></span><br><span class="line">HGETALL <span class="built_in">hash</span>               <span class="comment"># 获取所有字段</span></span><br></pre></td></tr></table></figure><h2><span id="配置说明">配置说明</span></h2><p>主要配置项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bind 127.0.0.1          # 绑定IP</span><br><span class="line">port 6379               # 端口</span><br><span class="line">maxmemory 256mb         # 最大内存</span><br><span class="line">maxmemory-policy allkeys-lru  # 淘汰策略</span><br><span class="line">save 900 1              # 持久化配置</span><br><span class="line">requirepass yourpassword # 密码</span><br></pre></td></tr></table></figure><h2><span id="性能优化">性能优化</span></h2><ol><li>内存优化 - 合理设置maxmemory，选择合适的数据类型</li><li>网络优化 - 使用pipeline，合理设置超时时间</li><li>持久化优化 - 根据业务需求选择持久化方式</li></ol><h2><span id="监控维护">监控维护</span></h2><p>监控命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INFO                    <span class="comment"># 查看Redis信息</span></span><br><span class="line">INFO memory             <span class="comment"># 查看内存使用</span></span><br><span class="line">INFO clients            <span class="comment"># 查看连接信息</span></span><br><span class="line">SLOWLOG GET 10          <span class="comment"># 查看慢查询</span></span><br></pre></td></tr></table></figure><p>维护操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FLUSHDB                 <span class="comment"># 清空当前数据库</span></span><br><span class="line">FLUSHALL                <span class="comment"># 清空所有数据库</span></span><br><span class="line">SCAN 0                  <span class="comment"># 安全遍历键</span></span><br></pre></td></tr></table></figure><h2><span id="总结">总结</span></h2><p>Redis是功能强大的内存数据库，适合用作缓存和高速数据存储。掌握基础知识是学习高级特性的前提。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 数据库 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebRTC/WHIP 区别详解</title>
      <link href="/blog/2025/10/15/%E8%A7%86%E9%A2%91%E6%B5%81/WebRTC-WHIP-%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2025/10/15/%E8%A7%86%E9%A2%91%E6%B5%81/WebRTC-WHIP-%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="概述">概述</span></h2><p>WebRTC 和 WHIP 是两种不同的技术。简单说：</p><p>🧠 <strong>WebRTC</strong> 是通信协议族<br>🚀 <strong>WHIP</strong> 是用于推流（Ingest）的 WebRTC 标准化子协议</p><h2><span id="一-概念对比总览">一、概念对比总览</span></h2><table><thead><tr><th>项目</th><th>WebRTC</th><th>WHIP</th></tr></thead><tbody><tr><td><strong>全称</strong></td><td>Web Real-Time Communication</td><td>WebRTC-HTTP Ingestion Protocol</td></tr><tr><td><strong>定位</strong></td><td>一整套实时音视频传输协议（P2P 实时通信标准）</td><td>用 HTTP 封装 WebRTC 推流到服务器的简化协议</td></tr><tr><td><strong>标准组织</strong></td><td>W3C &#x2F; IETF</td><td>IETF (draft-ietf-wish-whip)</td></tr><tr><td><strong>使用场景</strong></td><td>浏览器与浏览器、浏览器与服务端之间的实时通信</td><td>客户端（如 OBS、浏览器、摄像头）推流到媒体服务器（如 Wowza、Janus、LiveKit、Millicast）</td></tr><tr><td><strong>信令机制</strong></td><td>自定义（开发者自己实现信令）</td><td>通过 HTTP POST&#x2F;DELETE 标准化信令</td></tr><tr><td><strong>传输协议</strong></td><td>SRTP + DTLS + ICE (UDP)</td><td>同 WebRTC，底层依然是 SRTP + DTLS + ICE</td></tr><tr><td><strong>推流&#x2F;拉流角色</strong></td><td>双方对等（peer-to-peer）</td><td>单向：Publisher → Media Server</td></tr><tr><td><strong>典型用途</strong></td><td>视频会议、实时互动</td><td>WebRTC 直播推流（低延迟直播）</td></tr></tbody></table><h2><span id="二-whip-的设计背景">二、WHIP 的设计背景</span></h2><p>WebRTC 本身只定义了音视频传输层（媒体、网络、加密），但<strong>不定义信令层</strong>。<br>也就是说，如何交换 SDP（Session Description Protocol）、如何建立连接由开发者自己决定。</p><p>→ 这让”推流场景”实现起来很复杂，每个平台信令都不一样。</p><p>💡 所以 IETF 推出了 <strong>WHIP</strong>（WebRTC-HTTP Ingestion Protocol），<br>目标是让 WebRTC 像 RTMP 一样容易推流：</p><ol><li>用一个 <strong>HTTP POST</strong> 发起推流（发送 SDP offer）</li><li>服务器返回 <strong>SDP answer</strong></li><li>推流端开始传输媒体流</li><li>用 <strong>HTTP DELETE</strong> 停止推流</li></ol><p>这样浏览器、OBS、GStreamer 等工具可以用统一接口推流到任意支持 WHIP 的服务器。</p><h2><span id="三-whip-工作流程示例">三、WHIP 工作流程示例</span></h2><p>👇 <strong>WHIP 推流时序图</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[Client]                        [Media Server]</span><br><span class="line">   |                                  |</span><br><span class="line">   |  POST /whip-endpoint             |</span><br><span class="line">   |  Content-Type: application/sdp   |</span><br><span class="line">   |  Body: SDP offer                 |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |       201 Created                |</span><br><span class="line">   |  Location: /resource/id          |</span><br><span class="line">   |  Body: SDP answer                |</span><br><span class="line">   |&lt;---------------------------------|</span><br><span class="line">   |                                  |</span><br><span class="line">   |------ ICE Candidate Exchange ----|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  (Start sending RTP media)       |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  DELETE /resource/id             |</span><br><span class="line">   |---------------------------------&gt;|</span><br><span class="line">   |                                  |</span><br><span class="line">   |  (Stop streaming)                |</span><br></pre></td></tr></table></figure><h2><span id="四-whip-与传统-rtmp-推流对比">四、WHIP 与传统 RTMP 推流对比</span></h2><table><thead><tr><th>对比项</th><th>RTMP</th><th>WHIP</th></tr></thead><tbody><tr><td><strong>协议层</strong></td><td>TCP</td><td>UDP (SRTP over ICE)</td></tr><tr><td><strong>延迟</strong></td><td>秒级（2~5s）</td><td>低于 500ms</td></tr><tr><td><strong>推流接口</strong></td><td>统一（rtmp:&#x2F;&#x2F;…）</td><td>标准化 HTTP (REST API)</td></tr><tr><td><strong>推流格式</strong></td><td>FLV</td><td>SDP + RTP</td></tr><tr><td><strong>是否加密</strong></td><td>否（或 TLS）</td><td>强制 DTLS + SRTP</td></tr><tr><td><strong>主要用途</strong></td><td>点播直播</td><td>超低延迟互动直播</td></tr></tbody></table><h2><span id="五-whip-的反向协议whep">五、WHIP 的反向协议：WHEP</span></h2><p><strong>WHIP</strong> 是 推流（Ingest），<br>而 <strong>WHEP</strong>（WebRTC-HTTP Egress Protocol） 是 拉流（Playback） 标准化协议。</p><p>二者配合可以替代 RTMP + HLS 的整套流程：</p><table><thead><tr><th>方向</th><th>协议</th><th>作用</th></tr></thead><tbody><tr><td>推流</td><td>WHIP</td><td>客户端 → 服务端</td></tr><tr><td>拉流</td><td>WHEP</td><td>服务端 → 播放端</td></tr></tbody></table><h2><span id="六-总结">六、总结</span></h2><p><strong>WebRTC</strong> 是底层传输标准，<strong>WHIP</strong> 是基于 WebRTC 的统一推流信令协议。<br>WHIP 让”WebRTC 推流”像”RTMP 推流”一样简单。</p><h2><span id="七-实际应用">七、实际应用</span></h2><p>如果你要在实际项目中使用：</p><h3><span id="服务器端">服务器端</span></h3><p>可以使用支持 WHIP 的媒体服务器：</p><ul><li><strong>Janus</strong> - 开源的 WebRTC 网关</li><li><strong>LiveKit</strong> - 现代化的实时音视频平台</li><li><strong>Wowza</strong> - 商业流媒体服务器</li><li><strong>OvenMediaEngine</strong> - 开源流媒体服务器</li></ul><h3><span id="客户端">客户端</span></h3><p>可以用以下工具：</p><ul><li>浏览器原生 <strong>WebRTC API</strong></li><li><strong>OBS</strong> 最新版本的 “WHIP 推流插件”</li><li><strong>ffmpeg</strong> -f whip（最新版也支持）</li></ul><hr><blockquote><p>💡 <strong>提示</strong>：WHIP 协议目前还在 IETF 草案阶段，但已经被多个主流媒体服务器支持，是未来 WebRTC 推流的标准方向。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 视频流技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebRTC </tag>
            
            <tag> WHIP </tag>
            
            <tag> 实时通信 </tag>
            
            <tag> 直播技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中如何做到动态分配网络域名</title>
      <link href="/blog/2024/07/17/tech/devops/k8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/"/>
      <url>/blog/2024/07/17/tech/devops/k8s/k8s-6-%E4%B8%AD%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C%E5%9F%9F%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s中关于服务网络的使用</title>
      <link href="/blog/2024/07/17/tech/devops/k8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/blog/2024/07/17/tech/devops/k8s/k8s-5-%E4%B8%AD%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E7%BD%91%E7%BB%9C%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang Context上下文</title>
      <link href="/blog/2024/07/15/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B08-Context%E4%B8%8A%E4%B8%8B%E6%96%87/"/>
      <url>/blog/2024/07/15/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B08-Context%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="/blog/image.png" alt="alt text"></p><p><a href="https://zhuanlan.zhihu.com/p/68792989">https://zhuanlan.zhihu.com/p/68792989</a></p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s-有状态服务无状态服务和对外访问服务</title>
      <link href="/blog/2024/04/12/tech/devops/k8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/"/>
      <url>/blog/2024/04/12/tech/devops/k8s/k8s-3-%E6%9C%89%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ol><li>基本概念<br>无状态服务<br>无状态服务不会在本地存储持久化数据.多个服务实例对于同一个用户请求的响应结果是完全一致的.这种多服务实例之间是没有依赖关系,比如web应用,在k8s控制器 中动态启停无状态服务的pod并不会对其它的pod产生影响.</li></ol><p>有状态服务<br>有状态服务需要在本地存储持久化数据,典型的是分布式数据库的应用,分布式节点实例之间有依赖的拓扑关系.比如,主从关系. 如果K8S停止分布式集群中任 一实例pod,就可能会导致数据丢失或者集群的crash.</p><ol start="2"><li>Deployment部署的问题?</li></ol><p>Deployment被设计用来管理无状态服务的pod,每个pod完全一致.什么意思呢?</p><p>无状态服务内的多个Pod创建的顺序是没有顺序的.<br>无状态服务内的多个Pod的名称是随机的.pod被重新启动调度后,它的名称与IP都会发生变化.<br>无状态服务内的多个Pod背后是共享存储的.<br>2.1.新的问题</p><p>对于数据库有状态的服务容器编排,Deployment解决方案就变得无能为力了.<br>比如,Redis是主从的架构,只能允许集群中出现一个主节点提供写,其它节点提供读能力.如果同时出现二个主节点后,必须会出现并发写的 操作,进一步导致集群写数据的不一致.<br>所以问题来了,针对Redis这种有状态的服务,它管理的多个Pod(代表master&#x2F;slave角色)必须有自己独立的持久化存储组件.<br>有状态的服务Pod是用来运行有状态应用的,其在数据卷上存储的数据非常重要,因为Stateful就是要依赖存储数据卷上对每个Pod的状态进行建模与存储.<br>所以K8S提供了一个新的工具——StatefulSet来统一解决问题.</p><ol start="3"><li>Stateful如何解决问题?<br>Deployment组件是为无状态服务而设计的,其中的Pod名称,主机名,存储都是随机,不稳定的,并且Pod的创建与销毁也是无序的.这个设计决定了无状态服务并 不适合数据库领域的应用.</li></ol><p>而Stateful管理有状态的应用,它的Pod有如下特征:</p><p>唯一性: 每个Pod会被分配一个唯一序号.<br>顺序性: Pod启动,更新,销毁是按顺序进行.<br>稳定的网络标识: Pod主机名,DNS地址不会随着Pod被重新调度而发生变化.<br>稳定的持久化存储: Pod被重新调度后,仍然能挂载原有的PV,从而保证了数据的完整性和一致性.</p><p>3.1. 如何理解稳定网络标识?</p><p>创建名为test-redis-pod的Stateful模型,根据你配置的Replica&#x3D;3的设置,K8S会创建三个Pod,依次命名为: test-redis-pod-0; test-redis-pod-1; test-redis-pod-2</p><p>K8S为有状态的服务Pod分配稳定的网络标识,具体实现基于test-redis-pod-0名称,借助Headless DNS进行如下解析,获取后端其中一个Pod的地址.</p><p>$(pod name).$(service name).$(namespace).svc.cluster.local<br>下面是一个通过Pod名称访问Redis集群的Master节点地址的方法.</p><p>session.save_path &#x3D; “tcp:&#x2F;&#x2F;test-redis-pod-0.test-redis-service.default.svc.cluster.local:6379”<br>现在回答如下二个问题:</p><p>在Redis Pod内部,主从节点之间数据同步的需求,Slave节点对应的配置文件中需要一个稳定的Master地址.下边脚本就是稳定访问test-redis-pod-0 名称来间接获得Redis Master节点IP地址,然后写入到Redis Slave的配置文件中,这样后续Slave节点与Master节点才能完成增量数据的同步.<br>if [ “${server_host}” !&#x3D; “test-redis-pod-0” ];then<br>        #echo “server-count: ${server_counts}” &gt;&gt; &#x2F;data&#x2F;test.log</p><pre><code>    while [ -z &quot;$&#123;master_address&#125;&quot; ];do        echo &quot;master_address is not available, $&#123;master_address&#125; waiting for redis master...&quot; &gt;&gt; /data/test.log        master_address=$(replication_master_address)        sleep 1s    donefiecho &quot;master_address: $(master_address)&quot; &gt;&gt; /data/test.logif [ ! -z &quot;$master_address&quot; ]; then    printf &quot;\nslaveof %s 6379\n&quot; &quot;$master_address&quot; &gt;&gt; $conffi</code></pre><p>在Redis Pod外部, 可以通过$(pod name).$(service name).$(namespace).svc.cluster.local方式来访问具体的Pod服务.<br>3.2. 如何理解稳定持久化存储?</p><p>每个Redis Pod对应一个自己的PVC&#x2F;PV.当Pod发生调度时,需要在别的节点启动时,根据Pod背后关联的存储信息保证其名称的稳定性.</p><p>Pod还是会attach挂载到原来的PV&#x2F;PVC中,从而确定每个Pod有自己专用的存储卷.</p><ol start="4"><li>总结<br>本文主要介绍了无状态和有状态服务在K8S中的典型应用场景.</li></ol><p>通过对Deployment部署无状态服务所遇到问题的分析,引出了Stateful新的部署组件.它是通过支持Pod一些特性(e.g. 名称唯一性,稳定的网络标识, 稳定的持久化存储等)来实现在K8S中部署运维有状态服务.</p><p>牢记: Stateful有状态服务,每个Pod有独立的PVC&#x2F;PV存储组件</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s-StorageClass PV PVC 概念和使用</title>
      <link href="/blog/2024/04/12/tech/devops/k8s/k8s-4-StorageClass%20PV%20PVC/"/>
      <url>/blog/2024/04/12/tech/devops/k8s/k8s-4-StorageClass%20PV%20PVC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>负责把PVC绑定到PV的是一个持久化存储卷控制循环，这个控制器也是kube-manager-controller的一部分运行在master上。而真正把目录挂载到容器上的操作是在POD所在主机上发生的，所以通过kubelet来完成。而且创建PV以及PVC的绑定是在POD被调度到某一节点之后进行的，完成这些操作，POD就可以运行了。下面梳理一下挂载一个PV的过程：</p><p>用户提交一个包含PVC的POD</p><p>调度器把根据各种调度算法把该POD分配到某个节点，比如node01</p><p>Node01上的kubelet等待Volume Manager准备存储设备</p><p>PV控制器调用存储插件创建PV并与PVC进行绑定</p><p>Attach&#x2F;Detach Controller或Volume Manager通过存储插件实现设备的attach。（这一步是针对块设备存储）</p><p>Volume Manager等待存储设备变为可用后，挂载该设备到&#x2F;var&#x2F;lib&#x2F;kubelet&#x2F;pods&#x2F;&lt;Pod 的 ID&gt;&#x2F;volumes&#x2F;kubernetes.io~&lt;Volume 类型 &gt;&#x2F;&lt;Volume 名字 &gt;目录上</p><p>Kubelet被告知卷已经准备好，开始启动POD，通过映射方式挂载到容器中</p><p>总结：本地卷也就是LPV不支持动态供给的方式，延迟绑定，就是为了综合考虑所有因素再进行POD调度。其根本原因是动态供给是先调度POD到节点，然后动态创建PV以及绑定PVC最后运行POD；而LPV是先创建与某一节点关联的PV，然后在调度的时候综合考虑各种因素而且要包括PV在哪个节点，然后再进行调度，到达该节点后在进行PVC的绑定。也就说动态供给不考虑节点，LPV必须考虑节点。所以这两种机制有冲突导致无法在动态供给策略下使用LPV。换句话说动态供给是PV跟着POD走，而LPV是POD跟着PV走。</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-笔记7-error.group用法</title>
      <link href="/blog/2024/03/26/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/"/>
      <url>/blog/2024/03/26/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B07-error-group%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4><span id="1-先看下数据结构">1 .先看下数据结构</span></h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Group <span class="keyword">struct</span> &#123;</span><br><span class="line">cancel <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">sem <span class="keyword">chan</span> token</span><br><span class="line"></span><br><span class="line">errOnce sync.Once</span><br><span class="line">err     <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="2在并发编程里-syncwaitgroup">2.在并发编程里 sync.WaitGroup</span></h4><p>并发原语的使用频率非常高，它经常用于协同等待的场景 gorouting 都完成后才能继续执行。</p><p>如果在woker goroutine的执行过程中遇到错误并想要处理该怎么办？</p><p>WaitGroup并没有提供传播错误的功能，遇到这种场景我们该怎么办？Go语言在扩展库提供了ErrorGroup并发原语正好适合在这种场景下使用，它在WaitGroup的基础上还提供了，错误传播以及上下文取消的功能。</p><p>扩展库通过errorgroup.Group提供ErrorGroup原语的功能，它有三个方法可调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func WithContext(ctx context.Context) (*Group, context.Context)</span><br><span class="line">func (g *Group) Go(f func() error)</span><br><span class="line">func (g *Group) Wait() error</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ErrorGroup有一个特点是会返回所以执行任务的goroutine遇到的第一个错误</span></span><br></pre></td></tr></table></figure><h4><span id="3想让程序遇到错误就终止其他子任务">3.想让程序遇到错误就终止其他子任务</span></h4><p>最早执行遇到错误的goroutine输出了Error: 98但是所有未执行完的其他任务并没有停止执行，那么想让程序遇到错误就终止其他子任务该怎么办呢？我们可以用errgroup.Group提供的WithContext方法创建一个带可取消上下文功能的ErrorGroup。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用errorgroup.Group时注意它的两个特点：</span><br><span class="line">- errgroup.Group在出现错误或者等待结束后都会调用 Context对象 的 cancel 方法同步取消信号。</span><br><span class="line">- 只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</span><br><span class="line">*/</span><br><span class="line">func main() &#123;</span><br><span class="line">   eg, ctx := errgroup.WithContext(context.Background())</span><br><span class="line"></span><br><span class="line">   for i := 0; i &lt; 100; i++ &#123;</span><br><span class="line">      i := i</span><br><span class="line">      eg.Go(func() error &#123;</span><br><span class="line">         time.Sleep(2 * time.Second)</span><br><span class="line"></span><br><span class="line">         select &#123;</span><br><span class="line">         case &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(&quot;Canceled:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         default:</span><br><span class="line">            if i &gt; 90 &#123;</span><br><span class="line">               fmt.Println(&quot;Error:&quot;, i)</span><br><span class="line">               return fmt.Errorf(&quot;Error: %d&quot;, i)</span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(&quot;End:&quot;, i)</span><br><span class="line">            return nil</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">   &#125;</span><br><span class="line">   if err := eg.Wait(); err != nil &#123;</span><br><span class="line">      log.Fatal(err)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="4cancle到其他的子任务">4.cancle到其他的子任务</span></h4><p>在上面的例子中，子goroutine出现错误后，会cancle到其他的子任务，但是我们并没有看到调用ctx的cancel方法，下面我们看下源码，看看内部是怎么处理的。<br> errgroup 的设计非常精练，全部代码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package errgroup</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;context&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// A Group is a collection of goroutines working on subtasks that are part of</span><br><span class="line">// the same overall task.</span><br><span class="line">//</span><br><span class="line">// A zero Group is valid and does not cancel on error.</span><br><span class="line">type Group struct &#123;</span><br><span class="line">    cancel func()</span><br><span class="line">    wg sync.WaitGroup</span><br><span class="line">    errOnce sync.Once</span><br><span class="line">    err     error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// WithContext returns a new Group and an associated Context derived from ctx.</span><br><span class="line">//</span><br><span class="line">// The derived Context is canceled the first time a function passed to Go</span><br><span class="line">// returns a non-nil error or the first time Wait returns, whichever occurs</span><br><span class="line">// first.</span><br><span class="line">func WithContext(ctx context.Context) (*Group, context.Context) &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    return &amp;Group&#123;cancel: cancel&#125;, ctx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Wait blocks until all function calls from the Go method have returned, then</span><br><span class="line">// returns the first non-nil error (if any) from them.</span><br><span class="line">func (g *Group) Wait() error &#123;</span><br><span class="line">    g.wg.Wait()</span><br><span class="line">    if g.cancel != nil &#123;</span><br><span class="line">        g.cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    return g.err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Go calls the given function in a new goroutine.</span><br><span class="line">//</span><br><span class="line">// The first call to return a non-nil error cancels the group; its error will be</span><br><span class="line">// returned by Wait.</span><br><span class="line">func (g *Group) Go(f func() error) &#123;</span><br><span class="line">    g.wg.Add(1)</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        defer g.wg.Done()</span><br><span class="line"></span><br><span class="line">        if err := f(); err != nil &#123;</span><br><span class="line">            g.errOnce.Do(func() &#123;</span><br><span class="line">                g.err = err</span><br><span class="line">                if g.cancel != nil &#123;</span><br><span class="line">                    g.cancel()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，errgroup 的实现依靠于结构体 Group，它通过封装 sync.WaitGroup，继承了 WaitGroup 的特性，在 Go() 方法中新起一个子任务 goroutine，并在 Wait() 方法中通过 sync.WaitGroup 的 Wait 进行阻塞等待。</p><p>同时 Group 利用 sync.Once 保证了它有且仅会保留第一个子 goroutine 错误。<br> Group 通过嵌入 context.WithCancel 方法产生的 <code>cancel</code> 函数（对于 Context 不熟悉的读者，推荐阅读 <a href="https://links.jianshu.com/go?to=https://mp.weixin.qq.com/s?__biz=MzkyMzIyNjIxMQ==&mid=2247484553&idx=1&sn=ce4c7e052bacf69c38e27d71187726c8&scene=21%23wechat_redirect">理解Context机制</a> 一文），能够<strong>在子 goroutine 发生错误时，及时通过调用 cancle 函数，将 Context 的取消信号及时传播出去。</strong></p><h4><span id="5总结">5.总结:</span></h4><p>使用errorgroup.Group时注意它的特点：</p><ul><li>继承了 WaitGroup 的功能</li><li>errgroup.Group在出现错误或者等待结束后都会调用Context对象 的 cancel 方法同步取消信号。</li><li>只有第一个出现的错误才会被返回，剩余的错误都会被直接抛弃。</li><li>context 信号传播：如果子任务 goroutine 中有循环逻辑，则可以添加 ctx.Done 逻辑，此时通过 context 的取消信号，提前结束子任务执行。</li></ul><p>.</p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> error.group </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s-kubeadmin安装</title>
      <link href="/blog/2024/03/18/tech/devops/k8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/"/>
      <url>/blog/2024/03/18/tech/devops/k8s/k8s-1-kubeadmin%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>通过kubeadm工具，部署k8s集群。操作步骤如下：</p><ol><li><p>准备工作：</p></li><li><ol><li>配置yum源，repo(防被墙)</li><li>安装常用工具，同步时间</li><li>关闭防火墙，将SELinux配置为Permissive模式，关闭swap</li><li>加载ipvs模块，优化内核</li></ol></li><li><p>在所有机器上安装docker</p></li><li><p>在所有机器上安装kubeadm, kubelet, kubectl</p></li><li><p>部署集群Master节点</p></li><li><p>部署集群工作节点</p></li><li><p>安装CNI网络插件</p></li></ol><ul><li>一个Kubernetes集群Master节点。k8s官网现在将master节点称为control plane node(控制平面节点)</li><li>一个Kubernetes集群Slave节点。k8s官网叫worker node(工作节点)。下文中Slave节点和工作节点含义含义相同。</li></ul><table><thead><tr><th>hostname</th><th>ip</th><th>备注</th><th></th></tr></thead><tbody><tr><td>master</td><td>master.k8s</td><td>192.168.246.133</td><td>k8s主节点(control plane node)</td></tr><tr><td>slave</td><td>slave.k8s</td><td>192.168.246.132</td><td>k8s 工作节点(worker node)</td></tr></tbody></table><h2><span id="0-系统要求">0. <strong>系统要求</strong></span></h2><p>安装之前，请确保操作系统满足如下要求：</p><ol><li>Linux内核操作系统，如CentOS，Ubuntu等</li><li>至少2 CPU， 2GB</li><li>集群中所有机器之间的网络必须是通的(公共或私有网络都可以)。</li><li>每个节点都有唯一的主机名、MAC地址和product_uuid</li><li>部署时要保证能连外网</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看操作系统</span></span></span><br><span class="line">cat /proc/version</span><br><span class="line">hostnamectl</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看IP和MAC命令</span></span></span><br><span class="line">ip link</span><br><span class="line">ifconfig -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看product_uuid</span></span></span><br><span class="line">sudo cat /sys/class/dmi/id/product_uuid</span><br></pre></td></tr></table></figure><h2><span id="1-准备工作"><strong>1. 准备工作</strong></span></h2><p><strong>在所有节点上运行</strong></p><h3><span id="11-配置yum源repo"><strong>1.1 配置yum源，repo</strong></span></h3><p>由于众所周知的原因，为防止在安装时出现资源下载失败的问题，在所有节点上配置yum源，repo。shell如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum源</span></span><br><span class="line">curl -o /etc/yum.repos.d/Centos-7.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker repo</span></span><br><span class="line">curl -o /etc/yum.repos.d/docker-ce.repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">kubernetes repo</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">缓存</span></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure><h3><span id="12-安装常用的工具同步时间"><strong>1.2 安装常用的工具，同步时间</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum -y install tree vim wget bash-completion bash-completion-extras lrzsz net-tools sysstat iotop iftop htop unzip nc nmap telnet bc  psmisc httpd-tools ntpdate</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">时区修改,如果/etc/localtime有软连接,不是Shanghai,可以直接删除,在软链接</span></span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">ntpdate ntp2.aliyun.com            # 同步阿里云服务器上的时间.</span><br><span class="line">/sbin/hwclock --systohc            # 写入到bios系统    </span><br></pre></td></tr></table></figure><h3><span id="13-检查防火墙是否关闭将selinux配置为permissive模式关闭swap"><strong>1.3 检查防火墙是否关闭，将SELinux配置为Permissive模式，关闭swap</strong></span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 查看防火墙状态</span></span></span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果防火墙是running，关闭防火墙</span></span></span><br><span class="line">sudo systemctl disable firewalld &amp;&amp; systemctl stop firewalld</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># Set SELinux to permissive mode.将SELinux配置为Permissive模式</span></span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 也可以直接关闭SELinux</span></span> </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo setenforce 0</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">sudo sed -ri <span class="string">&#x27;s#(SELINUX=).*#\1disabled#&#x27;</span> /etc/selinux/config</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">临时关闭swap。如果不关闭，kubelet会启动失败</span></span><br><span class="line">sudo swapoff -a</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">永久防止开机自动挂载swap</span></span><br><span class="line">sudo sed -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstab</span><br></pre></td></tr></table></figure><h3><span id="14-加载ipvs模块优化内核"><strong>1.4 加载ipvs模块，优化内核</strong></span></h3><p>如下参数不修改，会导致<code>kubeadm init</code>运行失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加载ipvs模块</span></span><br><span class="line">modprobe br_netfilter</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证ip_vs模块</span></span><br><span class="line">lsmod |grep ip_vs</span><br><span class="line">ip_vs_wrr              12697  0 </span><br><span class="line">ip_vs_rr               12600  0 </span><br><span class="line">ip_vs_sh               12688  0 </span><br><span class="line">ip_vs                 145458  6 ip_vs_rr,ip_vs_sh,ip_vs_wrr</span><br><span class="line">nf_conntrack          139264  2 ip_vs,nf_conntrack_ipv4</span><br><span class="line">libcrc32c              12644  3 xfs,ip_vs,nf_conntrack</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内核文件</span> </span><br><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward=1</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line">EOF</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">生效并验证内核优化</span></span><br><span class="line">sysctl -p /etc/sysctl.d/k8s.conf</span><br></pre></td></tr></table></figure><h2><span id="2-安装docker"><strong>2. 安装docker</strong></span></h2><p><em>在所有节点上运行</em></p><h3><span id="21-安装启动docker"><strong>2.1 安装启动docker</strong></span></h3><p>注意：安装docker需要root权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. yum 安装</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 运行sudo yum install docker-ce 也是可以的，docker-ce依赖了docker-ce-cli, containerd.io, docker-buildx-plugin, docker-compose-plugin。这些依赖会同步install</span></span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 2. 配置docker</span></span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">    &quot;registry-mirrors&quot;: [</span><br><span class="line">        &quot;https://registry.hub.docker.com&quot;,</span><br><span class="line">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125; </span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 3. 启动docker</span></span></span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>验证是否安装正确</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 4. docker运行正常</span></span><br><span class="line">[shirley@master k8s_install]$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/docker.service; disabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Tue 2023-10-10 09:23:41 CST; 19s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 16381 (dockerd)</span><br><span class="line">    Tasks: 8</span><br><span class="line">   Memory: 27.4M</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           └─16381 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/con...</span><br><span class="line">[shirley@master k8s_install]$</span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行docker命令，验证镜像下载正常，容器运行正常</span></span><br><span class="line">[shirley@slave k8s_install]$ sudo docker run hello-world</span><br><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line">latest: Pulling from library/hello-world</span><br><span class="line">719385e32844: Pull complete</span><br><span class="line">Digest: sha256:4f53e2564790c8e7856ec08e384732aa38dc43c52f02952483e3f003afbf23db</span><br><span class="line">Status: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><h3><span id="22-配置containerd中pause镜像地址"><strong>2.2 配置containerd中pause镜像地址</strong></span></h3><p>为了防止安装过程中出现pause镜像下载失败的问题，建议运行<code>containerd config dump &gt; /etc/containerd/config.toml </code>命令，将当前配置导出到文件，并修改<code>sandbox_image</code>配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 如果没有/etc/containerd/config.toml文件，将默认配置导出到/etc/containerd/config.toml。</span></span></span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 修改配置文件/etc/containerd/config.toml， 更改sandbox_image配置</span></span></span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    sandbox_image = &quot;registry.aliyuncs.com/google_containers/pause:3.9&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># PS: 如果生成的/etc/containerd/config.toml中没有如上配置项，可以运行如下命令导出当前所有配置项后再修改文件/etc/containerd/config.toml</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">containerd config dump &gt; /etc/containerd/config.toml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 重启containerd</span></span></span><br><span class="line">systemctl restart containerd</span><br></pre></td></tr></table></figure><h2><span id="3-部署kubeadm-kubelet-kubectl"><strong>3. 部署kubeadm, kubelet, kubectl</strong></span></h2><p>kubeadm：启动k8s集群的工具</p><p>kubelet: 该组件在集群中的所有机器上运行，并执行启动pod和容器之类的任务。</p><p>kubectl: 与集群通信的工具。可以只在master节点上安装。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">## 开机启动kubelet</span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><p>验证</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看kubeadm版本</span></span><br><span class="line">[root@master ~]<span class="comment"># sudo kubeadm version</span></span><br><span class="line">kubeadm version: &amp;version.Info&#123;Major:<span class="string">&quot;1&quot;</span>, Minor:<span class="string">&quot;28&quot;</span>, GitVersion:<span class="string">&quot;v1.28.2&quot;</span>, GitCommit:<span class="string">&quot;89a4ea3e1e4ddd7f7572286090359983e0387b2f&quot;</span>, GitTreeState:<span class="string">&quot;clean&quot;</span>, BuildDate:<span class="string">&quot;2023-09-13T09:34:32Z&quot;</span>, GoVersion:<span class="string">&quot;go1.20.8&quot;</span>, Compiler:<span class="string">&quot;gc&quot;</span>, Platform:<span class="string">&quot;linux/amd64&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2><span id="4-初始化master节点kubeadm-init"><strong>4.</strong> 初始化Master节点（kubeadm init）</span></h2><p><em>在Master节点运行</em></p><h3><span id="41-更改配置文件"><strong>4.1. 更改配置文件</strong></span></h3><p><code>kubeadm init</code>命令用于初始化master节点。kubeadm init 的参数可以通过<strong>命令行</strong>或<strong>yaml文件</strong>进行配置。本文介绍如何通过yaml文件进行配置。可以通过<code>kubeadm config print init-defaults</code>命令得到一份默认配置，然后对其进行修改。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults &gt; kubeadm.yaml</span><br></pre></td></tr></table></figure><p>对kubeadm.yaml进行编辑，修改内容如下：</p><ol><li>修改<code>advertiseAddress</code>为master IP地址</li><li><code>imageRepository</code>修改为<code>registry.aliyuncs.com/google_containers</code>，防止镜像拉不下来</li><li>建议将<code>networking.podSubnet</code>修改为<code>10.244.0.0/16</code>， 和后续安装的flannel CNI 插件的默认配置保持一致。</li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">bootstrapTokens:</span><br><span class="line">- groups:</span><br><span class="line">  - system:bootstrappers:kubeadm:default-node-token</span><br><span class="line">  token: abcdef.0123456789abcdef</span><br><span class="line">  ttl: 24h0m0s</span><br><span class="line">  usages:</span><br><span class="line">  - signing</span><br><span class="line">  - authentication</span><br><span class="line">kind: InitConfiguration</span><br><span class="line">localAPIEndpoint:</span><br><span class="line">  advertiseAddress: 192.168.246.133    ## change the IP of apiserver.</span><br><span class="line">  bindPort: 6443</span><br><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br><span class="line">  imagePullPolicy: IfNotPresent</span><br><span class="line">  name: node</span><br><span class="line">  taints: null</span><br><span class="line">---</span><br><span class="line">apiServer:</span><br><span class="line">  timeoutForControlPlane: 4m0s</span><br><span class="line">apiVersion: kubeadm.k8s.io/v1beta3</span><br><span class="line">certificatesDir: /etc/kubernetes/pki</span><br><span class="line">clusterName: kubernetes</span><br><span class="line">controllerManager: &#123;&#125;</span><br><span class="line">dns: &#123;&#125;</span><br><span class="line">etcd:</span><br><span class="line">  local:</span><br><span class="line">    dataDir: /var/lib/etcd</span><br><span class="line">imageRepository: registry.aliyuncs.com/google_containers   ## change imageRepository to aliyun.</span><br><span class="line">kind: ClusterConfiguration</span><br><span class="line">kubernetesVersion: 1.28.0</span><br><span class="line">networking:</span><br><span class="line">  dnsDomain: cluster.local</span><br><span class="line">  podSubnet: 10.244.0.0/16  ## add this line to config POD network. Same with CNI config.</span><br><span class="line">  serviceSubnet: 10.96.0.0/12</span><br><span class="line">scheduler: &#123;&#125;</span><br></pre></td></tr></table></figure><p>如上配置文件等价于命令行：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init \</span><br><span class="line">  --apiserver-advertise-address=192.168.246.133 \</span><br><span class="line">  --image-repository registry.aliyuncs.com/google_containers \</span><br><span class="line">  --kubernetes-version v1.28.0 \</span><br><span class="line">  --service-cidr=10.96.0.0/12 \</span><br><span class="line">  --pod-network-cidr=10.244.0.0/16 </span><br></pre></td></tr></table></figure><ul><li>–apiserver-advertise-address 集群通告地址</li><li>–image-repository 由于默认拉取镜像地址<a href="https://link.zhihu.com/?target=http://k8s.gcr.io">http://k8s.gcr.io</a>国内无法访问，这里指定阿里云镜像仓库地址</li><li>–kubernetes-version K8s版本，与上面安装的一致</li><li>–service-cidr 集群内部虚拟网络，Pod统一访问入口</li><li>–pod-network-cidr Pod网络，<strong>与下面部署的CNI网络组件yaml中保持一致</strong></li></ul><h3><span id="42-提前pull镜像可选"><strong>4.2 提前pull镜像（可选）</strong></span></h3><p>为了使后续安装更快，建议先把安装需要的镜像pull下来。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 验证配置文件格式是否正确</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config validate --config kubeadm.yaml</span><br><span class="line">ok</span><br><span class="line"></span><br><span class="line"><span class="comment">## 查看需要下载哪些镜像。需要关注下载的repository地址是否正确。</span></span><br><span class="line"><span class="comment">## 如上在kubeadm.yaml文件配置了imageRepository：registry.aliyuncs.com/google_containers，因此images会从aliyun的repo下载。</span></span><br><span class="line">[shirley@master k8s_install]$ kubeadm config images list --config kubeadm.yaml</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">## pull镜像。pull镜像有点慢，第一个镜像pull成功后才有日志输出。命令运行后发现没有日志不要着急，多等一会。</span></span><br><span class="line">[shirley@master k8s_install]$ sudo kubeadm config images pull --config kubeadm.yaml</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-apiserver:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-controller-manager:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-scheduler:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/kube-proxy:v1.28.0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/pause:3.9</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/etcd:3.5.9-0</span><br><span class="line">[config/images] Pulled registry.aliyuncs.com/google_containers/coredns:v1.10.1</span><br></pre></td></tr></table></figure><h3><span id="43-kubeadm-init初始化"><strong>4.3 kubeadm init初始化</strong></span></h3><p>运行<code>kubeadm init --config kubeadm.yaml</code>， 当看到<code>Your Kubernetes control-plane has initialized successfully!</code>时表示安装成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@master k8s_install]<span class="comment"># kubeadm init --config kubeadm.yaml</span></span><br><span class="line">... ...</span><br><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, <span class="keyword">if</span> you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p><strong>PS：最好将最后一行log需要记下来，worker节点安装会用到。</strong></p><p>根据提示，退出root账户后运行命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo <span class="built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo <span class="built_in">chown</span> $(<span class="built_in">id</span> -u):$(<span class="built_in">id</span> -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><h3><span id="44-验证"><strong>4.4 验证</strong></span></h3><p>验证master节点是否部署成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## kubectl 运行正常. STATUS=NotReady是因为CNI插件还没装。</span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME   STATUS     ROLES           AGE   VERSION</span><br><span class="line">node   NotReady   control-plane   20m   v1.28.2</span><br><span class="line"></span><br><span class="line"><span class="comment">## 通过crictl命令可以查看到运行的container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo crictl ps -a</span><br><span class="line">CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID              POD</span><br><span class="line">955b0c87ad621       ea1030da44aa1       26 minutes ago      Running             kube-proxy                0                   78efbee65dfac       kube-proxy-kp9kw</span><br><span class="line">f69d8c3246904       73deb9a3f7025       26 minutes ago      Running             etcd                      0                   77180bc7ff0a8       etcd-node</span><br><span class="line">3efba65f263d3       f6f496300a2ae       26 minutes ago      Running             kube-scheduler            0                   f89fb4bb60e2e       kube-scheduler-node</span><br><span class="line">5dfb28390f30b       4be79c38a4bab       26 minutes ago      Running             kube-controller-manager   0                   b716cb4652e1c       kube-controller-manager-node</span><br><span class="line">b8cfce31fa842       bb5e0dde9054c       26 minutes ago      Running             kube-apiserver            0                   006db1ce43cfe       kube-apiserver-node</span><br></pre></td></tr></table></figure><p>这里有大家可能有个疑惑，为什么docker ps看不到运行的容器</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 运行docker命令，发现没有container</span></span><br><span class="line">[shirley@master k8s_install]$ sudo docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure><p>这是因为kubernetes使用的containerd作为容器运行时，而不是Docker engine. kubernetes支持4中容器运行时：</p><table><thead><tr><th>Runtime</th><th>Path to Unix domain socket（CRI socket）</th></tr></thead><tbody><tr><td>containerd</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;containerd&#x2F;containerd.sock</td></tr><tr><td>CRI-O</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;crio&#x2F;crio.sock</td></tr><tr><td>Docker Engine (using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr><tr><td>Mirantis Container Runtime (MCR)(using cri-dockerd)</td><td>unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;cri-dockerd.sock</td></tr></tbody></table><p>By default, Kubernetes uses the Container Runtime Interface (CRI) to interface with your chosen container runtime.</p><p>默认情况下，kubernetes会用CRI找到选择的容器运行时。在我们安装docker时，安装了containerd，因此k8s找到了containerd作为容器运行时。在kubeadm.yam文件中也能看到相应的配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodeRegistration:</span><br><span class="line">  criSocket: unix:///var/run/containerd/containerd.sock</span><br></pre></td></tr></table></figure><p>为什么k8s不选用docker engine作为容器运行时？因为如果使用docker engine, 还需要安装cri-dockerd，才能作为容器时被k8s识别。而如上操作并未安装。</p><p>此外，k8s推荐直接使用containerd作为容器运行时。</p><h2><span id="5-初始化工作节点"><strong>5. 初始化工作节点</strong></span></h2><h3><span id="51-运行kubeadm-join将工作节点加入集群"><strong>5.1 运行kubeadm join将工作节点加入集群</strong></span></h3><p>在master节点kubeadm init安装完成后，会有如下类似log</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.. ... </span><br><span class="line">Then you can <span class="built_in">join</span> any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm <span class="built_in">join</span> 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><p>将上述命令粘贴到工作节点，将工作节点添加到集群</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@slave ~]# kubeadm join 192.168.246.133:6443 --token abcdef.0123456789abcdef \</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">        --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span></span><br><span class="line">[preflight] Running pre-flight checks</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot; could not be reached</span><br><span class="line">        [WARNING Hostname]: hostname &quot;slave.k8s&quot;: lookup slave.k8s on 192.168.246.2:53: no such host</span><br><span class="line">[preflight] Reading configuration from the cluster...</span><br><span class="line">[preflight] FYI: You can look at this config file with &#x27;kubectl -n kube-system get cm kubeadm-config -o yaml&#x27;</span><br><span class="line">[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;</span><br><span class="line">[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;</span><br><span class="line">[kubelet-start] Starting the kubelet</span><br><span class="line">[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to apiserver and a response was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#x27;kubectl get nodes&#x27; on the control-plane to see this node join the cluster.</span><br></pre></td></tr></table></figure><h3><span id="52-验证"><strong>5.2 验证</strong></span></h3><p>到master节点运行kubelet get node,可以看到加进来的node</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl get nodes</span><br><span class="line">NAME        STATUS     ROLES           AGE    VERSION</span><br><span class="line">node        NotReady   control-plane   121m   v1.28.2</span><br><span class="line">slave.k8s   NotReady   &lt;none&gt;          28s    v1.28.2</span><br></pre></td></tr></table></figure><p>当前STATUS都是NotReady，这是因为还没有安装网络插件CNI</p><h3><span id="53-忘记token怎么办"><strong>5.3 忘记token怎么办</strong></span></h3><p>如果master节点安装时，没有记录下token，或token超时(默认24小时)，可以运行如下命令重新生成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubeadm token create --print-join-command</span><br><span class="line">kubeadm join 192.168.246.133:6443 --token by8q23.65btteq9iud7ypso --discovery-token-ca-cert-hash sha256:9f7d37c768e658119242dfb49675eaeb3cbdbb7d191526bfa197dd92373b40ab</span><br></pre></td></tr></table></figure><h2><span id="6-安装cni网络插件"><strong>6. 安装CNI网络插件</strong></span></h2><p>Kubernetes 它需要网络插件来提供集群内部和集群外部的网络通信。以下是一些常用的 k8s 网络插件：</p><ul><li>Flannel：Flannel 是最常用的 k8s 网络插件之一，它使用了虚拟网络技术来实现容器之间的通信，支持多种网络后端，如 VXLAN、UDP 和 Host-GW。</li><li>Calico：Calico 是一种基于 BGP 的网络插件，它使用路由表来路由容器之间的流量，支持多种网络拓扑结构，并提供了安全性和网络策略功能。</li><li>Canal：Canal 是一个组合了 Flannel 和 Calico 的网络插件，它使用 Flannel 来提供容器之间的通信，同时使用 Calico 来提供网络策略和安全性功能。</li><li>Weave Net：Weave Net 是一种轻量级的网络插件，它使用虚拟网络技术来为容器提供 IP 地址，并支持多种网络后端，如 VXLAN、UDP 和 TCP&#x2F;IP，同时还提供了网络策略和安全性功能。</li><li>Cilium：Cilium 是一种基于 eBPF (Extended Berkeley Packet Filter) 技术的网络插件，它使用 Linux 内核的动态插件来提供网络功能，如路由、负载均衡、安全性和网络策略等。</li><li>Contiv：Contiv 是一种基于 SDN 技术的网络插件，它提供了多种网络功能，如虚拟网络、网络隔离、负载均衡和安全策略等。</li><li>Antrea：Antrea 是一种基于 OVS (Open vSwitch) 技术的网络插件，它提供了容器之间的通信、网络策略和安全性等功能，还支持多种网络拓扑结构。</li></ul><table><thead><tr><th>提供商</th><th>网络模型</th><th>路线分发</th><th>网络策略</th><th>网格</th><th>外部数据存储</th><th>加密</th><th>Ingress&#x2F;Egress 策略</th></tr></thead><tbody><tr><td>Canal</td><td>封装 (VXLAN)</td><td>否</td><td>是</td><td>否</td><td>K8s API</td><td>是</td><td>是</td></tr><tr><td>Flannel</td><td>封装 (VXLAN)</td><td>否</td><td>否</td><td>否</td><td>K8s API</td><td>是</td><td>否</td></tr><tr><td>Calico</td><td>封装（VXLAN，IPIP）或未封装</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr><tr><td>Weave</td><td>封装</td><td>是</td><td>是</td><td>是</td><td>否</td><td>是</td><td>是</td></tr><tr><td>Cilium</td><td>封装 (VXLAN)</td><td>是</td><td>是</td><td>是</td><td>Etcd 和 K8s API</td><td>是</td><td>是</td></tr></tbody></table><p>Calico 和 Flannel都是常用的CNI，如下介绍如何安装flannel网络插件</p><h3><span id="61-安装flannel网络插件"><strong>6.1 安装flannel网络插件</strong></span></h3><ol><li>下载kube-flannel.yml</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 1. 下载kube-flannel.yml</span></span></span><br><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure><p><code>kube-flannel.yaml</code>文件中，需要注意，net-conf.json里的network要和kubeadm.yaml里配置的networking.podSubnet相同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">  net-conf.json: |</span><br><span class="line">    &#123;</span><br><span class="line">      ### 这里的network和kubeadm.yaml里配置的networking.podSubnet相同 </span><br><span class="line">      &quot;Network&quot;: &quot;10.244.0.0/16&quot;,</span><br><span class="line">      &quot;Backend&quot;: &#123;</span><br><span class="line">        &quot;Type&quot;: &quot;vxlan&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure><ol start="2"><li>容器部署flannel</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[shirley@master k8s_install]$ kubectl apply -f kube-flannel.yml</span><br><span class="line">namespace/kube-flannel created</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds created</span><br></pre></td></tr></table></figure><h3><span id="62-验证cni"><strong>6.2 验证CNI</strong></span></h3><p>安装后，运行<code>kubectl -n kube-system get pod -o wide</code>， 可以看到在master节点和slave节点分别运行了一个kube-proxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 每个节点上都运行了kube-proxy</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl -n kube-system get pod -o wide</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE     IP                NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">coredns-66f779496c-d8rws       1/1     Running   0          4h40m   10.244.0.3        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">coredns-66f779496c-fzmjm       1/1     Running   0          4h40m   10.244.0.2        node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">etcd-node                      1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-apiserver-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-controller-manager-node   1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-bpv8d               1/1     Running   0          160m    192.168.246.132   slave.k8s   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-proxy-kp9kw               1/1     Running   0          4h40m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kube-scheduler-node            1/1     Running   0          4h41m   192.168.246.133   node        &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># node状态显示为Ready</span></span></span><br><span class="line">[shirley@master k8s_install]$ kubectl get node</span><br><span class="line">NAME        STATUS   ROLES           AGE     VERSION</span><br><span class="line">node        Ready    control-plane   4h38m   v1.28.2</span><br><span class="line">slave.k8s   Ready    &lt;none&gt;          158m    v1.28.2</span><br></pre></td></tr></table></figure><p>自此，集群搭建完成。</p><h2><span id="其他说明"><strong>其他说明</strong></span></h2><p>另外，在初始安装的Master节点上也启动了<code>kubelet</code>和<code>kube-proxy</code>，在默认情况下并不参与工作负载的调度。如果希望Master节点也作为Node角色，则可以运行下面的命令（删除Master节点的：<code>node-role.kubernetes.io/control-plane:NoSchedule</code>），让Master节点也成为一个Node：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl taint nodes --all node-role.kubernetes.io/control-plane-</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>k8s-IPVS概念原理以及应用</title>
      <link href="/blog/2024/03/18/tech/devops/k8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/"/>
      <url>/blog/2024/03/18/tech/devops/k8s/K8s-2-IPVS%E6%A6%82%E5%BF%B5%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="ipvs的概念-原理及应用">IPVS的概念、原理及应用</span></h3><h3><span id="一-什么是ipvs">一、什么是IPVS</span></h3><p>LVS（Linux 虚拟服务器）和 IPVS（IP 虚拟服务器）是 Linux 中用于构建可扩展和高性能网络服务的两种相关技术。</p><p>LVS 是 Linux 系统的内核级负载均衡解决方案。 它允许您在多个服务器之间分配传入的网络流量，创建一个服务器集群，在客户端看来就像一个虚拟服务器。 LVS 中的负载均衡算法可以根据各种因素（例如循环法、最少连接数和源 IP 哈希）来分配流量。 </p><h3><span id="二-ipvs的工作原理">二、IPVS的工作原理</span></h3><p>IPVS的工作原理基于网络地址转换（Network Address Translation，NAT）和端口转换（Port Translation）。</p><p>当一个网络请求到达IPVS，IPVS会根据预设的调度算法选择一个后端服务器，然后修改网络请求的目标IP地址和端口，使其指向选择的后端服务器。</p><p>当后端服务器处理完请求后，IPVS会将服务器的响应转发回原始请求的客户端。</p><p>在这个过程中，客户端并不知道实际上是哪个后端服务器处理了它的请求。</p><h3><span id="三-ipvs的主要特性">三、IPVS的主要特性</span></h3><p>丰富的调度算法：IPVS支持多种调度算法，包括最小连接（Least-Connection）、轮询（Round-Robin）和加权轮询（Weighted Round-Robin）等，满足不同应用场景的需求。<br>健康检查：IPVS能够定期对后端服务器进行健康检查，当检测到某个服务器故障时，可以将其从服务列表中移除，防止向故障服务器发送请求。<br>高性能：由于IPVS是Linux内核的一部分，因此处理网络请求的效率非常高。IPVS支持大规模并发连接，能够处理每秒数以万计的网络请求。<br>易于集成：IPVS可以与其他Linux内核模块和用户空间工具一起使用，如iptables和keepalived等，提供更加强大和灵活的网络服务。</p><h3><span id="四-ipvs的应用场景">四、IPVS的应用场景</span></h3><p>IPVS广泛应用于大规模的互联网服务，如网站、在线视频和游戏等，提供高可用性和高性能的网络服务。</p><p>此外，IPVS也在云计算、大数据和容器技术等领域有广泛的应用，例如在Kubernetes中，IPVS作为服务代理的一种模式，为集群内的服务提供负载均衡。</p><p>综上所述，LVS 是 Linux 系统的综合负载均衡解决方案，而 IPVS 是 LVS 中专门处理 IP 负载均衡的组件。 LVS 利用 IPVS 在多个真实服务器之间分发流量，并为各种网络服务提供可扩展性和容错性</p>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-析构函数-destruct</title>
      <link href="/blog/2024/03/12/tech/backend/php/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/"/>
      <url>/blog/2024/03/12/tech/backend/php/PHP-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0-destruct/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>phpStrom 里alt+insert 会出现的一些函数</p></blockquote><h3><span id="析构函数destruct">析构函数destruct</span></h3><p><img src="http://s2-cdn.oneitfarm.com/d7f45961508248afb2f08e0bd137ca9c.png" alt="image.png"></p><p>简单理解：构造函数的对立面<br>构造函数：__construct()在初始化对象的时候默认执行的<br>析构函数：__destruct()在对象销毁回收时候默认执行的，类似于web框架里面的钩子函数</p><p>触发条件 当对象或者变量 消失时候</p><p>关键词：unset或者对象生命周期结束</p><p>phpStrom 里alt+insert 会出现的一些函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">calss A&#123;</span><br><span class="line">    </span><br><span class="line">protected $data = [];</span><br><span class="line"></span><br><span class="line">public function insert($data)</span><br><span class="line">    &#123;</span><br><span class="line">        $data[&#x27;appkey&#x27;] = getAppkey();</span><br><span class="line">        $data[&#x27;channel&#x27;] = getChannel();</span><br><span class="line">        $this-&gt;data[] = $data;</span><br><span class="line">        //这个[]意思在多个多次调用的时候插入整个数组很关键，可以看下面内容 请求中 php 如何分配phpfpm</span><br><span class="line">    &#125;</span><br><span class="line"> public function __destruct()</span><br><span class="line">    &#123;</span><br><span class="line">        if ($this-&gt;data) &#123;</span><br><span class="line">            $this-&gt;getDB()-&gt;insert_batch($this-&gt;table, $this-&gt;data);</span><br><span class="line">            $id = $this-&gt;getDB()-&gt;insert_id();</span><br><span class="line">            Ioc()-&gt;CallRecordModel-&gt;_delete([</span><br><span class="line">                &#x27;id &lt;&#x27; =&gt; $id - 50000</span><br><span class="line">            ], &#x27;&#x27;, 1000);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$zend=new A();</span><br><span class="line">$zend-&gt;insert([&quot;aaaaa&quot;]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-笔记-ArrayMapSlice</title>
      <link href="/blog/2024/03/12/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/"/>
      <url>/blog/2024/03/12/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B03-nil-slice-map/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">### 1. := = ==</span><br><span class="line"></span><br><span class="line">:= 给某变量的第一次赋值，初始化</span><br><span class="line"></span><br><span class="line">= 变量的非第一次赋值</span><br><span class="line"></span><br><span class="line">== 等于操作符</span><br><span class="line"></span><br><span class="line">### 2. go中nil的使用</span><br><span class="line"></span><br><span class="line">指针、切片、映射、通道、函数和接口的零值则是 nil。</span><br><span class="line"></span><br><span class="line">- nil 标识符是不能比较的</span><br><span class="line">- nil 不是关键字或保留字</span><br><span class="line">- nil 没有默认类型</span><br><span class="line">- 不同类型 nil 的指针是一样的</span><br><span class="line">- 不同类型的 nil 是不能比较的</span><br><span class="line">- 两个相同类型的 nil 值也可能无法比较</span><br><span class="line">- nil 是 map、slice、pointer、channel、func、interface 的零值</span><br><span class="line">- 不同类型的 nil 值占用的内存大小可能是不一样的</span><br><span class="line"></span><br><span class="line">### 3.切片 slice</span><br><span class="line"></span><br><span class="line">类似于py或Java的list ,是数组的抽象,支持数组扩容 定义:</span><br><span class="line">slice1 := make([]type, len)</span><br><span class="line"></span><br><span class="line">len 获取长度 cap 获取容量 append(slice1 ,v1,...) copy(new_slice,slice1)</span><br><span class="line"></span><br><span class="line">### 4.集合 map</span><br><span class="line"></span><br><span class="line">map 无序k-v ,快速根据k 找到v,类似于索引,在做循环打印的时候，无法固定返回顺序，因为map 用hash表来实现的</span><br><span class="line"></span><br><span class="line">- 声明变量，默认 map 是 nil var map_val map[key_data_type]value_data_type</span><br><span class="line"></span><br><span class="line">- 使用 make 函数 map_val := make(map[key_data_type]value_data_type)</span><br><span class="line"></span><br><span class="line">### 并发</span><br><span class="line">goroutine </span><br><span class="line">go sync()</span><br><span class="line">### 通道 channel</span><br><span class="line">既然已经有了线程的概念，那么就会存在线程间的同步和通讯问题，Go 使用通道（channel）来实现。</span><br><span class="line"></span><br><span class="line">通道可用于两个 goroutine 之间通过传递一个指定类型的值来同步运行和通讯。使用操作符 &lt;-，符号左边是接收者，右边是发送者。</span><br><span class="line"></span><br><span class="line">使用 make 创建 channel，如下：</span><br><span class="line"></span><br><span class="line">​```</span><br><span class="line">ch := make(chan int, 100) // make 第二个参数 100 是该通道的缓冲区，是一个可选参数，如果不指定，那么就是无缓冲的通道</span><br><span class="line">ch &lt;- v    // 把 v 发送到通道 ch</span><br><span class="line">v := &lt;-ch  // 从 ch 接收数据</span><br><span class="line">// 并把值赋给 v</span><br><span class="line">​```</span><br><span class="line">通道与消息队列是等效的，如果通道缓冲区满，那么再往通道里塞数据，就会阻塞该 goroutine；同样，如果通道缓冲区没有数据了，再次接收通道数据，也会阻塞该 goroutine。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>darp Docs</title>
      <link href="/blog/2022/03/16/tech/devops/darp-Docs/"/>
      <url>/blog/2022/03/16/tech/devops/darp-Docs/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>dapr 文档贡献<br>dapr 文档贡献规则：<a href="https://docs.dapr.io/zh-hans/contributing/contributing-docs/">https://docs.dapr.io/zh-hans/contributing/contributing-docs/</a></p><p>dapr 文档网站使用hugo 开发工具：</p><p>Windows：安装流程<br>安装scoope<br>powerSheel ：执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">set-executionpolicy remotesigned -scope currentuser</span><br><span class="line"></span><br><span class="line">iex (new-object net.webclient).downloadstring(&#x27;https://get.scoop.sh&#x27;)</span><br><span class="line"></span><br><span class="line">执行scoope help 查看是否安装正常</span><br><span class="line"></span><br><span class="line">执行   scoop install hugo</span><br><span class="line">      scoop install hugo-extended</span><br><span class="line">这两部即可 完成对其安装</span><br><span class="line"></span><br><span class="line">文档：https://gohugo.io/getting-started/installing/</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3><span id="1执行doc仓库下载和安装依赖">1.执行doc仓库下载和安装依赖</span></h3><p>仓库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">https://github.com.cnpmjs.org/dapr/docs.git</span><br><span class="line"></span><br><span class="line">执行：</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line">这步可能遇到下载不下来情况，可以按照此步骤进行操作</span><br><span class="line"></span><br><span class="line">1.执行 git submodule update --init</span><br><span class="line">2.去.gitmodules文件 进行编辑将所有的https://github.com  后缀加上 cnpmjs.org</span><br><span class="line">(这个原理可以参考:谷歌插件---GitHub加速1.3.5)</span><br><span class="line">3.然后利用git submodule sync更新子项目对应的url</span><br><span class="line">4.git submodule update --init --recursive，最后执行</span><br><span class="line"></span><br><span class="line">//s2-cdn.oneitfarm.com/6d3518411d074f9eae604f77da39da83.png</span><br></pre></td></tr></table></figure><p><img src="//s2-cdn.oneitfarm.com/a23f2220daff4375ba97522c7edc552c.png"></p><p>错误1.</p><p><img src="//s2-cdn.oneitfarm.com/c036d24abc364f00be0870faec874818.png" alt="image-20220316151455745"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">使用git代理：</span><br><span class="line">git config *--global https.proxy*</span><br><span class="line">执行命令后取消代理</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure><p>错误2：</p><p><img src="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png" alt="//s2-cdn.oneitfarm.com/b933985e39524c7ea6763610f552ecd7.png"></p><p>解决方案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个是因为没有执行git module的 下载</span><br></pre></td></tr></table></figure><h3><span id="2安装依赖">2.安装依赖</span></h3><p>此项目使用的还是npm </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install （很慢） </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dapr </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-grpc-2</title>
      <link href="/blog/2021/12/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B013grpc-2/"/>
      <url>/blog/2021/12/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B013grpc-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>脑图：</p><p><a href="https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5">https://naotu.baidu.com/file/c80e753e20e8ab18a80cb573ac08e912?token=e89e127e95b325d5</a></p><p>服务端的操作：</p><p>取出server</p><p>挂载方法</p><p>注册服务</p><p>创建监听</p><p>客户端：</p><p>创建链接</p><p>new 一个client</p><p>调用client方法</p><p>获取返回值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>x86和arm架构区别</title>
      <link href="/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2021/12/02/%E5%BB%BA%E7%AB%99/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是arm架构">什么是arm架构</span></h3><p>ARM架构过去称之为进阶精简指令集机器，是一个32位的精简指令集（RISC）处理器架构，其广泛的使用在嵌入式系统设计，由于节能的特点，ARM非常适合处理移动通讯领域，符合其设计目标低消耗 电量的特性，在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.</p><p>arm架构图</p><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据&#x2F;地址寄存器组成.</p><p><img src="http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg"></p><p>1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</p><p>2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移&#x2F;右移n位、环移n位和算术右移n位等都可以一次完成。</p><p>3、高速乘法器：乘法器一般采用“加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现“加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1&#x2F;3）。</p><p>4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</p><p>5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</p><p>6、寄存器</p><h2><span id="x86架构"><strong>x86架构</strong></span></h2><p><img src="http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg"></p><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><p>   1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</p><p>　2： 北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</p><p>　3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I&#x2F;O总线较多，离处理器远一点有利于布线。</p><p>　4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p><p>　5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</p><p>　6：显示j接口</p><p>　7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>　8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</p><p>　9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</p><p>　10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</p><p>　11：总线</p><h2><span id="arm架构和x86架构有什么区别"><strong>arm架构和x86架构有什么区别</strong></span></h2><p><strong>一、性能</strong> </p><p>​    X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。</p><p>　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.</p><p><strong>二、扩展能力</strong></p><p>​    X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.</p><p>　　ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行“够用就好”的原则.</p><p> <strong>三、操作系统的兼容性</strong></p><p>​    X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。</p><p>　　ARM系统几乎都采用<strong>Linux</strong>的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的<strong>Android</strong>系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.</p><p><strong>四、软件开发的方便性及可使用工具的多样性</strong></p><p>​    X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。</p><p>　　Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。</p><p>　　对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。</p><p>　　从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：<strong>功耗.</strong></p><p><strong>五、功耗</strong> </p><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>x86和arm架构区别</title>
      <link href="/blog/2021/12/02/tech/devops/site/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2021/12/02/tech/devops/site/x86%E5%92%8Carm%E6%9E%B6%E6%9E%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是arm架构">什么是arm架构</span></h3><p>ARM架构过去称之为进阶精简指令集机器，是一个32位的精简指令集（RISC）处理器架构，其广泛的使用在嵌入式系统设计，由于节能的特点，ARM非常适合处理移动通讯领域，符合其设计目标低消耗 电量的特性，在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列.</p><p>arm架构图</p><p>下图所示的是ARM构架图。它由32位ALU、若干个32位通用寄存器以及状态寄存器、32&TImes;8位乘法器、32&TImes;32位桶形移位寄存器、指令译码以及控制逻辑、指令流水线和数据&#x2F;地址寄存器组成.</p><p><img src="http://file.elecfans.com/web1/M00/50/D9/o4YBAFr7zl2AGVr8AABPkxqzXZA667.jpg"></p><p>1、ALU：它有两个操作数锁存器、加法器、逻辑功能、结果以及零检测逻辑构成。</p><p>2、桶形移位寄存器：ARM采用了32&TImes;32位的桶形移位寄存器，这样可以使在左移&#x2F;右移n位、环移n位和算术右移n位等都可以一次完成。</p><p>3、高速乘法器：乘法器一般采用”加一移位”的方法来实现乘法。ARM为了提高运算速度，则采用两位乘法的方法，根据乘数的2位来实现”加一移位”运算;ARM高速乘法器采用32&TImes;8位的结构，这样，可以降低集成度（其相应芯片面积不到并行乘法器的1&#x2F;3）。</p><p>4、浮点部件：浮点部件是作为选件供ARM构架使用。FPA10浮点加速器是作为协处理方式与ARM相连，并通过协处理指令的解释来执行。</p><p>5、控制器：ARM的控制器采用的是硬接线的可编程逻辑阵列PLA。</p><p>6、寄存器</p><h2><span id="x86架构"><strong>x86架构</strong></span></h2><p><img src="http://file.elecfans.com/web1/M00/50/ED/pIYBAFr7zpSASlXUAABbDZ2xUGo091.jpg"></p><p>当然，这个架构图并不是所有的都是如此，根据不同的主板，平台，架构是略有差别的比如说，目前很多主板已经将北桥集成到CPU当中，将南桥集成为PCH，但大致的框架还是如此的。下面对这个架构图上的各个内容分别进行一些简介:</p><p>   1：CPU，大家都不陌生的名词，中央处理器，计算机的核心大脑。</p><p>　2： 北桥（North Bridge Chipset）：北桥是电脑主板上的一块芯片，位于CPU插座边，起连接作用。</p><p>　3：南桥芯片（South Bridge）是主板芯片组的重要组成部分，一般位于主板上离CPU插槽较远的下方，PCI插槽的附近，这种布局是考虑到它所连接的I&#x2F;O总线较多，离处理器远一点有利于布线。</p><p>　4： 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。</p><p>　5：显卡（Video card，Graphics card）全称显示接口卡，又称显示适配器，是计算机最基本配置、最重要的配件之一。</p><p>　6：显示j接口</p><p>　7：网卡是工作在链路层的网络组件，是局域网中连接计算机和传输介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质访问控制、数据的编码与解码以及数据缓存的功能等。</p><p>　8：声卡的基本功能是把来自话筒、磁带、光盘的原始声音信号加以转换，输出到耳机、扬声器、扩音机、录音机等声响设备，或通过音乐设备数字接口（MIDI）使乐器发出美妙的声音。</p><p>　9：SATA（Serial Advanced Technology Attachment，串行高级技术附件）是一种基于行业标准的串行硬件驱动器接口，是由Intel、IBM、Dell、APT、Maxtor和Seagate公司共同提出的硬盘接口规范。</p><p>　10：硬盘是电脑主要的存储媒介之一，由一个或者多个铝制或者玻璃制的碟片组成。碟片外覆盖有铁磁性材料。</p><p>　11：总线</p><h2><span id="arm架构和x86架构有什么区别"><strong>arm架构和x86架构有什么区别</strong></span></h2><p><strong>一、性能</strong> </p><p>​    X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核大行其道，通常使用45nm（甚至更高级）制程的工艺进行生产；而ARM方面：CPU通常是几百兆，最近才出现1G左右的CPU，制程通常使用不到65nm制程的工艺，可以说在性能和生产工艺方面ARM根本不是X86结构系统的对手。</p><p>　　但ARM的优势不在于性能强大而在于效率，ARM采用RISC流水线指令集，在完成综合性工作方面根本就处于劣势，而在一些任务相对固定的应用场合其优势就能发挥得淋漓尽致.</p><p><strong>二、扩展能力</strong></p><p>​    X86结构的电脑采用”桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且x86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以x86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等.</p><p>　　ARM结构的电脑是通过专用的数据接口使CPU与数据存储设备进行连接，所以ARM的存储、内存等性能扩展难以进行（一般在产品设计时已经定好其内存及数据存储的容量），所以采用ARM结构的系统，一般不考虑扩展。基本奉行”够用就好”的原则.</p><p> <strong>三、操作系统的兼容性</strong></p><p>​    X86系统由微软及Intel构建的Wintel联盟一统天下，垄断了个人电脑操作系统近30年，形成巨大的用户群，也深深固化了众多用户的使用习惯，同时x86系统在硬件和软件开发方面已经形成统一的标准，几乎所有x86硬件平台都可以直接使用微软的视窗系统及现在流行的几乎所有工具软件，所以x86系统在兼容性方面具有无可比拟的优势。</p><p>　　ARM系统几乎都采用<strong>Linux</strong>的操作系统，而且几乎所有的硬件系统都要单独构建自己的系统，与其他系统不能兼容，这也导致其应用软件不能方便移植，这一点一直严重制约了ARM系统的发展和应用。GOOGLE开发了开放式的<strong>Android</strong>系统后，统一了ARM结构电脑的操作系统，使新推出基于ARM结构的电脑系统有了统一的、开放式的、免费的操作系统，为ARM的发展提供了强大的支持和动力.</p><p><strong>四、软件开发的方便性及可使用工具的多样性</strong></p><p>​    X86结构的系统推出已经近30年，在此期间，x86电脑经过飞速发展的黄金时期，用户的应用、软件配套、软件开发工具的配套及兼容等工作，已经到达非常成熟甚至可以说是完美的境界。所以使用X86电脑系统不仅有大量的第三方软件可供选择，也有大量的软件编程工具可以帮助您完成您所希望完成的工作。</p><p>　　Arm结构的电脑系统因为硬件性能的制约、操作系统的精简、以及系统兼容等问题的制约，造成Arm结构的电脑系统不可能像X86电脑系统那样有众多的编程工具和第三方软件可供选择及使用，ARM的编程语言大多采用C和JAVA。</p><p>　　对这一点的比较，更直接的结论是：基于x86结构电脑系统平台开发软件比arm结构系统更容易、更简单、实际成本也更低，同时更容易找到第三方软件（免去自己开发的时间和成本），而且软件移植更容易。</p><p>　　从以上对比分析，给了我们的一个很清晰的感觉，ARM和X86结构的电脑根本就无法对比，ARM根本就不是X86电脑的的对手。是的，如果只考虑上述几个方面的要数，ARM确实无法与X86电脑竞争，甚至连比较的资格都没有。但是近1、2年，ARM的产品在终端应用特别是手持终端应用飞速发展（如：智能手机、平板电脑等），其销售数量已经远远超出x86结构的电脑销售数量，可见ARM是具有其与X86结构电脑不可对比的优势。该优势就是：<strong>功耗.</strong></p><p><strong>五、功耗</strong> </p><p>X86电脑因考虑要适应各种应用的需求，其发展思路是：性能+速度。20多年来x86电脑的速度从原来8088的几M发展到现在随便就是几G，而且还是几核，其速度和性能已经提升了千、万倍，技术进步使x86电脑成为大众生活中不可缺少的一部分。但是x86电脑发展的方向和模式，使其功耗一直居高不下，一台电脑随便就是几百瓦，即使是号称低功耗节能的手提电脑或上网本，也有十几、二十多瓦的功耗，这与ARM结构的电脑就无法相比.</p>]]></content>
      
      
      <categories>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 请求方法之CONNECT method</title>
      <link href="/blog/2021/11/25/tech/network/http/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/"/>
      <url>/blog/2021/11/25/tech/network/http/HTTP-%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95%E4%B9%8BCONNECT-method/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>HTTP1.1 中的connect<br>1.http请求代理就是connect这个方法，connect网页开发中不会使用<br>2.connect的作用将服务器作为代理，让服务器提用户访问其他网页（翻墙），之后将数据返回用户<br>3.connect是将通过TCP代理链接服务器的，假如我想让代理服务器访问，<a href="https://baidu.com网站,首先要简历一条客户端到代理服务器的tcp的链接/">https://baidu.com网站，首先要简历一条客户端到代理服务器的tcp的链接</a><br>然后给代理服务器发送一个http报文</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CONNECT https://www.jianshu.com/u/f67233ce6c0c:80 HTTP/1.1</span><br><span class="line">Host: www.web-tinker.com:80</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Proxy-Authorization: Basic *</span><br><span class="line">Content-Length: 0</span><br></pre></td></tr></table></figure><p>在发送完这个请求之后，代理服务器会响应请求，返回一个200的信息，但这个200并不同于我们平时见到的OK，而是Connection Established</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>弱势文化</title>
      <link href="/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/"/>
      <url>/blog/2021/11/22/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%BC%B1%E5%8A%BF%E6%96%87%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><img src="https://pic1.zhimg.com/v2-bb213c477bc9d02350862acc72395838_720w.jpg?source=3af55fa1" alt="preview"></p><p>知识的快餐：我们为什么要懂点哲学<br>什么是哲学，哲学可不可以理解成为人的认知的差异，哲学里的文化属性到底代表着什么</p><blockquote><p>闲暇产生思辨，思辨消解教条主义和陈腐习俗，发展出敏锐的感知，让人丧失行动的决断。</p><p>思想，在分析迷宫冒险前行，发现社会背后的个体，玻璃其正常的社会功能，转向内在，发现自我</p><p>共同的利益，和共同体的意识衰退，如今没有公民只有个人</p><p>个体通过思索意识到自己本身就是生存的目的，他要求国际从此以往加强而不是利用他的能力，以此为代价，个人将维持国家的持续</p></blockquote><p><strong>社会经济的发展带来的我们物质和生活的增长，被冠以着数十年来通过个体努力的结果，于是国家造就了弱势文化的典型思想:误以为将自己的生活水平的提高，是通过自己勤劳获取的，殊不知这是吃着国家的红利，而并非自己真的可以通过真正的努力获取的温饱</strong></p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-GPM的深入理解</title>
      <link href="/blog/2021/11/18/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B012-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/blog/2021/11/18/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B012-GPM%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>深入golang runtime的调度</p><h3><span id="理解调度器的启动">理解调度器的启动</span></h3><p>runtime：</p><p>scheduler:</p><p>TLS:</p><p>spinning:</p><p>systemstack,mcall,asmcgocall</p><p>主要源码文件:</p><p>调度基本组件：</p><p>**G(goroutine)**：调度器的基本单位，存储的goroutine的执行stack信息，状态以及任务函数</p><p>在g的眼中只有p,p就是运行的G的“CPU”</p><p>相当于两级线程</p><blockquote><p>g的任务函数</p></blockquote><p>每个g的实例都有任务函数，如下代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">userFun:=func()&#123;fmt.Println(&quot;111&quot;)&#125;</span><br><span class="line">go userFunc();</span><br></pre></td></tr></table></figure><p>go的关键词创建了一个goroutine,此时gouroutine的任务函数userFun</p><p><strong>P（processor）</strong></p><p>p表示逻辑processor，代表M执行的上下文</p><p>p的最大作用是拥有各种G的对象队列，链表，cache,和状态</p><p>p的数量也代表go的执行并发度，即多少个goroutine可以同时执行</p><p>这里的p虽然表示逻辑处理器，但是p并不代表任何执行代码，对于g来说，p相当于cpu的核，g只有绑定p才能调度。对于M来说，p提供了执行环境（Context），如分配内存状态（mcache）,任务队列G等</p><p><strong>M(machine)</strong></p><p>M代表真正的执行计算资源，可以任务他就是os thread(系统线程)</p><p>M是真正的执行者，每个M就像一个勤劳的工作者，总是从各种队列找到可运行的G,而且这样的M的可以同时存在多个</p><p>M在绑定有效P，可以进行调度循环，而且M并不保留G状态，这个是g可以跨M调度的基础</p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-纯纯的语法仔的没落</title>
      <link href="/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B09-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/"/>
      <url>/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B09-%E7%BA%AF%E7%BA%AF%E7%9A%84%E8%AF%AD%E6%B3%95%E4%BB%94%E7%9A%84%E6%B2%A1%E8%90%BD/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="基础">基础</span></h2><h3><span id="1-对于已经关闭的channel的处理">1. 对于已经关闭的channel的处理</span></h3><p>读已经关闭的channel，一直能读到东西，但是读到的东西根据通道内关闭前是否有元素而不同，</p><ul><li>关闭前，buffer有还未读取的，会读取到chan内的值，且返回是否读取成功的bool值为true</li><li>关闭前，buffer的值读完，channel元素值为0，bool值为false</li></ul><p>写入：直接panic</p><h3><span id="2-make和new区别">2. Make和new区别</span></h3><p>make：返回特定类型channel，slice,map</p><p>new: 开辟新内存和指针，泛化类型</p><h3><span id="3-nil-切片和空切片一不一样">3. nil 切片和空切片一不一样</span></h3><p>指向的地址不一样。nill引用指针地址为0，空切片执行数组指针地址，且为一个固定值</p><p>数据结构：data,len,cap</p><h3><span id="4-字符串转byte数组会发生内存拷贝吗">4. 字符串转byte数组，会发生内存拷贝吗</span></h3><p>严格来说，只要发生类型强转，都会发生内存拷贝。</p><p>那么go有个很强的包叫 <code>unsafe</code> 。先获取变量地址，字符串转成底层结构，通过unsafe包，转为切片数组,再通过指针指向实际内容</p><p>string 数据结构 {data,len} </p><h3><span id="5-json包变量不加tag会怎么样">5. json包变量不加tag会怎么样</span></h3><p>和key的大小写有关</p><h3><span id="6-gpm">6. GPM</span></h3><p>指向另一篇详细（）</p><h3><span id="7docker-的网络通信模式">7.Docker 的网络通信模式。</span></h3><p>四种：</p><p>1.host模式：和宿主机公用一个network NameSpace 。容器不会配置任何自己网卡，而是使用自己宿主机的IP和端口</p><p>2.container模式：指定和其他容器共享network nameSpace,而不是和宿主机共享</p><p>3.none模式：告诉容器放到自己网站堆里，但是不要配置他的网络</p><p>4.brideg模式：docker默认的网络模式，此模式会将主机docker链接到虚拟网桥上</p><h3><span id="8访问私有成员">8.访问私有成员</span></h3><blockquote><p>调用其他包共有结构的私有成员变<strong>量</strong></p></blockquote><p><strong>绕过小写不公开</strong></p><p>用unsafe包中的unsafe.Pointer获取到结构体对象的首地址，然后加上想访问的私有变量的偏移地址就是私有变量的地址</p><h3><span id="9-数组和切片的区别">9、数组和切片的区别</span></h3><p>长度，容量，数组指针</p><p>切片是指针类型，数组是是值类型</p><p>数据长度固定，切片不固定</p><p>切片比数组多个属性（cap）,切片底层是数组</p><ul><li>扩容：小于1024 每次cap翻倍，超过变成1.25</li><li>扩容后没触及原数组容量，那么切片指针指向的位置，还是原数组，扩容后，超过原数组容量，会开辟一块新内存，原来的值拷贝过来，也不会影响原来数组</li><li>append:</li></ul><h3><span id="10介绍-rune-类型">10.介绍 rune 类型</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">func main() &#123;</span><br><span class="line">    var str = &quot;hello 你好&quot;</span><br><span class="line">    fmt.Println(&quot;len(str):&quot;, len(str))</span><br><span class="line">    //12个 </span><br><span class="line">    //中文字符在unicode下占2个字节，在utf-8编码下占3个字节 go默认utf-8 5+1+3*2</span><br><span class="line">    //通过rune类型处理unicode字符</span><br><span class="line">    fmt.Println(&quot;rune:&quot;, len([]rune(str))) //8个</span><br><span class="line">    fmt.Println(&quot;RuneCountInString:&quot;, utf8.RuneCountInString(str))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>byte等同于uint8，而不是int8</p><p>rune 等同于int32,常用来处理unicode或utf-8字符</p><h3><span id="11-panic-defer-recover">11 panic defer recover</span></h3><p>panic() 函数</p><p>函数中遇到panic语句，会立即终止当前函数的执行，在panic所在函数内如果存在要执行的defer函数列表，按照defer的逆序执行</p><p>recover() 函数</p><p>recover函数的返回值报告协程是否正在遭遇panic</p><p>有异常时，recover()只能调用一次，后面再次调用则捕获不到任何异常</p><p>通常办法：go中可以抛出一个panic的异常，然后在defer中通过recover捕获这个异常，然后正常处理，从而恢复正常代码的执行</p><h3><span id="12-读写锁和互斥锁">12 读写锁和互斥锁</span></h3><p>总结：</p><ol><li>1.在单纯的只是获取锁和释放锁时，互斥锁的用时要少一些，这主要是因为多个线程同时获取读写锁的情况比较少出现。</li><li>golang底层实现上，互斥锁确实要比读写锁的性能要好一些，这主要是因为读写锁的底层实现其实是互斥锁加上计数器</li><li>在 增 强 协 程 互 相 冲 突 的 效 果 后 ， 读 写 锁 的 性 能 要 明 显 高 于 互 斥 锁</li></ol><h3><span id="13结构体是否可以比较">13.结构体是否可以比较</span></h3><p>回到上面的划重点部分，在总结中我们可以知道，golang中 <em>Slice</em>，<em>Map</em>，<em>Function</em> 这三种数据类型是不可以直接比较的。我们再看看S结构体，该结构体并没有包含不可比较的成员变量，所以该结构体是可以直接比较的。</p><p> <em>reflect.DeepEqual 函数</em> 来对两个变量进行比较。</p><h3><span id="14golang-channel是线程安全的吗">14.golang channel是线程安全的吗</span></h3><p>如果把线程安全定义为允许多个goroutine同时去读写，那么golang 的channel 是线程安全的。不需要在并发读写同一个channe时加锁。</p><h3><span id="15channel数据结构">15.channel数据结构</span></h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">    elemsize <span class="type">uint16</span></span><br><span class="line">    closed   <span class="type">uint32</span></span><br><span class="line">    elemtype *_type <span class="comment">// element type</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">    sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock protects all fields in hchan, as well as several</span></span><br><span class="line">    <span class="comment">// fields in sudogs blocked on this channel.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Do not change another G&#x27;s status while holding this lock</span></span><br><span class="line">    <span class="comment">// (in particular, do not ready a G), as this can deadlock</span></span><br><span class="line">    <span class="comment">// with stack shrinking.</span></span><br><span class="line">    lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">    first *sudog</span><br><span class="line">    last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-grpc</title>
      <link href="/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B014grpc/"/>
      <url>/blog/2021/11/17/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B014grpc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>grpc 官网：<a href="https://grpc.io/docs/languages/go/basics/">https://grpc.io/docs/languages/go/basics/</a> 中文翻译版本：<a href="http://doc.oschina.net/grpc?t=56831">http://doc.oschina.net/grpc?t=56831</a></p></blockquote><p>1、下载protobuf的编译器protoc</p><p>地址：</p><p>1、<code>https://github.com/google/protobuf/releases</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window：</span><br><span class="line">  下载: protoc-3.3.0-win32.zip</span><br><span class="line">  解压，把bin目录下的protoc.exe复制到GOPATH/bin下，GOPATH/bin加入环境变量。</span><br><span class="line">当然也可放在其他目录，需加入环境变量，能让系统找到protoc.exe</span><br><span class="line"></span><br><span class="line">linux：</span><br><span class="line">    下载：protoc-3.3.0-linux-x86_64.zip 或 protoc-3.3.0-linux-x86_32.zip</span><br><span class="line">解压，把bin目录下的protoc复制到GOPATH/bin下，GOPATH/bin加入环境变量。</span><br><span class="line">如果喜欢编译安装的，也可下载源码自行安装，最后将可执行文件加入环境变量。</span><br></pre></td></tr></table></figure><p>2、获取protobuf的编译器插件<code>protoc-gen-go</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  进入GOPATH目录</span><br><span class="line">  运行</span><br><span class="line">&gt; go get -u github.com/golang/protobuf/protoc-gen-go</span><br><span class="line">  如果成功，会在GOPATH/bin下生成protoc-gen-go.exe文件</span><br></pre></td></tr></table></figure><p>3、创建一个<code>test.proto</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//指定版本</span><br><span class="line">//注意proto3与proto2的写法有些不同</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"> </span><br><span class="line">//包名，通过protoc生成时go文件时</span><br><span class="line">package test;</span><br><span class="line"> </span><br><span class="line">//手机类型</span><br><span class="line">//枚举类型第一个字段必须为0</span><br><span class="line">enum PhoneType &#123;</span><br><span class="line">    HOME = 0;</span><br><span class="line">    WORK = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//手机</span><br><span class="line">message Phone &#123;</span><br><span class="line">    PhoneType type = 1;</span><br><span class="line">    string number = 2;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//人</span><br><span class="line">message Person &#123;</span><br><span class="line">    //后面的数字表示标识号</span><br><span class="line">    int32 id = 1;</span><br><span class="line">    string name = 2;</span><br><span class="line">    //repeated表示可重复</span><br><span class="line">    //可以有多个手机</span><br><span class="line">    repeated Phone phones = 3;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">//联系簿</span><br><span class="line">message ContactBook &#123;</span><br><span class="line">    repeated Person persons = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行如下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; protoc --go_out=. *.proto</span><br><span class="line">会生成一个test.pb.go的文件，具体的文件内容我就不截图了。</span><br></pre></td></tr></table></figure><p>5、在go语言中使用protobuf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">package main;</span><br><span class="line"> </span><br><span class="line">import (</span><br><span class="line">    &quot;github.com/golang/protobuf/proto&quot;</span><br><span class="line">    &quot;protobuf/test&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line">func write() &#123;</span><br><span class="line">    p1 := &amp;test.Person&#123;</span><br><span class="line">        Id:   1,</span><br><span class="line">        Name: &quot;小张&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;111111111&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;222222222&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    p2 := &amp;test.Person&#123;</span><br><span class="line">        Id:   2,</span><br><span class="line">        Name: &quot;小王&quot;,</span><br><span class="line">        Phones: []*test.Phone&#123;</span><br><span class="line">            &#123;test.PhoneType_HOME, &quot;333333333&quot;&#125;,</span><br><span class="line">            &#123;test.PhoneType_WORK, &quot;444444444&quot;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    //创建地址簿</span><br><span class="line">    book := &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    book.Persons = append(book.Persons, p1);</span><br><span class="line">    book.Persons = append(book.Persons, p2);</span><br><span class="line"> </span><br><span class="line">    //编码数据</span><br><span class="line">    data, _ := proto.Marshal(book);</span><br><span class="line">    //把数据写入文件</span><br><span class="line">    ioutil.WriteFile(&quot;./test.txt&quot;, data, os.ModePerm);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func read() &#123;</span><br><span class="line">    //读取文件数据</span><br><span class="line">    data, _ := ioutil.ReadFile(&quot;./test.txt&quot;);</span><br><span class="line">    book := &amp;test.ContactBook&#123;&#125;;</span><br><span class="line">    //解码数据</span><br><span class="line">    proto.Unmarshal(data, book);</span><br><span class="line">    for _, v := range book.Persons &#123;</span><br><span class="line">        fmt.Println(v.Id, v.Name);</span><br><span class="line">        for _, vv := range v.Phones &#123;</span><br><span class="line">            fmt.Println(vv.Type, vv.Number);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">func main() &#123;</span><br><span class="line">    write();</span><br><span class="line">    read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/5367714-2eb580ad8e2e7a93.png" alt="img"></p><p>image.png</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//go:generate protoc -I ../routeguide --go_out=plugins=grpc:../routeguide ../routeguide/route_guide.proto protoc</span><br></pre></td></tr></table></figure><p><code>-I</code> 参数：指定import路径，可以指定多个-I参数，编译时按顺序查找，不指定时默认查找当前目录</p><p><code>--go_out</code> ：golang编译支持，支持以下参数<br>plugins&#x3D;plugin1+plugin2 - 指定插件，目前只支持grpc，即：plugins&#x3D;grpc</p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>golang里的进程线程携程的调度方式</title>
      <link href="/blog/2021/10/10/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B015-%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/"/>
      <url>/blog/2021/10/10/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B015-%E9%87%8C%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%90%BA%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>找工作本来想靠实力和经验，奈何仍需背面试题，刷算法，可以说是可恶了<br>作者：腾讯技术工程<br>链接：<a href="https://www.zhihu.com/question/20862617/answer/921061289">https://www.zhihu.com/question/20862617/answer/921061289</a><br>来源：知乎</p><h2><span id="goroutine-实现">goroutine 实现:</span></h2><p><img src="https://pic1.zhimg.com/50/v2-5f7f337c089077babfbe296e8a82c88a_720w.jpg?source=1940ef5c" alt="img"></p><p>我们去看调度的一个进化, 从进程到线程再到协程, 其实是一个不断共享, 不断减少切换成本的过程. go 实现的协程为有栈协程, go 协程的用法和线程的用法基本类似. 很多人会疑问, 协程到底是个什么东西? 用户态的调度感觉很陌生, 很抽象, 到底是个什么东西?</p><p>我觉得要理解调度, 要理解两个概念: 运行和阻塞. 特别是在协程中, 这两个概念不容易被正确理解. 我们理解概念时往往会代入自身感受, 觉得线程或协程运行就是像我们吭哧吭哧的处理事情, 线程或协程阻塞就是做事情时我们需要等待其他人. 然后就在这等着了. 要是其他人搞好了, 那我们就继续做当前的事.</p><p>其实主体对象搞错了.正确的理解应该是我们处理事情时就像 CPU, 而不是像线程或者协程. 假如我当前在写某个服务, 发现依赖别人的函数还没有 ready, 那就把写服务这件事放一边. 点开企业微信, 我去和产品沟通一些问题了. 我和产品沟通了一会后, 检查一下, 发现别人已经把依赖的函数提交了, 然后我就最小化企业微信, 切到 IDE, 继续写服务 A 了.</p><p>对操作系统有过一些了解, 知道 linux 下的线程其实是 task_struct 结构, 线程其实并不是真正运行的实体, 线程只是代表一个执行流和其状态.真正运行驱动流程往前的其实是 CPU. CPU 在时钟的驱动下, 根据 PC 寄存器从程序中取指令和操作数, 从 RAM 中取数据, 进行计算, 处理, 跳转, 驱动执行流往前. CPU 并不关注处理的是线程还是协程, 只需要设置 PC 寄存器, 设置栈指针等(这些称为上下文), 那么 CPU 就可以欢快的运行这个线程或者这个协程了.</p><p>线程的运行, 其实是被运行.其阻塞, 其实是切换出调度队列, 不再去调度执行这个执行流. 其他执行流满足其条件, 便会把被移出调度队列的执行流重新放回调度队列.协程同理, 协程其实也是一个数据结构, 记录了要运行什么函数, 运行到哪里了.<br>go 在用户态实现调度, 所以 go 要有代表协程这种执行流的结构体, 也要有保存和恢复上下文的函数, 运行队列. 理解了阻塞的真正含义, 也就知道能够比较容易理解, 为什么 go 的锁, channel 这些不阻塞线程.</p><p>对于实现的同步执行流效果, 又不阻塞线程的网络, 接下来也会介绍.</p><h3><span id="协程结构体和切换函数"><strong>协程结构体和切换函数</strong></span></h3><p><img src="https://pic1.zhimg.com/50/v2-85a56b6e215d2b427ac4f5252ce3c619_720w.jpg?source=1940ef5c" alt="img"></p><p>我们 go 一个 func 时一般这样写</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go func1(arg1 type1,arg2 type2)&#123;....&#125;(a1,a2)</span><br></pre></td></tr></table></figure><p>一个协程代表了一个执行流, 执行流有需要执行的函数(对应上面的 func1), 有函数的入参(a1, a2), 有当前执行流的状态和进度(对应 CPU 的 PC 寄存器和 SP 寄存器), 当然也需要有保存状态的地方, 用于执行流恢复.</p><p>真正代表协程的是 runtime.g 结构体. 每个 go func 都会编译成 runtime.newproc 函数, 最终有一个 runtime.g 对象放入调度队列. 上面的 func1 函数的指针设置在 runtime.g 的 startfunc 字段, 参数会在 newproc 函数里拷贝到 stack 中, sched 用于保存协程切换时的 pc 位置和栈位置.</p><p>协程切换出去和恢复回来需要保存上下文, 恢复上下文, 这些由以下两个汇编函数实现. 以上就能实现协程这种执行流, 并能进行切换和恢复.(下图中的 struct 和函数都做了精简)</p><h3><span id="gm-模型及-gpm-模型"><strong>GM 模型及 GPM 模型</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-836e26770ed9489f835605529e608c37_720w.jpg?source=1940ef5c" alt="img"></p><p>有了协程的这种执行流形式, 那待运行的协程放在哪呢?<br>在 Go1.0 的时候:</p><ol><li>调度队列 schedt 是全局的, 对该队列的操作均需要竞争同一把锁, 导致伸缩性不好.</li><li>新生成的协程也会放入全局的队列, 大概率是被其他 m(可以理解为底层线程的一个表示)运行了, 内存亲和性不好. 当前协程 A 新生成了协程 B, 然后协程 A 比较大概率会结束或者阻塞, 这样 m 直接去执行协程 B, 内存的亲和性也会好很多.</li><li>因为 mcache 与 m 绑定, 在一些应用中(比如文件操作或其他可能会阻塞线程的系统调用比较多), m 的个数可能会远超过活跃的 m 个数, 导致比较大的内存浪费.</li></ol><p>那是不是可以给 m 分配一个队列, 把阻塞的 m 的 mcache 给执行 go 代码的 m 使用? Go 1.1 及以后就是这样做的.</p><p><img src="https://pic1.zhimg.com/50/v2-a06db1f245421b17c64d7bc4f338b71e_720w.jpg?source=1940ef5c" alt="img"></p><p>再 1.1 中调度模型更改为 GPM 模型, 引入逻辑 Process 的概念, 表示执行 Go 代码所需要的资源, 同时也是执行 Go 代码的最大的并行度.</p><p>这个概念可能很多人不知道怎么理解. P 涉及到几点, 队列和 mcache, 还有 P 的个数的选取.</p><p>首先为什么把全局队列打散, 以及 mcache 为什么跟随 P, 这个在 GM 模型那一页就讲的比较清楚了.然后为什么 P 的个数默认是 CPU 核数: Go 尽量提升性能, 那么在一个 n 核机器上, 如何能够最大利用 CPU 性能呢? 当然是同时有 n 个线程在并行运行中, 把 CPU 喂饱, 即所有核上一直都有代码在运行.</p><p>在 go 里面, 一个协程运行到阻塞系统调用, 那么这个协程和运行它的线程 m, 自然是不再需要 CPU 的, 也不需要分配 go 层面的内存. 只有一直在并行运行的 go 代码才需要这些资源, 即同时有 n 个 go 协程在并行执行, 那么就能最大的利用 CPU, 这个时候需要的 P 的个数就是 CPU 核数. (注意并行和并发的区别)</p><h2><span id="协程状态及流转"><strong>协程状态及流转</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-95c62d2ff20b8a75e0ec2eddddaf4bd2_720w.jpg?source=1940ef5c" alt="img"></p><p>协程的状态其实和线程状态类似,状态转换和发生状态转换的时机如图所示. 还是需要注意: 协程只是一个执行流, 并不是运行实体.</p><h2><span id="调度"><strong>调度</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-0328b09cc3dd5537bd463e10ef17db6e_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有一个一直在运行调度的调度器实体. 当一个协程切换出去或新生成的 m, go 的运行时从 stw 中恢复等情况时, 那么接下来就需要发生调度. go 的调度是通过线程(m)执行 runtime.schedule 函数来完成的.</p><h2><span id="sysmon-协程"><strong>sysmon 协程</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-28f751cb1c56fcc275bc545d7f82d869_720w.jpg?source=1940ef5c" alt="img"></p><p>在 linux 内核中有一些执行定时任务的线程, 比如定时写回脏页的 pdflush, 定期回收内存的 kswapd0, 以及每个 cpu 上都有一个负责负载均衡的 migration 线程等.在 go 运行时中也有类似的协程, sysmon.功能比较多: 定时从 netpoll 中获取 ready 的协程, 进行抢占, 定时 GC,打印调度信息,归还内存等定时任务.</p><h2><span id="协作式抢占"><strong>协作式抢占</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-d8baadb9a783032443d3d2fd6b0b5227_720w.jpg?source=1940ef5c" alt="img"></p><p>go 目前(1.12)还没有实现非协作的抢占. 基本流程是 sysmon 协程标记某个协程运行过久, 需要切换出去, 该协程在运行函数时会检查栈标记, 然后进行切换.</p><h2><span id="同步执行流不阻塞线程的网络的实现"><strong>同步执行流不阻塞线程的网络的实现</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-7bed4181eb6bbcba7be4a6b43a604c3e_720w.jpg?source=1940ef5c" alt="img"></p><p>go 写后台最舒服的就是能够以同步写代码的方式操作网络, 但是网络操作不阻塞线程.主要是结合了非阻塞的 fd, epoll 以及协程的切换和恢复.linux 提供了网络 fd 的非阻塞模式, 对于没有 ready 的非阻塞 fd 执行网络操作时, linux 内核不阻塞线程, 会直接返回 EAGAIN, 这个时候将协程状态设置为 wait, 然后 m 去调度其他协程.</p><p>go 在初始化一个网络 fd 的时候, 就会把这个 fd 使用 epollctl 加入到全局的 epoll 节点中. 同时放入 epoll 中的还有 polldesc 的指针.</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func netpollopen(fd uintptr, pd *pollDesc) int32 &#123;</span><br><span class="line">    var ev epollevent</span><br><span class="line">    ev.events = _EPOLLIN | _EPOLLOUT | _EPOLLRDHUP | _EPOLLET</span><br><span class="line">    *(**pollDesc)(unsafe.Pointer(&amp;ev.data)) = pd</span><br><span class="line">    return -epollctl(epfd, _EPOLL_CTL_ADD, int32(fd), &amp;ev)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sysmon 中, schedule 函数中, start the world 中等情况下, 会执行 netpoll 调用 epollwait 系统调用, 把 ready 的网络事件从 epoll 中取出来, 每个网络事件可以通过前面传入的 polldesc 获取到阻塞在其上的协程, 以此恢复协程为 runnable.</p><h2><span id="调度相关结构体"><strong>调度相关结构体</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-85359486219d4ce31b93fa450b592083_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="调度综述"><strong>调度综述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7f7ea37737a8e4ac2809a8122ba62c1c_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic1.zhimg.com/50/v2-8d5f447993ab105b88eac9fb827b2a3c_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="内存分配"><strong>内存分配</strong></span></h2><h2><span id="内存分配简介"><strong>内存分配简介</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-eb6d4ba5968ebe8a0a86318c2ef35ca6_720w.jpg?source=1940ef5c" alt="img"></p><p>Go 的分配采用了类似 tcmalloc 的结构.特点: 使用一小块一小块的连续内存页, 进行分配某个范围大小的内存需求. 比如某个连续 8KB 专门用于分配 17-24 字节,以此减少内存碎片. 线程拥有一定的 cache, 可用于无锁分配.</p><p>同时 Go 对于 GC 后回收的内存页, 并不是马上归还给操作系统, 而是会延迟归还, 用于满足未来的内存需求.</p><h2><span id="内存空间结构"><strong>内存空间结构</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-c1b2977bf1d33669bb9c2774c7b6d8d8_720w.jpg?source=1940ef5c" alt="img"></p><p>在 1.10 以前 go 的堆地址空间是线性连续扩展的, 比如在 1.10(linux amd64)中, 最大可扩展到 512GB. 因为 go 在 gc 的时候会根据拿到的指针地址来判断是否位于 go 的 heap 的, 以及找到其对应的 span, 其判断机制需要 gc heap 是连续的. 但是连续扩展有个问题, cgo 中的代码(尤其是 32 位系统上)可能会占用未来会用于 go heap 的内存. 这样在扩展 go heap 时, mmap 出现不连续的地址, 导致运行时 throw.</p><p>在 1.11 中, 改用了稀疏索引的方式来管理整体的内存. 可以超过 512G 内存, 也可以允许内存空间扩展时不连续.在全局的 mheap struct 中有个 arenas 二阶数组, 在 linux amd64 上,一阶只有一个 slot, 二阶有 4M 个 slot, 每个 slot 指向一个 heapArena 结构, 每个 heapArena 结构可以管理 64M 内存, 所以在新的版本中, go 可以管理 4M*64M&#x3D;256TB 内存, 即目前 64 位机器中 48bit 的寻址总线全部 256TB 内存.</p><h2><span id="span-机制"><strong>span 机制</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-84e72feda2d2cd49aaad59bb6f72837c_720w.jpg?source=1940ef5c" alt="img"></p><p>前面提到了 go 的内存分配类似于 tcmalloc, 采用了 span 机制来减少内存碎片. 每个 span 管理 8KB 整数倍的内存, 用于分配一定范围的内存需求.</p><h2><span id="内存分配全景"><strong>内存分配全景</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-11756712c78ee841873eb9aa22198f3c_720w.jpg?source=1940ef5c" alt="img"></p><p>多层次的分配 Cache, 每个 P 上有一个 mcache, mcache 会为每个 size 最多缓存一个 span, 用于无锁分配. 全局每个 size 的 span 都有一个 mcentral, 锁的粒度相对于全局的 heap 小很多, 每个 mcentral 可以看成是每个 size 的 span 的一个全局后备 cache.</p><p>在 gc 完成后, 会把 P 中的 span 都 flush 到 mcentral 中, 用于清扫后再分配. P 有需要 span 时, 从对应 size 的 mcentral 获取. 获取不到再上升到全局的 heap.</p><h2><span id="几种特殊的分配器"><strong>几种特殊的分配器</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-e35ffea692133cbe86898cdf3eb55352_720w.jpg?source=1940ef5c" alt="img"></p><p>对于很小的对象分配, go 做了个优化, 把小对象合并, 以移动指针的方式分配.对于栈内存有 stackcache 分配, 也有多个层次的分配, 同时 stack 也有多个不同 size. 用于分配 stack 的内存也是位于 go gc heap, 用 mspan 管理, 不过这个 span 的状态和用于分配对象的 mspan 状态不太一样, 为 mSpanManual.</p><p>我们可以思考一个问题, go 的对象是分配在 go gc heap 中, 并由 mcache, mspan, mcentral 这些结构管理, 那么 mcache, mspan, mcentral 这些结构又是哪里管理和分配的呢? 肯定不是自己管理自己. 这些都是由特殊的分配 fixalloc 分配的, 每种类型有一个 fixalloc, 大致原理就是通过 mmap 从进程空间获取一小块内存(百 KB 的样子), 然后用来分配这个固定大小的结构.</p><h2><span id="内存分配综合"><strong>内存分配综合</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-1a3d04db061c92d10bed0e5ab0df1c16_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc"><strong>GC</strong></span></h2><h2><span id="golang-gc-简述"><strong>Golang GC 简述</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-7eb346f748153072b454b9b78759e067_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="gc-简介"><strong>GC 简介</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-ecebbf99b365d076f7076b31a30fc3e8_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 并不是个新事物, 使得 GC 大放光彩的是 Java 语言.</p><p><img src="https://pica.zhimg.com/50/v2-05266f76d410fe9d90fd1dbd23570953_720w.jpg?source=1940ef5c" alt="img"></p><p><img src="https://pic3.zhimg.com/50/v2-291b501f005c3958111daf30bcec1a2b_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="golang-gc-发展"><strong>Golang GC 发展</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-558037836bb253c0777a4a822516d27e_720w.jpg?source=1940ef5c" alt="img"></p><p>上面是几个比较重要的版本.左图是根据 twitter 工程师的数据绘制的(堆比较大), 从 1.4 的百 ms 级别的停顿到 1.8 以后的小于 1ms.右图是我对线上服务(Go 1.11 编译)测试的一个结果, 是一个批量拉取数据的服务, 大概 3000qps, 服务中发起的 rpc 调用大概在 2w&#x2F;s. 可以看到大部分情况下 GC 停顿小于 1ms, 偶尔超过一点点.</p><p>整体来说 golang gc 用起来是很舒心的, 几乎不用你关心.</p><h2><span id="三色标记"><strong>三色标记</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-652acc8ca5d0f04c455c68d1084cd309_720w.jpg?source=1940ef5c" alt="img"></p><p>go 采用的是并发三色标记清除法. 图展示的是一个简单的原理.有几个问题可以思考一下:</p><ul><li>并发情况下, 会不会漏标记对象?</li><li>对象的三色状态存放在哪?</li><li>如何根据一个对象来找到它引用的对象?</li></ul><h3><span id="写屏障"><strong>写屏障</strong></span></h3><p><img src="https://pic3.zhimg.com/50/v2-8c43a67a0eba214a81f56c873504c884_720w.jpg?source=1940ef5c" alt="img"></p><p>GC 最基本的就是正确性: 不漏标记对象, 程序还在用的对象都被清除了, 那程序就错误了. 有一点浮动垃圾是允许的.<br>在并发情况下, 如果没有一些措施来保障, 那可能会有什么问题呢?</p><p>看左边的代码和图示, 第 2 步标记完 A 对象, A 又没有引用对象, 那 A 变成黑色对象. 在第 3 步的时候, muator(程序)运行, 把对象 C 从 B 转到了 A, 第 4 步, GC 继续标记, 扫描 B, 此时 B 没有引用对象, 变成了黑色对象. 我们会发现 C 对象被漏标记了.</p><p>如何解决这个问题? go 使用了写屏障, 这里的写屏障是指由编译器生成的一小段代码. 在 gc 时对指针操作前执行的一小段代码, 和 CPU 中维护内存一致性的写屏障不太一样哈.所以有了写屏障后, 第 3 步, A.obj&#x3D;C 时, 会把 C 加入写屏障 buf. 最终还是会被扫描的.</p><p><img src="https://pic3.zhimg.com/50/v2-69b05d315557f599251e091a0d4a00d9_720w.jpg?source=1940ef5c" alt="img"></p><p>这里感受一下写屏障具体生成的代码. 我们可以看到在写入指针 slot 时, 对写屏障是否开启做了判断, 如果开启了, 会跳转到写屏障函数, 执行加入写屏障 buf 的逻辑. 1.8 中写屏障由 Dijkstra 写屏障改成了混合式写屏障, 使得 GC 停顿达到了 1ms 以下.</p><h3><span id="三色状态"><strong>三色状态</strong></span></h3><p><img src="https://pic2.zhimg.com/50/v2-4dd9c75a72c82eaf3690386dcf286cdb_720w.jpg?source=1940ef5c" alt="img"></p><p>并没有这样一个集合把不同状态对象放到对应集合中. 只是一个逻辑上的意义.</p><h3><span id="扫描和元信息"><strong>扫描和元信息</strong></span></h3><p><img src="https://pica.zhimg.com/50/v2-ee14e9737cbb929bc95ec3af883e5474_720w.jpg?source=1940ef5c" alt="img"></p><p>gc 拿到一个指针, 如何把这个指针指向的对象其引用的子对象都加到扫描队列呢? 而且 go 还允许内部指针, 似乎更麻烦了. 我们分析一下, 要知道对象引用的子对象, 从对象开始到对象结尾, 把对象那一块内存上是指针的放到扫描队列就好了. 那我们是不是得知道对象有多大, 从哪开始到哪结束, 同时要知道内存上的 8 个字节, 哪里是指针, 哪里是普通的数据.</p><p>首先 go 的对象是 mspan 管理的, 我们如果能知道对象属于哪个 mspan, 就知道对象多大, 从哪开始, 到哪结束了. 前面我们讲到了 areans 结构, 可以通过指针加上一定得偏移量, 就知道属于哪个 heap arean 64M 块. 再通过对 64M 求余, 结合 spans 数组, 即可知道属于哪个 mspan 了.</p><p>结合 heapArean 的 bitmap 和每 8 个字节在 heapArean 中的偏移, 就可知道对象每 8 个字节是指针还是普通数据(这里的 bitmap 是在分配对象时根据 type 信息就设置了, type 信息来源于编译器生成)</p><h2><span id="gc-流程"><strong>GC 流程</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-e0eef1afbfa873db4b0faa21a4741c5f_720w.jpg?source=1940ef5c" alt="img"></p><p>1.5 和 1.12 的 GC 大致流程相同. 上图是 golang 官方的 ppt 里的图, 下图是我根据 1.12 源码绘制的.从最坏可能会有百 ms 的 gc 停顿到能够稳定在 1ms 以下, 这之间 GC 做了很多改进. 右边是我根据官方 issues 整理的一些比较重要的改进. 1.6 的分布式检测, 1.7 将栈收缩放到了并发扫描阶段, 1.8 的混合写屏障, 1.12 更改了 mark termination 检测算法, mcache flush 移除出 mark termination 等等.</p><h2><span id="golang-gc-pacer"><strong>Golang GC Pacer</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-e5d325ee3dbdf9b2911520651798a872_720w.jpg?source=1940ef5c" alt="img"></p><p>大家对并发 GC 除了怎么保证不漏指针有疑问外, 可能还会疑问, 并发 GC 如何保证能够跟得上应用程序的分配速度? 会不会分配太快了, GC 完全跟不上, 然后 OOM?</p><p>这个就是 Golang GC Pacer 的作用.</p><p>Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例. 由 GOGC 控制, 默认 100, 即 2 倍的关系, 200 就是 3 倍, 以此类推.</p><p>假如上一次 GC 完成时, 存活对象 1000M, 默认 GOGC 100, 那么下次 GC 会在比较接近但小于 2000M 的时候(比如 1900M)开始, 争取在堆大小达到 2000M 的时候结束. 这之间留有一定的裕度, 会计算待扫描对象大小(根据历史数据计算)与可分配的裕度的比例, 应用程序分配内存根据该比例进行辅助 GC, 如果应用程序分配太快了, 导致 credit 不够, 那么会被阻塞, 直到后台的 mark 跟上来了,该比例会随着 GC 进行不断调整.</p><p>GC 结束后, 会根据这一次 GC 的情况来进行负反馈计算, 计算下一次 GC 开始的阈值.</p><p>如何保证按时完成 GC 呢? GC 完了后, 所有的 mspan 都需要 sweep, 类似于 GC 的比例, 从 GC 结束到下一次 GC 开始之间有一定的堆分配裕度, 会根据还有多少的内存需要清扫, 来计算分配内存时需要清扫的 span 数这样的一个比例.</p><p><img src="https://pic2.zhimg.com/50/v2-92218cc498cc9ae159ba9e95df29f4c9_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="实践与总结"><strong>实践与总结</strong></span></h2><h2><span id="观察调度"><strong>观察调度</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-78cd3a12e7aecf54c56eabca2c879f78_720w.jpg?source=1940ef5c" alt="img"></p><p>观察一下调度, 加一些请求. 我们可以看到虽然有 1000 个连接, 但是 go 只用了几个线程就能处理了, 表明 go 的网络的确是由 epoll 管理的. runqueue 表示的是全局队列待运行协程数量, 后面的数字表示每个 P 上的待运行协程数. 可以看到待处理的任务并没有增加, 表示虽然请求很多, 但完全能 hold 住.</p><p>同时可以看到, 不同 P 上有的时候可能任务不均衡, 但是一会后, 任务又均衡了, 表示 go 的 work stealing 是有效的.</p><h2><span id="观察-gc"><strong>观察 GC</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-596836ab3923ed21c32a4a961264d7d8_720w.jpg?source=1940ef5c" alt="img"></p><p>其中一些数据的含义, 在分享的时候没有怎么解释, 不过网上的解释几乎没有能完全解释正确. 我这里敲一下.<br>其实一般关注堆大小和两个 stw 的 wall time 即可.</p><p>gc 8913(第 8913 次 gc) @2163.341s(在程序运行的第 2163s) 1%(gc 所有 work 消耗的历史累计 CPU 比例, 所以其实这个数据没太大意义) 0.13(第一个 stw 的 wall time)+14(并发 mark 的 wall time)+0.20(第二个 stw 的 wall time) ms clock, 1.1(第一个 stw 消耗的 CPU 时间)+21(用户程序辅助扫描消耗的 cpu 时间)&#x2F;22(分配用于 mark 的 P 消耗的 cpu 时间)&#x2F;0(空闲的 P 用于 mark 的 cpu 时间)+1.6ms(第 2 个 stw 的 cpu 时间) cpu, 147(gc 开始时的堆大小)-&gt;149(gc 结束的堆大小)-&gt;75MB(gc 结束时的存活堆大小), 151 MB goal(本次 gc 预计结束的堆大小), 8P(8 个 P).</p><h2><span id="优化"><strong>优化</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-dd28c6e140bbcd27d737f61e980b562b_720w.jpg?source=1940ef5c" alt="img"></p><p>个人建议, 没事不要总想着优化, 好好 curd 就好.</p><p><img src="https://pica.zhimg.com/50/v2-2e0bbec8ffca844876195af2e970e8a6_720w.jpg?source=1940ef5c" alt="img"></p><p>当然还是有一些优化方法的.</p><h2><span id="一点实践"><strong>一点实践</strong></span></h2><p><img src="https://pica.zhimg.com/50/v2-827fe7197304383f74f774d3c23d8df7_720w.jpg?source=1940ef5c" alt="img"></p><p>我们将 pprof 的开启集成到模板中, 并自动选择端口, 并集成了 gops 工具, 方便查询 runtime 信息, 同时在浏览器上可直接点击生成火焰图, pprof 图, 非常的方便, 也不需要使用者关心.</p><h2><span id="问题排查的一点思路"><strong>问题排查的一点思路</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-eb8dc800c3390a55be87d142cee862f2_720w.jpg?source=1940ef5c" alt="img"></p><h2><span id="一次有意思的问题排查"><strong>一次有意思的问题排查</strong></span></h2><p><img src="https://pic2.zhimg.com/50/v2-8360b4e634560ca5ac314b7b76181b98_720w.jpg?source=1940ef5c" alt="img"></p><p>负载, 依赖服务都很正常, CPU 利用率也不高, 请求也不多, 就是有很多超时.</p><p><img src="https://pic1.zhimg.com/50/v2-8a0e06b128b6f2316d8462b9dbc30e0b_720w.jpg?source=1940ef5c" alt="img"></p><p>该服务在线上打印了 debug 日志, 因为早期的服务模板开启了 gctrace, 框架把 stdout 重定向到一个文件了. 而输出 gctrace 时本来是到 console 的, 输出到文件了, 而磁盘跟不上, 导致 gctrace 日志被阻塞了.</p><p>这里更正一下 ppt 中的内容, 并不是因为 gc 没完成而导致其他协程不能运行, 而是后续 gc 无法开启, 导致实质上的 stw.<br>打印 gc trace 日志时, 已经 start the world 了, 其他协程可以开始运行了. 但是在打印 gctrace 日志时, 还保持着开启 gc 需要的锁, 所以, 打印 gc trace 日志一直没完成, 而 gc 又比较频繁, 比如 0.1s 一次, 这样会导致下一次 gc 开始时无法获取锁, 每一个进入 gc 检查的 p 阻塞, 实际上就造成了 stw.</p><h2><span id="runtime-的一点个人总结"><strong>Runtime 的一点个人总结</strong></span></h2><p><img src="https://pic3.zhimg.com/50/v2-2c598eec44a5909786868950c5224a6c_720w.jpg?source=1940ef5c" alt="img"></p><p>并行, 纵向多层次, 横向多个 class, 缓存, 缓冲, 均衡.</p><h2><span id="参考文档"><strong>参考文档</strong></span></h2><p><img src="https://pic1.zhimg.com/50/v2-406faead2e6957e16a50c5b42f58053a_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>本文完整 PPT 可点击下方图片获得。</strong></p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发空间使用文档</title>
      <link href="/blog/2021/09/01/other/wiki/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/"/>
      <url>/blog/2021/09/01/other/wiki/%E5%BC%80%E5%8F%91%E7%A9%BA%E9%97%B4%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="开发空间使用文档">开发空间使用文档</span></h2><h3><span id="项目设置">项目设置</span></h3><h4><span id="项目主页">项目主页</span></h4><p>项目名称：默认创建的时候的名称，可以在这里修改</p><p>封面：项目的封面，可以用来发布，图片尺寸符合页面提示内容</p><p>简介：项目的一些简单介绍</p><h4><span id="代码仓库">代码仓库</span></h4><p>代码仓库默认分为语言类型的git仓库，所带有的框架默认支持打包，和支持中台的基本框架</p><p>前端仓库：vue idg等</p><p>后端仓库：golang java php node 等 </p><p>ios,android,中台小程序，微信小程序，h5，浏览器插件，pc，跨段应用，</p><p>勤务仓库，和区块链专用仓库，并支持复制其他仓库</p><h5><span id="仓库使用">仓库使用：</span></h5><p>默认开发者为主master分支管理员</p><p>分支:</p><p>合并请求：可以合并其他用户提交的合并请求</p><p>标签：利用此标签可以用来打包集成各类型的资产包和镜像</p><p>成员：可以添加成员</p><h4><span id="镜像管理">镜像管理</span></h4><p>可以分为两大类：镜像（可以直接放在服务器运行的）包管理（可以支持其他服务引入的）</p><p>镜像根据仓库类型里的tag然后进行打包：</p><p>包括：php(5-*7)类型，golang(13-15)java 和其他类型打包 vue类型镜像</p><p>包根据仓库里的tag进行打包：</p><p>包括:npm android ios composer h5等类型dab</p><h4><span id="成员管理">成员管理</span></h4><p>此处用来添加用户，其中项目成员基本权限要有：项目负责人或者项目参与者。支持批量添加用户角色</p><h4><span id="部署设置">部署设置</span></h4><p>b部署设置放在此处比较早，需要后端或者项目负责人添加。</p><p>其中包括：对项目所需要的容器资源类型进行配置，和资源模板配置，cpu membery port 等</p><h3><span id="产品定义">产品定义</span></h3><ul><li>模块列表：默认有主模块。主模块权限属于第一个使用产品定义的人，并非创建者。</li></ul><p>可以选择新增模块，填写模块名称和描述，模块标签</p><p>模块之间支持的功能：利用密钥来实现复制（内容复制）和分享（通道分享）</p><p>模块之间可以添加用户，给用户赋予模块负责人、模块参与者（只有浏览权限）</p><ul><li><p>任务列表：</p><p>包括产品、后端、设计使用的基本工具和文档</p><p>需求定义：产品需要写的一些基本功能提供。项目创立之初的一些信息收集，和基本的作图，设计用例，数据模型等功能的支持</p><p>设计文档：一些基本的设计图片文稿，竞品分析，设计用的图片且支持图片拖动执行</p><p>技术定义：后端的一些基本api文档填写</p><p>数据定义：数据库相关的基本使用</p><p>每个分类下分为各种的类型使用，种类繁多，满足项目创立之初所有的使用</p></li></ul><h3><span id="多语言管理">多语言管理</span></h3><h4><span id="项目多语言">项目多语言</span></h4><p>支撑项目内关键词，各个国家语言的翻译使用</p><h3><span id="会议记录">会议记录</span></h3><p>记录项目成员每次开会使用的基本任务</p><h3><span id="接入管理">接入管理</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="资源管理">资源管理</span></h3><p>容器云所需的资源购买和资源配置</p><h3><span id="部署空间">部署空间</span></h3><p>中台核心内容：支持开发者创建开发容器，支持实例数据填写ACL权限管控，支持用户购买</p><h3><span id="项目管理">项目管理</span></h3><p>项目issue配置</p><h3><span id="cicd">CICD</span></h3><p>项目自动化测试</p><h3><span id="发布管理">发布管理</span></h3><p>项目发布到市场</p><h3><span id="gui管理">GUI管理</span></h3><p>gui前端界面自动化添加</p><h3><span id="wiki">WIKI</span></h3><p>项目Wiki记录</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GOLGANG-笔记6-学习日志位运算符</title>
      <link href="/blog/2021/08/27/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/blog/2021/08/27/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B06-%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>位运算：位运算符对整数在内存中的二进制位进行操作。</p><p> &amp;, |, 和 ^ </p><p>》》》 《《《</p><p>数组</p><p>var a 【5】string</p><p>a:&#x3D;[5]string[“2”,”3”,”4”,”2”,”3”]</p><p>a:&#x3D;[….]string[“2”,”3”,”4”,”2”,”3”]</p><p>空指针：指针定义后没有分配到任何变量就会错</p><p>旧的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  topocpzejlq4huin6cmhieqxxn8fep7n  263</p><p>新的：</p><p>uh49y8vwmxp5rsiqthfjm62ynxbajofc  edc8af2cfdaf438e9e1dc301234e13b9  747  opygwmeutz6kt15umavlwyrcjqqok0ni  8191a23b9783477599b9f01f53f5bab7 37</p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础-转义字符</title>
      <link href="/blog/2021/06/22/other/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/"/>
      <url>/blog/2021/06/22/other/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="什么是转义字符有什么用">什么是转义字符？有什么用？</span></h3><p>转义字符是一种特殊的字符常量</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 转义字符 </tag>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式-修饰符</title>
      <link href="/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
      <url>/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ul><li><p>标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。</p></li><li><p>标记不写在正则表达式里，标记位于表达式之外</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/pattern/flags</span><br></pre></td></tr></table></figure></li></ul><table><thead><tr><th align="left">修饰符</th><th align="left">含义</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">i</td><td align="left">ignore - 不区分大小写</td><td align="left">将匹配设置为不区分大小写，搜索时不区分大小写: A 和 a 没有区别。</td></tr><tr><td align="left">g</td><td align="left">global - 全局匹配</td><td align="left">查找所有的匹配项。</td></tr><tr><td align="left">m</td><td align="left">multi line - 多行匹配</td><td align="left">使边界字符 <strong>^</strong> 和 <strong>$</strong> 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。</td></tr><tr><td align="left">s</td><td align="left">特殊字符圆点 <strong>.</strong> 中包含换行符 <strong>\n</strong></td><td align="left">默认情况下的圆点 <strong>.</strong> 是 匹配除换行符 <strong>\n</strong> 之外的任何字符，加上 <strong>s</strong> 修饰符之后, <strong>.</strong> 中包含换行符 \n。</td></tr></tbody></table><h4><span id="元字符">元字符</span></h4><h4><span id="运算符优先级">运算符优先级</span></h4><p>正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。</p><p>相同优先级的从左到右进行运算，不同优先级的运算先高后低。下表从最高到最低说明了各种正则表达式运算符的优先级顺序：</p><table><thead><tr><th align="left">运算符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">转义符</td></tr><tr><td align="left">(), (?:), (?&#x3D;), []</td><td align="left">圆括号和方括号</td></tr><tr><td align="left">*, +, ?, {n}, {n,}, {n,m}</td><td align="left">限定符</td></tr><tr><td align="left">^, $, \任何元字符、任何字符</td><td align="left">定位点和序列（即：位置和顺序）</td></tr><tr><td align="left">|</td><td align="left">替换，”或”操作 字符具有高于替换运算符的优先级，使得”m|food”匹配”m”或”food”。若要匹配”mood”或”food”，请使用括号创建子表达式，从而产生”(m|f)ood”。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式-语法</title>
      <link href="/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/"/>
      <url>/blog/2021/06/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md</a></p><h4><span id="1普通字符1-9-a-z-a-z-标点符号和一些其他符号">1.普通字符：1-9 a-z A-Z 标点符号和一些其他符号。</span></h4><p><img src="//s2-cdn.oneitfarm.com/eab92d4dcdab496abde257a6adf121c8.png"></p><table><thead><tr><th>key</th><th>val</th><th>desc</th><th>exp</th></tr></thead><tbody><tr><td>&#x2F;*&#x2F;</td><td></td><td>基础语法区隔，转义符号</td><td></td></tr><tr><td>^</td><td></td><td>开始位置</td><td></td></tr><tr><td>$</td><td></td><td>结束位置</td><td></td></tr><tr><td>[0-9]</td><td></td><td>匹配数字</td><td></td></tr><tr><td>[a-z]</td><td></td><td>小写字母</td><td></td></tr><tr><td>[A-Z]</td><td></td><td>大写字母</td><td></td></tr><tr><td>+</td><td>runoo+b</td><td>匹配一个或多个</td><td></td></tr><tr><td>-</td><td></td><td>连接字符</td><td></td></tr><tr><td>{}</td><td>{3,5}</td><td>字符长度3-5</td><td>^[a-z0-9_-]{3,15}$</td></tr><tr><td>？</td><td>colou?r</td><td>匹配 color 或者 colour</td><td></td></tr><tr><td>…</td><td>[…]</td><td>匹配所有字符</td><td></td></tr><tr><td>( )</td><td>(  )</td><td>子表达式的开始和结束位置</td><td></td></tr></tbody></table><h4><span id="2非打印字符">2.非打印字符</span></h4>]]></content>
      
      
      <categories>
          
          <category> regex </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络协议</title>
      <link href="/blog/2021/06/07/tech/network/http/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
      <url>/blog/2021/06/07/tech/network/http/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><!-- toc --><ul><li><a href="#10-%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AEtcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</a></li><li><a href="#11-%E8%AF%B7%E6%B1%82%E5%A4%B4">1.1 请求头</a></li><li><a href="#12-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">1.2 三次握手四次挥手</a></li><li><a href="#13-%E6%8A%A5%E6%96%87%E6%8A%93%E5%8F%96%E5%B7%A5%E5%85%B7">1.3 报文抓取工具</a></li></ul><ul><li><a href="#20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</a><ul><li><a href="#21-%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87">2.1 请求报文</a></li><li><a href="#22-%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87">2.2 响应报文</a></li><li><a href="#23-http-%E6%8A%93%E5%8F%96%E5%B7%A5%E5%85%B7">2.3 HTTP 抓取工具</a></li><li><a href="#24-session-cookie">2.4 Session Cookie</a></li><li><a href="#25-tcpudphttp%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB">2.5 TCP&#x2F;UDP&#x2F;HTTP的区别和联系</a></li></ul></li><li><a href="#30-%E6%80%BB%E7%BB%93">3.0 总结</a></li></ul><!-- tocstop --><h4><span id="10-网络协议tcp-trancemission-control-protocol">1.0 网络协议（TCP Trancemission Control Protocol）</span></h4><ul><li><p>TCP 七层网络模型<br>主机层：<br>媒介层：</p><p><img src="http://s2-cdn.oneitfarm.com/767fb54c00ef41d1b15f28a8c33f3d16.png"></p></li></ul><h4><span id="11-请求头">1.1 请求头</span></h4><h4><span id="12-三次握手四次挥手">1.2 三次握手四次挥手</span></h4><h4><span id="13-报文抓取工具">1.3 报文抓取工具</span></h4><h3><span id="20-http-hypertext-transfer-protocol">2.0 HTTP (HyperText Transfer protocol)</span></h3><p><img src="//s2-cdn.oneitfarm.com/205566ffbffc4786af2443e348192532.png"></p><h4><span id="21-请求报文">2.1 请求报文</span></h4><h4><span id="22-响应报文">2.2 响应报文</span></h4><h4><span id="23-http-抓取工具">2.3 HTTP 抓取工具</span></h4><h4><span id="24-session-cookie">2.4 Session Cookie</span></h4><h4><span id="25-tcpx2fudpx2fhttp的区别和联系">2.5 TCP&#x2F;UDP&#x2F;HTTP的区别和联系</span></h4><p>一、<br>TPC&#x2F;IP协议是传输层协议，主要解决数据如何在网络中传输，<br>而HTTP是应用层协议，主要解决如何包装数据。<br>关于TCP&#x2F;IP和HTTP协议的关系，网络有一段比较容易理解的介绍：</p><p>“我们在传输数据时，可以只使用（传输层）TCP&#x2F;IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用层协议，应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP 文本信息，然后使用TCP&#x2F;IP做传输层协议将它发到网络上。”<br>术语TCP&#x2F;IP代表传输控制协议&#x2F;网际协议，指的是一系列协议。</p><p>“IP”代表网际协议，TCP和UDP使用该协议从一个网络传送数据包到另一个网络。把IP想像成一种高速公路，它允许其它协议在上面行驶并找到到其它电脑的出口。TCP和UDP是高速公路上的“卡车”，它们携带的货物就是像HTTP，文件传输协议FTP这样的协议等。 </p><p>你应该能理解，TCP和UDP是FTP，HTTP和SMTP之类使用的传输层协议。虽然TCP和UDP都是用来传输其他协议的，它们却有一个显著的不同：TCP提供有保证的数据传输，而UDP不提供。这意味着TCP有一个特殊的机制来确保数据安全的不出错的从一个端点传到另一个端点，而UDP不提供任何这样的保证。<br>HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。客户端使用Web浏览器发起HTTP请求给Web服务器，Web服务器发送被请求的信息给客户端。</p><p>1、HTTP协议的几个重要概念</p><p> 1.连接(Connection)：一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。</p><p> 2.消息(Message)：HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。</p><p> 3.请求(Request)：一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号</p><p> 4.响应(Response)：一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。</p><p> 5.资源(Resource)：由URI标识的网络数据对象或服务。</p><p> 6.实体(Entity)：数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。</p><p> 7.客户机(Client)：一个为发送请求目的而建立连接的应用程序。</p><p> 8.用户代理(Useragent)：初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。</p><p> 9.服务器(Server)：一个接受连接并对请求返回信息的应用程序。</p><p> 10.源服务器(Originserver)：是一个给定资源可以在其上驻留或被创建的服务器。</p><p> 11.代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。</p><p> 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。</p><p> 12.网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。</p><p> 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。</p><p> 13.通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。</p><p> 14.缓存(Cache)：反应信息的局域存储。</p><p> 2.发送请求</p><p>打开一个连接后，客户机把请求消息送到服务器的停留端口上，完成提出请求动作。</p><p> HTTP&#x2F;1.0 请求消息的格式为：</p><p> 请求消息&#x3D;请求行(通用信息|请求头|实体头)CRLF[实体内容]</p><p> 请求 行&#x3D;方法 请求URL HTTP版本号 CRLF</p><p> 方 法&#x3D;GET|HEAD|POST|扩展方法</p><p> U R L&#x3D;协议名称+宿主名+目录与文件名</p><p> 请求行中的方法描述指定资源中应该执行的动作，常用的方法有GET、HEAD和POST。不同的请求对象对应GET的结果是不同的，对应关系如下：</p><p> 对象 GET的结果</p><p> 文件 文件的内容</p><p> 程序 该程序的执行结果</p><p> 数据库查询 查询结果</p><p> HEAD??要求服务器查找某对象的元信息，而不是对象本身。</p><p> POST??从客户机向服务器传送数据，在要求服务器和CGI做进一步处理时会用到POST方法。POST主要用于发送HTML文本中FORM的内容，让CGI程序处理。</p><p> 一个请求的例子为：</p><p> GET<a href="http://networking.zju.edu.cn/zju/index.htmHTTP/1.0">http://networking.zju.edu.cn/zju/index.htmHTTP/1.0</a> networking.zju.edu.cn&#x2F;zju&#x2F;index.htmHTTP&#x2F;1.0 头信息又称为元信息，即信息的信息，利用元信息可以实现有条件的请求或应答。</p><p> 请求头??告诉服务器怎样解释本次请求，主要包括用户可以接受的数据类型、压缩方法和语言等。</p><p> 实体头??实体信息类型、长度、压缩方法、最后一次修改时间、数据有效期等。</p><p> 实体??请求或应答对象本身。</p><p> 3.发送响应</p><p> 服务器在处理完客户的请求之后，要向客户机发送响应消息。</p><p> HTTP&#x2F;1.0的响应消息格式如下：</p><p> 响应消息&#x3D;状态行(通用信息头|响应头|实体头) CRLF 〔实体内容〕</p><p> 状态行&#x3D;HTTP版本号 状态码 原因叙述</p><p> 状态码表示响应类型</p><p> 1×× 保留</p><p> 2×× 表示请求成功地接收</p><p> 3×× 为完成请求客户需进一步细化请求</p><p> 4×× 客户错误</p><p> 5×× 服务器错误</p><p> 响应头的信息包括：服务程序名，通知客户请求的URL需要认证，请求的资源何时能使用。</p><p> 4.关闭连接</p><p>客户和服务器双方都可以通过关闭套接字来结束TCP&#x2F;IP对话</p><p>二、TCP（传输控制协议）：</p><p>一、TCP是一种面向连接的、可靠的传输层协议；</p><pre><code>  TCP协议建立在不可靠的网络层 IP 协议之上，IP协议并不能提供任何可靠性机制，TCP的可靠性完全由自己实现；  TCP采用的最基本的可靠性技术是：确认与超时重传机制、流量控制机制；         </code></pre><p>1.超时重传是TCP协议保证数据可靠性的一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的ACK报文，那么就重新发送数据，直到发送成功为止。</p><p>2.流量控制就是让发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制。</p><p>Image</p><p>1.源端口和目的端口字段—— socket（IP+端口号）。TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</p><ol start="2"><li><p>序列号 SEQ ——当前报文段的序号。</p></li><li><p>确认应答号 AN ——期望收到对方的下一个报文段的数据的第一个字节的序号；</p></li><li><p>紧急  URG ——当  URG  &#x3D;  1  时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)；</p></li><li><p>确认 ACK ——当 ACK &#x3D; 1 时。表示确认应答号 AN 有效。</p></li><li><p>推送  PSH  (PuSH) —— 接收  TCP  收到  PSH  &#x3D;  1  的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付；</p></li><li><p>复位  RST  (ReSeT) —— 当  RST  &#x3D;  1  时，表明  TCP  连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接；</p></li><li><p>同步 SYN —— 同步  SYN  &#x3D;  1  表示这是一个连接请求报文。</p></li><li><p>终止 FIN (Finish) —— 用来释放一个连接。FIN&#x3D;  1  表明发送端的数据已发送完毕，并要求释放传输连接；</p></li><li><p>窗口字段 —— 占 2 字节，用来让对方设置发送窗口的依据，单位为字节。窗口值是[ 0, 216-1 ]之间的整数；</p></li><li><p>检验和 —— 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP 报文段的前面加上 12 字节的伪部(协议字段为6，表示TCP)；</p></li><li><p>紧急指针字段 —— 占 16 位，指出在本报文段中紧急数据共有多少个字节(紧急数据放在本报文段数据的最前面)；</p></li><li><p>选项字段 —— 长度可变。① 最大报文段长度 MSS：MSS是指在TCP连接建立时，收发双发协商的通信时每一个报文段所能承载的数据字段的最大长度（并不是TCP报文段的最大长度，而是：MSS&#x3D;TCP报文段长度-TCP首部长度），单位为字节（双方提供的MSS中的最小值，为本次连接的最大MSS值）；② 窗口扩大选项；③ 时间戳选项；④ 选择确认选项；</p></li></ol><p>二、TCP三次握手（非常重要）</p><ul><li><pre><code>第一次握手：客户端向服务器发送请求报文段，其中同步位SYN=1，序号SEQ=x（表明传送数据时的第一个数据字节的序号是x），等待服务器确认；</code></pre></li><li><pre><code>第二次握手：服务器收到客户端发来的请求，如果同意建立连接，就发回一个确认报文段，该报文段中同步位SYN=1，确认号ACK=x+1，序号SEQ=y；</code></pre></li><li><pre><code>第三次握手：客户端收到服务器的确认报文段后，还需要向服务器给出确认，向其发送确认包ACK(ack=y+1)，进而完成三次握手。</code></pre></li></ul><p>通过这样的三次握手，客户端与服务端建立起可靠的双工的连接，开始传送数据。</p><p>为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手。</p><p>三、用户数据报协议（用户报文协议）UDP</p><p>   UDP是一种无连接的、不可靠的传输层协议；</p><p>   提供了有限的差错检验功能；</p><p>   目的是希望以最小的开销来达到网络环境中的进程通信目的；</p><p>随着网络技术飞速发展，网速已不再是传输的瓶颈，UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP，如网页浏览、流媒体、实时游戏、物联网。</p><p>1.网速的提升给UDP稳定性提供可靠网络保障</p><p>CDN服务商Akamai（NASDAQ: AKAM）报告从2008年到2015年7年时间，各个国家网络平均速率由1.5Mbps提升为5.1Mbps，网速提升近4倍。网络环境变好，网络传输的延迟、稳定性也随之改善，UDP的丢包率低于5%，如果再使用应用层重传，能够完全确保传输的可靠性。</p><p>2.对比测试结果UDP性能优于TCP</p><p>为了提升浏览速度，Google基于TCP提出了SPDY协议以及HTTP&#x2F;2。Google在Chrome上实验基于UDP的QUIC协议，传输速率减少到100ms以内。</p><p>Google采用QUIC后连接速率能有效提升75%。</p><p>Google搜索采用QUIC后页面加载性能提升3%。</p><p>YouTube采用QUIC后重新缓冲次数减少了30%。</p><p>3.TCP设计过于冗余，速度难以进一步提升</p><p>TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程以及重传策略。由于TCP内置在系统协议栈中，极难对其进行改进。</p><p>4.UDP协议以其简单、传输快的优势，在越来越多场景下取代了TCP</p><p>4.1 网页浏览</p><p>使用UDP协议有三个优点 ：</p><p>能够对握手过程进行精简，减少网络通信往返次数；</p><p>能够对TLS加解密过程进行优化；</p><p>收发快速，无阻塞。</p><p>4.2 流媒体<br>采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如WebRTC是极佳的选择。<br>2010年google 通过收购 Global IP Solutions，获得了WebRTC（网页实时通信，Web Real-Time Communication）技术，用于提升网页视频速率。<br>4.3 实时游戏</p><p>对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。</p><p>采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet</p><p>四、TCP与UDP的不同</p><ol><li>是否需要建立连接：UDP在传送数据之前不需要先建立连接；TCP则提供面向连接的服务；</li><li>是否需要给出确认：对方的传输层在收到UDP报文后，不需要给出任何确认，而 TCP需要给出确认报文，要提供可靠的、面向连接的传输服务。</li><li>虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式；【UDP取代TCP】</li><li>和IP层的联系：IP层只负责把数据送到节点，而不能区分上面的不同应用，所以TCP和UDP协议在其基础上加入了端口的信息，每个端口标识的是一个节点上的一个应用。除了增加端口信息，UPD协议基本就没有对IP层的数据进行任何的处理了。而TCP协议还加入了更加复杂的传输控制，比如滑动的数据发送窗口，以及接收确认和重发机制，以达到数据的可靠传送。不管应用层看到的是怎样一个稳定的TCP数据流，下面传送的都是一个个的IP数据包，需要由TCP协议来进行数据重组。</li></ol><p>五、TCP与UDP的适用场景。</p><ol><li><p>TCP用于在传输层有必要实现可靠传输的情况。</p></li><li><p>UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。</p><p> 举一个通过 IP 电话进行通话的例子。如果使用 TCP，数据在传送途中如果丢失就会被重发，这样就会导致无法流畅地传输通话人的声音。而采用UDP，它不会进行重发处理，从而也就不会有声音大幅度延迟到达的问题，即使有部分数据丢失，也只是会影响某一小部分的通话。</p></li></ol><h3><span id="30-总结">3.0 总结</span></h3>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>The MIT License</title>
      <link href="/blog/2021/05/27/other/wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/"/>
      <url>/blog/2021/05/27/other/wiki/%E5%85%B6%E4%BB%96-MIT%20%E8%AE%B8%E5%8F%AF%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>MIT许可证（The MIT License）是许多软件授权条款中，被广泛使用的其中一种。与其他常见的软件授权条款（如GPL、LGPL、BSD）相比，MIT是相对宽松的软件授权条款。</p></blockquote><h3><span id="1条款内容">1.条款内容</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Copyright (C) &lt;year&gt; &lt;copyright holders&gt;</span><br><span class="line">Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</span><br><span class="line">The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</span><br><span class="line">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span><br></pre></td></tr></table></figure><h3><span id="2mit与其他开源许可证的区别">2.MIT与其他开源许可证的区别</span></h3><p><img src="//s2-cdn.oneitfarm.com/2bec9f7690a945a499ebc95fd84a0cb5.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>孔乙己和阿Q</title>
      <link href="/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/"/>
      <url>/blog/2021/05/26/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%AD%94%E4%B9%99%E5%B7%B1%E5%92%8C%E9%98%BFQ/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>孔乙己原为鲁迅笔下的一个旧时代的人物，我们可以简单理解为一个臭读书的<br>阿Q我们听到的最多的是阿Q精神：自恋不自知的小人物<br>这些都是鲁迅笔下的小人物，之前不大明白鲁迅为何喜欢写这些我们现在看起来抨击小人物的短片小说，<br>包括对闰土 阿Q 孔乙己 祥林嫂 范爱农等等这些现在看起来很离谱的事情，这要是放到现在不得不说是一股奇葩的力量<br>在微博贡献，因为本人也是个冲浪的键盘侠。<br>但了解过鲁迅大大说过一句很经典的话：学医救不了中国人<br>当时是民国 想想这句话到底有几个味道大家便知道了<br>现在提起来中国人，你走到哪里都是自豪的，除了蜜汁自信呢的美帝，最起码在国外是没问题的，对于一个长时间被中央人民广播电台熏陶的年青人是这样的</p><p>当时中国是被侵略，被十几个人打，想想那画面，不敢还手，对于国家至此，何况老百姓。<br>其实鲁迅笔下任务用的最多为小小的底层任务对社会，谈不上社会，而是对自己的生活圈子里造成的影响，可有可无的那种。</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从正则表达式的iUs说说模式修正符</title>
      <link href="/blog/2021/05/25/tech/backend/php/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/"/>
      <url>/blog/2021/05/25/tech/backend/php/PHP-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84iUs%E8%AF%B4%E8%AF%B4%E6%A8%A1%E5%BC%8F%E4%BF%AE%E6%AD%A3%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>本想做个简单的采集程序，发现被抓页面代码的规律后发现抓下来的内容没有放到一个数组中，而是放在一个元素中，无奈找遍资料发现在正则表达式后加上”&#x2F;iUs”后竟然可以了。<br>hexo<br>网上关于iUs的说明多数都是抄袭的，没有做过多的解释，对于一个小学毕业证是买来的人来说是在是不好理解。不过幸亏Google让我找到答案。</p><p>“iUs” 在这里叫“模式修正符”。模式修正符其实就是几个字母，可以一次使用一个也可以一次使用多个，每一个都具有一定的意义，模式修正符是对正则表达式的扩展；“&#x2F;模式修正符”，其中正斜线“&#x2F;”为边界符。下表列出来有那些模式修正符：</p><p>模式修正符说明<br>i表示在和模式进行匹配进不区分大小写<br>m将模式视为多行，使用^和$表示任何一行都可以以正则表达式开始或结束<br>s如果没有使用这个模式修正符号，元字符中的”.”默认不能表示换行符号,将字符串视为单行<br>x表示模式中的空白忽略不计<br>e正则表达式必须使用在preg_replace替换字符串的函数中时才可以使用(讲这个函数时再说)<br>A以模式字符串开头，相当于元字符^<br>Z以模式字符串结尾，相当于元字符$<br>U正则表达式的特点：就是比较“贪婪”，使用该模式修正符可以取消贪婪模式</p><h3><span id="1模式修正符m">1，模式修正符m。</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern = ‘/^abc/m’;</span><br><span class="line">$string = ‘bcd</span><br><span class="line">abc</span><br><span class="line">cba’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;/b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;/b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color=’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;/font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>匹配结果是成功的。注意：我们在使用模式修正符m的时候，将匹配字符串看成是多行而不是默认的单行，所以任何一行只要是以abc开头，就匹配成功。但是，如果能匹配的行前面有空格的话，就不能匹配了!除非修改正则表达式的匹配模式。</p><h3><span id="2模式修正符s">2，模式修正符s。</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern = ‘/a.*c/s’;</span><br><span class="line">$string = ‘adsadsa</span><br><span class="line">c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;/b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;/b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color=’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;/font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配记过也是成功的。如果你将上例中的模式修正符s去掉的话，匹配就会失败。因为模式修正符s将匹配字符串看作是单行的，所以这个时候，元字符中的”.”就可以表示换行符号了。</p><h3><span id="3模式修正符x">3，模式修正符x。</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern = ‘/a c/x’;</span><br><span class="line">$string = ‘a c’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;/b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;/b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color=’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;/font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这次的匹配结果是失败的。因为我们使用模式修正符x取消了模式中的空格。注意：我们无法使用模式修正符取消\s表示的空白。</p><h3><span id="4模式修正符a">4，模式修正符A。</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern = ‘/ac/A’;</span><br><span class="line">$string = ‘acahgyghvbm’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;/b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;/b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color=’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;/font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>正则表达式表示的含义是匹配以ac开头的字符串，结果成功。</p><p>模式修正符Z表示的是以字符串结尾的匹配，和A的用法是一样的，我们不再进行演示。</p><h3><span id="5模式修正符u">5，模式修正符U。</span></h3><p>这个模式修正符是十分重要的!在正则表达式中，其本身是“贪婪”的。那什么是贪婪模式呢?贪婪模式的意思就是说，正则表达式默认会在查找到第一个匹配后，继续尝试后面的匹配，如果能找到匹配，则匹配最大的范围字符串。但有的时候这并不是我们想要的结果，所以我们需要取消贪婪模式。</p><p>我们还是先看一个贪婪模式的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern = ‘/&lt;b&gt;.*&lt;\/b&gt;/’;</span><br><span class="line">$string = ‘&lt;b&gt;welcome&lt;/b&gt; &lt;b&gt;to&lt;/b&gt; &lt;b&gt;phpfuns&lt;/b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;/b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;/b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color=’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;/font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>这个实例的本意是匹配welcome，但是结果却匹配了welcome to phpfuns整个字符串(注意我们的字符串’welcome to phpfuns’，其开头和结尾正好构成了正则表达式的模式匹配，所以匹配成功)，这就是正则表达式的贪婪模式。当然，这不是我们要的结果。</p><p>取消贪婪模式<br>我们可以使用模式修正符U和元字符?两种方式取消正则表达式的贪婪模式。</p><p>模式修正符U取消贪婪模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern = ‘/&lt;b&gt;.*&lt;\/b&gt;/U’;</span><br><span class="line">$string = ‘&lt;b&gt;welcome&lt;/b&gt; &lt;b&gt;to&lt;/b&gt; &lt;b&gt;phpfuns&lt;/b&gt;’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;/b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;/b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color=’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;/font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>元字符?取消贪婪模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pattern = ‘/&lt;b&gt;.*?&lt;\/b&gt;/’;</span><br><span class="line">$string = ‘&lt;b&gt;welcome&lt;/b&gt; &lt;b&gt;to&lt;/b&gt; &lt;b&gt;phpfuns&lt;/b&gt;dsadsadas’;</span><br><span class="line">if (preg_match($pattern, $string, $arr)) &#123;</span><br><span class="line">echo “正则表达式&lt;b&gt;&#123;$pattern&#125;&lt;/b&gt;和字符串&lt;b&gt;&#123;$string&#125;&lt;/b&gt;匹配成功&lt;br&gt;”;</span><br><span class="line">print_r($arr);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">echo “&lt;font color=’red’&gt;正则表达式&#123;$pattern&#125;和字符串&#123;$string&#125;匹配失败&lt;/font&gt;”;</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>注意元字符的位置，我们必须在“”之前结束贪婪模式，才能达到我们的目的</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于 URL 中协议的省略</title>
      <link href="/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/"/>
      <url>/blog/2021/05/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>前天看了 Google HTML&#x2F;CSS 代码风格指南，里面有很多值得借鉴的地方，也学到了一些新东西，其中第一条说道，HTML 和 CSS 代码中引用的图片、媒体、CSS 和 JS 文件中的 URL 都可以去掉协议部分（http: 和 https:），比如</p><script src="http://www.google-analytics.com/ga.js" type="text/javascript"></script><script src="https://www.google-analytics.com/ga.js" type="text/javascript"></script><p>都可以换成：</p><script src="//www.google-analytics.com/ga.js" type="text/javascript"></script><p>只要是使用 http、https 这两种协议都可以省略。原因是可以节省一点文件体积（当然只是那么一点点），另外一个原因 Google 说是可以解决混合内容的问题。起初我对这个第二点不是很了解，所以特意搜索了下。最后从 Paul Irish 的一篇文章找到答案，链接在文后。文章是两三年前写的，老外研究问题总是比我们要早啊。</p><p>以 &#x2F;&#x2F; 开头的叫做相对URL（protocol-relative URL），相关的标准可以看 RFC 3986 Section 4.2，内容不是一般的长估计大家也没耐心去看吧。总之浏览器遇到相对 URL，则会根据当前的网页协议，自动在 &#x2F;&#x2F; 前面加上相同的协议。如当前网页是 http 访问，那么所有的相对引用 &#x2F;&#x2F; 都会变成http:&#x2F;&#x2F;。https 同理。如果你在本地查看，协议就会变成 file:&#x2F;&#x2F;。</p><p>所以，如果省略协议，就需要保证引用的外部资源也采用和网页相同的协议，或者保证资源可以同时通过 http 和 https 访问。经过 StackOverflow 网友测试，这种用法几乎所有的浏览器都能支持，只有在 IE7&#x2F;8 下会有一点小问题，就是通过相对 URL 引用的 CSS 文件（无论 <link> 或 @import）会被下载两遍。所以对性能有一点影响。</p><p>至于 Google 提到的混合内容问题，其实是指IE有时会弹出的一个警告框：</p><p>这个框想必大家也都见过。通常是在浏览 https 网页的时候出现，原因是网页里引用了 http 协议的外部资源，由于 http 被认为是不安全的，IE 才会给出提示。如果引用的时候写成相对 URL，浏览器就会自动采用 https 协议下载，这样就解决了问题。</p><p>所以，我们平时写代码还是可以放心使用相对 URL 的，写博客的大概很少开 https，当然做项目的就例外了。如果你引用的资源里有 https 协议的就特别处理一下，或者只要 http 也能访问到资源就可以。我看了下国内的站点这么用的还不多，有一次看到百度音乐这么用过。不过 Google 很多站点都已经是这样的写法了。</p><hr>> 参考资料：<p><a href="http://paulirish.com/2010/the-protocol-relative-url/">http://paulirish.com/2010/the-protocol-relative-url/</a><br><a href="http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just">http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just</a><br><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><blockquote><p>转载 自：<a href="http://pandacafe.net/post/231?huvqlc=r5eup1">http://pandacafe.net/post/231?huvqlc=r5eup1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http:// </tag>
            
            <tag> https:// </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 URL 中协议的省略</title>
      <link href="/blog/2021/05/25/tech/frontend/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/"/>
      <url>/blog/2021/05/25/tech/frontend/%E5%85%B3%E4%BA%8E-URL-%E4%B8%AD%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%9C%81%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>前天看了 Google HTML&#x2F;CSS 代码风格指南，里面有很多值得借鉴的地方，也学到了一些新东西，其中第一条说道，HTML 和 CSS 代码中引用的图片、媒体、CSS 和 JS 文件中的 URL 都可以去掉协议部分（http: 和 https:），比如</p><script src="http://www.google-analytics.com/ga.js" type="text/javascript"></script><script src="https://www.google-analytics.com/ga.js" type="text/javascript"></script><p>都可以换成：</p><script src="//www.google-analytics.com/ga.js" type="text/javascript"></script><p>只要是使用 http、https 这两种协议都可以省略。原因是可以节省一点文件体积（当然只是那么一点点），另外一个原因 Google 说是可以解决混合内容的问题。起初我对这个第二点不是很了解，所以特意搜索了下。最后从 Paul Irish 的一篇文章找到答案，链接在文后。文章是两三年前写的，老外研究问题总是比我们要早啊。</p><p>以 &#x2F;&#x2F; 开头的叫做相对URL（protocol-relative URL），相关的标准可以看 RFC 3986 Section 4.2，内容不是一般的长估计大家也没耐心去看吧。总之浏览器遇到相对 URL，则会根据当前的网页协议，自动在 &#x2F;&#x2F; 前面加上相同的协议。如当前网页是 http 访问，那么所有的相对引用 &#x2F;&#x2F; 都会变成http:&#x2F;&#x2F;。https 同理。如果你在本地查看，协议就会变成 file:&#x2F;&#x2F;。</p><p>所以，如果省略协议，就需要保证引用的外部资源也采用和网页相同的协议，或者保证资源可以同时通过 http 和 https 访问。经过 StackOverflow 网友测试，这种用法几乎所有的浏览器都能支持，只有在 IE7&#x2F;8 下会有一点小问题，就是通过相对 URL 引用的 CSS 文件（无论 <link> 或 @import）会被下载两遍。所以对性能有一点影响。</p><p>至于 Google 提到的混合内容问题，其实是指IE有时会弹出的一个警告框：</p><p>这个框想必大家也都见过。通常是在浏览 https 网页的时候出现，原因是网页里引用了 http 协议的外部资源，由于 http 被认为是不安全的，IE 才会给出提示。如果引用的时候写成相对 URL，浏览器就会自动采用 https 协议下载，这样就解决了问题。</p><p>所以，我们平时写代码还是可以放心使用相对 URL 的，写博客的大概很少开 https，当然做项目的就例外了。如果你引用的资源里有 https 协议的就特别处理一下，或者只要 http 也能访问到资源就可以。我看了下国内的站点这么用的还不多，有一次看到百度音乐这么用过。不过 Google 很多站点都已经是这样的写法了。</p><hr>> 参考资料：<p><a href="http://paulirish.com/2010/the-protocol-relative-url/">http://paulirish.com/2010/the-protocol-relative-url/</a><br><a href="http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just">http://stackoverflow.com/questions/4831741/can-i-change-all-my-http-links-to-just</a><br><a href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p><blockquote><p>转载 自：<a href="http://pandacafe.net/post/231?huvqlc=r5eup1">http://pandacafe.net/post/231?huvqlc=r5eup1</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http:// </tag>
            
            <tag> https:// </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>天气晴-2021-5-20</title>
      <link href="/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/"/>
      <url>/blog/2021/05/20/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%A4%A9%E6%B0%94%E6%99%B4-2021-5-20/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="今天是2021年5月20日是个好日子">今天是2021年5月20日，是个好日子</span></h3><p> 早上打开电脑 撇了下右下角的电脑，是2021&#x2F;5&#x2F;20 嗯是个吉利的数字</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>百年孤独</title>
      <link href="/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/"/>
      <url>/blog/2021/05/18/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><h3><span id="家族的第一个人被捆在树上最后一个人正被蚂蚁吃掉">家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉</span></h3></blockquote><ul><li>这本书到底讲了什么？作者想表达什么？自己有了什么样的感触<hr></li></ul><h3><span id="经典语句">经典语句</span></h3><p>1、多年以后，奥雷连诺上校站在行刑队面前，准会想起父亲带他去参观冰块的那个遥远的下午。</p><p>2、 过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂热最坚贞的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。</p><p>3、买下一张永久车票，登上一列永无终点的火车。</p><p>4、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>5、生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p><p>6、我确实一度死去，但难以忍受孤独又重返人世。</p><p>7、他渴望孤独，对整个世界的怨恨咬噬着他的内心。</p><p>8、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>9、所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。</p><p>10、这手稿上所写的事情过去不曾，将来也永远不会重复，因为命中注定要一百年处于孤独的世家决不会有出现在世上的第二次机会。</p><h3><span id="百年孤独讲述了什么">百年孤独讲述了什么</span></h3><p>《百年孤独》讲的是一个叫布恩迪亚家族百年的兴衰以及小镇马孔多的发展变迁史。</p><p>布恩迪亚家族的每一代人都在努力地摆脱孤独落后的生活状态，但是却一次又一次的失败，最终，家族的最后一个人被蚂蚁吃掉，整个屋子也被风卷走，从此消失在地球上，再未出现。</p><p>孤独会让人丧失对生活的希望。没有人喜欢孤独，布恩迪亚家族的人付出了一辈又一辈的努力，却依然是一场空，书也表现了人类的抗争，对命运的无可奈何以及天性的顽固。</p><h3><span id="百年孤独反思">百年孤独反思</span></h3><p>《百年孤独》是哥伦比亚作家加西亚·马尔克斯的一部长篇小说</p><p>百年孤独比较适合25岁以上，经历过社会的人看。这样才能读出韵味的。</p><p>说到底《百年孤独》好在它的新颖，不仅让人们看到一个不一样的故事，也让人看到了小说不一样的表现手，而且这种不一样的表现手法，被国内许多的作家所借鉴引用。这也就是《百年孤独》的好处。</p><p>可以不客气地说，《百年孤独》影响了中国当代文学的走向，国内许多的作家，正是由于看了这本小说之后，才开始写出了自己最为重要的作品，例如莫言、陈忠实、余华、阎连科等等，这些国内一线作家，那都是受到了《百年孤独》的影响，他们的作品里，都有着《百年孤独》的影子。也正是这一份影响，使得它在国人心目中，有着崇高的地位。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>百年孤独</title>
      <link href="/blog/2021/05/18/personal/reading/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/"/>
      <url>/blog/2021/05/18/personal/reading/%E7%BB%8F%E5%85%B8%E8%AF%BB%E7%89%A9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><h3><span id="家族的第一个人被捆在树上最后一个人正被蚂蚁吃掉">家族的第一个人被捆在树上，最后一个人正被蚂蚁吃掉</span></h3></blockquote><ul><li>这本书到底讲了什么？作者想表达什么？自己有了什么样的感触<hr></li></ul><h3><span id="经典语句">经典语句</span></h3><p>1、多年以后，奥雷连诺上校站在行刑队面前，准会想起父亲带他去参观冰块的那个遥远的下午。</p><p>2、 过去都是假的，回忆是一条没有归途的路，以往的一切春天都无法复原，即使最狂热最坚贞的爱情，归根结底也不过是一种瞬息即逝的现实，唯有孤独永恒。</p><p>3、买下一张永久车票，登上一列永无终点的火车。</p><p>4、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>5、生命中真正重要的不是你遭遇了什么，而是你记住了哪些事，又是如何铭记的。</p><p>6、我确实一度死去，但难以忍受孤独又重返人世。</p><p>7、他渴望孤独，对整个世界的怨恨咬噬着他的内心。</p><p>8、我们趋行在人生这个亘古的旅途，在坎坷中奔跑，在挫折里涅槃，忧愁缠满全身，痛苦飘洒一地。我们累，却无从止歇；我们苦，却无法回避。</p><p>9、所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。</p><p>10、这手稿上所写的事情过去不曾，将来也永远不会重复，因为命中注定要一百年处于孤独的世家决不会有出现在世上的第二次机会。</p><h3><span id="百年孤独讲述了什么">百年孤独讲述了什么</span></h3><p>《百年孤独》讲的是一个叫布恩迪亚家族百年的兴衰以及小镇马孔多的发展变迁史。</p><p>布恩迪亚家族的每一代人都在努力地摆脱孤独落后的生活状态，但是却一次又一次的失败，最终，家族的最后一个人被蚂蚁吃掉，整个屋子也被风卷走，从此消失在地球上，再未出现。</p><p>孤独会让人丧失对生活的希望。没有人喜欢孤独，布恩迪亚家族的人付出了一辈又一辈的努力，却依然是一场空，书也表现了人类的抗争，对命运的无可奈何以及天性的顽固。</p><h3><span id="百年孤独反思">百年孤独反思</span></h3><p>《百年孤独》是哥伦比亚作家加西亚·马尔克斯的一部长篇小说</p><p>百年孤独比较适合25岁以上，经历过社会的人看。这样才能读出韵味的。</p><p>说到底《百年孤独》好在它的新颖，不仅让人们看到一个不一样的故事，也让人看到了小说不一样的表现手，而且这种不一样的表现手法，被国内许多的作家所借鉴引用。这也就是《百年孤独》的好处。</p><p>可以不客气地说，《百年孤独》影响了中国当代文学的走向，国内许多的作家，正是由于看了这本小说之后，才开始写出了自己最为重要的作品，例如莫言、陈忠实、余华、阎连科等等，这些国内一线作家，那都是受到了《百年孤独》的影响，他们的作品里，都有着《百年孤独》的影子。也正是这一份影响，使得它在国人心目中，有着崇高的地位。</p>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>git 使用 connot stat</title>
      <link href="/blog/2021/05/17/tech/devops/cannot%20stat/"/>
      <url>/blog/2021/05/17/tech/devops/cannot%20stat/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>1.记一次使用bug<br><img src="http://s2-cdn.oneitfarm.com/c71c1444ef7b472fbad9c71ba803fa95.png"><br>git error: cannot stat<br>原因是因为，在某个编辑器打开了master分支的一个文件，然后切换到feat分支，文件并不消失，拉取时候出现问题，</p><p>解决办法：关掉编辑器</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-改善golang50个有效实践</title>
      <link href="/blog/2021/05/14/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B010-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/"/>
      <url>/blog/2021/05/14/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B010-%E6%94%B9%E5%96%84golang50%E4%B8%AA%E6%9C%89%E6%95%88%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>闲逛好久go论坛，找到一本适合看的教程，花了点时间将这个文章搬运过来，自己慢慢研读</p></blockquote><h4><span id="1-语言的前生今世">1 </span></h4><h4><span id="2-语言的设计哲学之一简单">2 </span></h4><h4><span id="3-语言的设计哲学之二组合">3  </span></h4><h4><span id="4-go语言的设计哲学之三并发">4  </span></h4><h4><span id="5-go-语言的设计哲学之四面向工程">5  </span></h4><h4><span id="6-参考-go-项目布局设计你的项目结构">6  </span></h4><h4><span id="7-gofmtgo代码风格的唯一标准">7  </span></h4><h4><span id="8-go-标识符的命名惯例">8  </span></h4><h4><span id="9-变量声明形式尽量保持一致">9  </span></h4><h4><span id="10-无类型常量让代码更简化">10  </span></h4><h4><span id="11-go枚举常量的惯用实现方法">11  </span></h4><h4><span id="12-定义零值可用的类型">12  </span></h4><h4><span id="13-用复合字面值作初值构造器">13  </span></h4><h4><span id="14-深入理解和高效运用切片slice">14  </span></h4><h4><span id="15-注意go-字符串是原生类型">15  </span></h4><h4><span id="16-理解包导入路径的含义">16  </span></h4><h4><span id="17-init-函数的妙用">17  </span></h4><h4><span id="18-go-函数是一等公民">18  </span></h4><h4><span id="19-defer-让你的代码更清">19  </span></h4><h4><span id="20-方法的本质">20  </span></h4><h4><span id="21-方法集合决定接口实现">21  </span></h4><h4><span id="22-变长参数函数的妙用">22  </span></h4><hr>转载自慕课资源，仅供学习使用，如有侵权联系自行删除]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> 书籍 </tag>
            
            <tag> 推荐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他-软件行业高频单词</title>
      <link href="/blog/2021/05/14/other/wiki/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/"/>
      <url>/blog/2021/05/14/other/wiki/%E5%85%B6%E4%BB%96-%E8%BD%AF%E4%BB%B6%E8%A1%8C%E4%B8%9A%E9%AB%98%E9%A2%91%E5%8D%95%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="1golang高频英语">1.golang高频英语</span></h3><p><strong>并发</strong>：(Concurrency) [kənˈkʌrənsɪ] </p><p><strong>并行</strong>：(Parallelism) [ˈpærəlelɪzəm]  </p><p><strong>摩尔定律</strong>：(Moore’s Law):集成电路上可以容纳的晶体管数目在大约每经过18个月便会增加一倍。换言之，处理器的性能每隔两年翻一倍</p><p><strong>cup主频</strong>：（CPU Clock Speed）:主频即CPU的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了CPU速度的快慢</p><p><strong>时钟频率</strong>：(clock rate):是指同步电路中时钟的基础频率，它以“若干次周期每秒”来度量，量度单位采用SI单位赫兹（Hz）。它是评定CPU性能的重要指标。一般来说主频数字值越大越好。外频，是CPU外部的工作频率，是由主板提供的基准时钟频率。FSB频率，是连接CPU和主板芯片组中的北桥芯片的前端总线（Front Side Bus）上的数据传输频率。CPU的主频和外频间存在这样的关系：主频&#x3D;外频×倍频。</p><p><strong>pthread</strong>： (线程)<br><strong>kernel</strong> ：（核心）</p><p>好的命名就像一个好笑话。如果你必须解释它，那就不好笑了</p><p><strong>在 Go 语言中 interface 名字仍然以单个词为优先。对于拥有唯一方法 (method) 或通过多个拥有唯一方法的接口组合而成的接口，Go 语言的惯例是一般用 “方法名 + er” 的方式为 interface 命名</strong><br><strong>coined</strong>：创造<br><strong>Syntax</strong>: 语法<br><strong>Semantics</strong>: 语意</p><p>Go 设计者认为隐式转换带来的便利性不足以抵消其带来的诸多问题 1，因此要解决上面的编译错误，我们必须进行显式地转型：</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-概述，为什么要使用设计模式</title>
      <link href="/blog/2021/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2021/05/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="设计模式design-pattern">设计模式（Design pattern）</span></h3><blockquote><p>GOF(gong of for)可复用面向对象软件元素</p></blockquote><ul><li>对接口编程而不是对实现编程</li><li>优先使用对象组合而不是继承</li></ul><h3><span id="设计模式的类型23种">设计模式的类型（23种）</span></h3><p>基本可以分为四大类：</p><ul><li>创建型模式（Creational Patterns）<br>提供一种在创建对象的时候隐藏逻辑方法的形式，而不是直接new一个对象，这使得程序在判断针对某个特定的实例需要创建哪些对象的时候更加灵活。</li><li>结构型模式 (Structural Patterns)<br>关注类和对象组合，集成的概念用来组合接口和定义组合对象 获取新的功能方式</li><li>行为型模式 (Behavioral Patterns)<br>关注对象之间的通信</li><li>j2EE模式<br>这些模式主要由java 中的设计模式提供（Sun Java Center）</li></ul><table><thead><tr><th align="left"></th><th>模式描述</th><th align="center">包括</th></tr></thead><tbody><tr><td align="left">1</td><td>创建型模式</td><td align="center">工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern）</td></tr><tr><td align="left">2</td><td>结构型模式</td><td align="center">适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern）</td></tr><tr><td align="left">3</td><td>行为型模式</td><td align="center">责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern）</td></tr><tr><td align="left">4</td><td>J2ee型模式</td><td align="center">MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h3><span id="设计模式-之间关系">设计模式 之间关系</span></h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg"></p><h3><span id="设计模式的六大原则">设计模式的六大原则</span></h3><ol><li><p>开闭原则（Open Close Principle）:<br> <strong>对扩展开放，对修改关闭</strong> ，在程序需要进行扩展的时候，不能去修改原代码，实现一个热拔插的效果。为了的是使程序的扩展性更好，易于维护和升级，我们需要使用接口和抽象类来实现</p></li><li><p>里氏代换原则（Liskow Substitution Priciple）</p><p> 任何基类出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位不受影响的时候，基类才能真正的被附中，而派生类可以在基类中增加新的行为，LSP是对开闭原则的补充。开闭原则关键步骤就是抽象化，基类与子类的继承关系就是抽象化的具体实现，即：对实现抽象化具体步骤的规范</p></li><li><p>依赖倒转原则（Dependence Inversion Priciple）</p><p> 针对接口变成，依赖于抽象而不依赖于具体</p></li><li><p>接口隔离原则（Interface Segregation Priciple）</p><p> 多实用隔离的接口，比使用单个接口更好。降低类之间的耦合度。</p></li><li><p>迪米特法则（Demeter Priciple）</p><p> 最少知道的原则：一个实体应当尽量少跟其他实体之间发生相互的作用，是得系统模块相对</p></li><li><p>合成复用原则（composite Reuse Priciple）</p><p> 尽量使用合成&#x2F;聚合方式，而不是使用继承</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-概述，为什么要使用设计模式</title>
      <link href="/blog/2021/05/13/tech/fundamentals/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2021/05/13/tech/fundamentals/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A6%82%E8%BF%B0%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="设计模式design-pattern">设计模式（Design pattern）</span></h3><blockquote><p>GOF(gong of for)可复用面向对象软件元素</p></blockquote><ul><li>对接口编程而不是对实现编程</li><li>优先使用对象组合而不是继承</li></ul><h3><span id="设计模式的类型23种">设计模式的类型（23种）</span></h3><p>基本可以分为四大类：</p><ul><li>创建型模式（Creational Patterns）<br>提供一种在创建对象的时候隐藏逻辑方法的形式，而不是直接new一个对象，这使得程序在判断针对某个特定的实例需要创建哪些对象的时候更加灵活。</li><li>结构型模式 (Structural Patterns)<br>关注类和对象组合，集成的概念用来组合接口和定义组合对象 获取新的功能方式</li><li>行为型模式 (Behavioral Patterns)<br>关注对象之间的通信</li><li>j2EE模式<br>这些模式主要由java 中的设计模式提供（Sun Java Center）</li></ul><table><thead><tr><th align="left"></th><th>模式描述</th><th align="center">包括</th></tr></thead><tbody><tr><td align="left">1</td><td>创建型模式</td><td align="center">工厂模式（Factory Pattern） 抽象工厂模式（Abstract Factory Pattern） 单例模式（Singleton Pattern） 建造者模式（Builder Pattern） 原型模式（Prototype Pattern）</td></tr><tr><td align="left">2</td><td>结构型模式</td><td align="center">适配器模式（Adapter Pattern） 桥接模式（Bridge Pattern） 过滤器模式（Filter、Criteria Pattern） 组合模式（Composite Pattern） 装饰器模式（Decorator Pattern） 外观模式（Facade Pattern） 享元模式（Flyweight Pattern） 代理模式（Proxy Pattern）</td></tr><tr><td align="left">3</td><td>行为型模式</td><td align="center">责任链模式（Chain of Responsibility Pattern） 命令模式（Command Pattern） 解释器模式（Interpreter Pattern） 迭代器模式（Iterator Pattern） 中介者模式（Mediator Pattern） 备忘录模式（Memento Pattern） 观察者模式（Observer Pattern） 状态模式（State Pattern） 空对象模式（Null Object Pattern） 策略模式（Strategy Pattern） 模板模式（Template Pattern） 访问者模式（Visitor Pattern）</td></tr><tr><td align="left">4</td><td>J2ee型模式</td><td align="center">MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h3><span id="设计模式-之间关系">设计模式 之间关系</span></h3><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/the-relationship-between-design-patterns.jpg"></p><h3><span id="设计模式的六大原则">设计模式的六大原则</span></h3><ol><li><p>开闭原则（Open Close Principle）:<br> <strong>对扩展开放，对修改关闭</strong> ，在程序需要进行扩展的时候，不能去修改原代码，实现一个热拔插的效果。为了的是使程序的扩展性更好，易于维护和升级，我们需要使用接口和抽象类来实现</p></li><li><p>里氏代换原则（Liskow Substitution Priciple）</p><p> 任何基类出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当派生类可以替换掉基类，且软件单位不受影响的时候，基类才能真正的被附中，而派生类可以在基类中增加新的行为，LSP是对开闭原则的补充。开闭原则关键步骤就是抽象化，基类与子类的继承关系就是抽象化的具体实现，即：对实现抽象化具体步骤的规范</p></li><li><p>依赖倒转原则（Dependence Inversion Priciple）</p><p> 针对接口变成，依赖于抽象而不依赖于具体</p></li><li><p>接口隔离原则（Interface Segregation Priciple）</p><p> 多实用隔离的接口，比使用单个接口更好。降低类之间的耦合度。</p></li><li><p>迪米特法则（Demeter Priciple）</p><p> 最少知道的原则：一个实体应当尽量少跟其他实体之间发生相互的作用，是得系统模块相对</p></li><li><p>合成复用原则（composite Reuse Priciple）</p><p> 尽量使用合成&#x2F;聚合方式，而不是使用继承</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-Phpfpm进程管理的三种模式</title>
      <link href="/blog/2021/05/10/tech/backend/php/PHP-Phpfpm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2021/05/10/tech/backend/php/PHP-Phpfpm%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-Phpfmp-如何分配任务到子进程的</title>
      <link href="/blog/2021/05/10/tech/backend/php/PHP-Phpfmp-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84/"/>
      <url>/blog/2021/05/10/tech/backend/php/PHP-Phpfmp-%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E5%88%B0%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://blog.csdn.net/liuqun0319/article/details/92573976?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.vipsorttest&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.vipsorttest">https://blog.csdn.net/liuqun0319/article/details/92573976?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-笔记5-gin开发规范</title>
      <link href="/blog/2021/04/29/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B05-gin%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/blog/2021/04/29/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B05-gin%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="go语言web框架基线版本">Go语言Web框架基线版本</span></h2><h3><span id="一框架简介">一.框架简介</span></h3><p>此web框架已gin为核心，包含了mysq、redis、rabbitmq、log、es等基础组件。<br>此框架内dockerfile和makefile已适配中台的打镜像流程，一般情况下不需要对这两个文件进行修改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── controller //控制器</span><br><span class="line">│   └── v1</span><br><span class="line">├── dao //dao层</span><br><span class="line">│   ├── mysql</span><br><span class="line">│   └── redis</span><br><span class="line">├── db //mysql文件初始化</span><br><span class="line">├── docs //swagger 接口文档</span><br><span class="line">├── middleware //中间件</span><br><span class="line">├── model //model层</span><br><span class="line">│   ├── mapi</span><br><span class="line">│   ├── mdb</span><br><span class="line">│   ├── mmysql</span><br><span class="line">│   └── mparam</span><br><span class="line">├── pconst //常量定义</span><br><span class="line">├── route //路由层</span><br><span class="line">│   └── v1</span><br><span class="line">├── script //脚本层</span><br><span class="line">│   └── logic</span><br><span class="line">├── server //服务启动</span><br><span class="line">├── service //业务层</span><br><span class="line">├── tgo //基础组件</span><br><span class="line">└── util //工具包</span><br><span class="line">    ├── curl</span><br><span class="line">    └── ip</span><br></pre></td></tr></table></figure><h3><span id="二框架分层">二.框架分层</span></h3><h4><span id="21路由层">2.1.路由层</span></h4><p>框架采用强路由模式，支持路由群组、中间件模式，自带跨域组件并默认开启，路由文件存放在 route 目录下</p><h4><span id="22控制器层">2.2.控制器层</span></h4><p>控制器存放在controller目录下，并区分版本，此层仅针对参数进行过滤处理，不处理相关业务。已集成swagger自动生成接口文档</p><h4><span id="23业务层">2.3.业务层</span></h4><p>业务层存放在service目录下，用来处理业务相关的逻辑</p><h4><span id="24数据处理层">2.4.数据处理层</span></h4><p>业务层存放在dao目录下，并根据下游不同服务放入不同目录下，此层仅处理数据，不处理业务相关逻辑</p><h4><span id="25对象层">2.5.对象层</span></h4><p>对象层存放在mode目录下，并根据对象的不同类型存放下级不同目录</p><h4><span id="26中间件层">2.6.中间件层</span></h4><p>中间件层存放在middleware目录下，用以对同一分组或具有相同特征的路由进行全局业务处理</p><h4><span id="27脚本层">2.7.脚本层</span></h4><p>脚本层存放在script目录下，用以处理非http类型的业务类型</p><h4><span id="28常量层">2.8.常量层</span></h4><p>常量定义存放在pconst目录下</p><h3><span id="三整体流程">三.整体流程</span></h3><p>框架整体请求请求流程为route - middleware - controller - service - dao，控制器、业务、数据处理禁止逆向调用</p><h3><span id="四请求示例">四.请求示例</span></h3><p>参考控制器下 log_platform.go 文件</p><h3><span id="五中台服务间调用">五.中台服务间调用</span></h3><blockquote><p>gosdk使用和服务间调用有问题和建议可以联系联系基础架构部：张超</p></blockquote><p>中台服务间调用通过<a href="https://gitlab.oneitfarm.com/bifrost/gosdk">gosdk</a>进行调用，gosdk如何使用可以参考服务内的readme文档。 </p><p>为了降低使用成本，我们对gosdk进行了一次封装<a href="https://gitlab.oneitfarm.com/ci123sdk/requester">requester</a>包，并提供了一个案例<a href="https://gitlab.oneitfarm.com/ci123sdk/account">account</a>服务的接口封装。</p><p>【强烈建议】：对子服务（比如A）的调用封装成单独的包，并在gitlab.oneitfarm.com&#x2F;ci123sdk group下创建项目A，将服务A的接口调用封装。这样其他项目（人）在接入A项目时，不需要再重复封装此部分内容。<br>简单来说就是每个服务在ci123sdk的group下创建项目，后续所有对此服务调用的封装都在此项目中，所有引用此服务的服务或应用，只需要引用此包进行开发，如果支持接口不全就在此项目中完善并打新的tag增加版本。</p><h3><span id="六关于pr">六.关于PR</span></h3><p>有任何疑问或者建议，欢迎随时联系基础架构部：陶圣，也欢迎各位提交有价值的PR，也将纳入年终绩效考核一部分</p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> farmworker </tag>
            
            <tag> gin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能库zap gox</title>
      <link href="/blog/2021/04/29/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B04-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%93zap/"/>
      <url>/blog/2021/04/29/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B04-%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%93zap/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="zap">zap</span></h2><p>高性能日志库分析</p><h4><span id="参数配置">参数配置</span></h4><p>##GOX<br>交叉编译工具可以编译各种的环境<br>go get github.com&#x2F;mitchellh&#x2F;gox<br>gox -build-toolchain</p><p>直接运行gox。程序会一口气生成17个文件<br>横跨windows,linux,mac,freebsd,netbsd五大操作系统<br>#####固定平台<br>gox -osarch “windows&#x2F;amd64 linux&#x2F;amd64” 或<br>        gox -os “windows linux” -arch amd64</p><h4><span id="go-mod-init-命令">go mod init 命令</span></h4><p>go.sum是一个模块版本内容的校验值，用来验证当前缓存的模块。go.sum包含了直接依赖和间接依赖的包的信息，比go.mod要多一些。</p><h4><span id="查看依赖包">查看依赖包</span></h4><p>go list -m all</p><h4><span id="模块配置文本格式化">模块配置文本格式化</span></h4><p>go mod edit -fmt</p><h4><span id="windows-下开启-go111module-的命令为">Windows 下开启 GO111MODULE 的命令为：</span></h4><p>set GO111MODULE&#x3D;on 或者 set GO111MODULE&#x3D;auto</p><h4><span id="代理">代理</span></h4><p>GOPROXY&#x3D;<a href="https://goproxy.cn,direct/">https://goproxy.cn,direct</a></p><h4><span id="以索引整个-gopath">以索引整个 GOPATH</span></h4><p>.Preferences -&gt; Go -&gt; GOPATH，勾选上 Index entire GOPATH</p><hr><h4><span id="基础命令关于module的">基础命令关于module的</span></h4><p>go mod download<br>go mod download -json 参数会以JSON的格式打印下载的模块对象<br><br>go mod tidy<br>go mod tidy -v  可以将执行的信息<br>可以使用go mod tidy命令来清除它<br><br>go mod vendor<br>go mod vendor -v会将添加到vendor中的模块打印到标准输出。<br>go mod graph<br><br>打印模块依赖图</p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> zap </tag>
            
            <tag> gox </tag>
            
            <tag> module </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最近太懒了</title>
      <link href="/blog/2021/04/29/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/"/>
      <url>/blog/2021/04/29/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>自定义支持markdown只会让我的VsCode越来越卡</p><h1><span id></span></h1><p>技术性不强但是打字还慢无语了，这个打字的东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br></pre></td></tr></table></figure> <hr><p><br>强行换行</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最近太懒了</title>
      <link href="/blog/2021/04/29/personal/diary/%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/"/>
      <url>/blog/2021/04/29/personal/diary/%E6%9C%80%E8%BF%91%E5%A4%AA%E6%87%92%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>自定义支持markdown只会让我的VsCode越来越卡</p><h1><span id></span></h1><p>技术性不强但是打字还慢无语了，这个打字的东西</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(a)</span><br></pre></td></tr></table></figure> <hr><p><br>强行换行</p>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang调度-channel</title>
      <link href="/blog/2021/01/10/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B011-Channel/"/>
      <url>/blog/2021/01/10/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B011-Channel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><strong>Channel</strong></p><h3><span id="设计原理">设计原理</span></h3><p>不要通过恭喜内存的方式进行通信，二十通过通信的方式共享内存。</p><p>很多主流编程语言中，多个线程传递数据方式一般情况都是共享内存，为了解决线程竞争，需要限制同一时间读写这些变量的线程数量</p><p>虽然可以通过共享内存加互斥锁进行通信，但是go提供了一种不同并发的模型，即顺序通讯进程，</p><p>Gorouting 和channel分别对应csp中实体和传递信息媒介。</p><p><strong>gorutine通过channel传递数据</strong></p><p>两个独立的goroutine ，一个会向channel中发送数据，另一个会从channel中读取数据，两个能独立的运行，并不存在直接关联，但是通过channel完成通讯</p><p><strong>先入先出原则</strong>（FIFO）</p><ul><li>先从channel读取数据的goroutine会先接受到数据</li><li>先向channel发送数据的goroutine会得到先发送的权力</li></ul><p>这种 FIFO 的设计是相对好理解的，但是稍早的 Go 语言实现却没有严格遵循这一语义，我们能在 <a href="https://github.com/golang/go/issues/11506">runtime: make sure blocked channels run operations in FIFO order</a> 中找到关于带缓冲区的 Channel 在执行收发操作时没有遵循先进先出的讨论<a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#fn:2">2</a>。</p><ul><li>发送方会向缓冲区写入数据，然后唤醒接收方，多个接受方会先尝试从缓冲区读取数据，如果没有读取到会重新陷入休眠。</li><li>接收方会从缓冲区去读数据，然后唤醒接收方，发送方会尝试像缓冲去写入数据，如果缓冲区已满会重新陷入休眠</li></ul><p>这种基于重试的机制会导致channel的处理遵循先进先出的原则。</p><p><strong>无锁管道</strong></p><p><strong>数据结构</strong></p><p>Go在channel中运行使用runtime.hchan ,新建chnanel结构</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span></span><br><span class="line">dataqsiz <span class="type">uint</span></span><br><span class="line">buf      unsafe.Pointer</span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">elemtype *_type</span><br><span class="line">sendx    <span class="type">uint</span></span><br><span class="line">recvx    <span class="type">uint</span></span><br><span class="line">recvq    waitq</span><br><span class="line">sendq    waitq</span><br><span class="line"></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建新的channel，如上结构构造地城循环队列：五个字段</p><ul><li>qcount channel中元素个数</li><li>dataqsiz channel循环长度</li><li>buf channel缓冲指针</li><li>sendx channel发送操作处理到的位置</li><li>recvx channel 接受的操作位置</li></ul><p>除此之外，elemsize elemtype 标识channel收发的元素类型和大小</p><p>sendq和recvq存储当前channel由于缓冲区元素不足而阻塞的goroutine 列表，这些等待队列可以用双向列表runtime.waitq标识，链表中所有元素都是runtime.sudog</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 表示一个在等待列表中的 Goroutine，该结构中存储了两个分别指向前后 <a href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 的指针以构成链表。</p><p><strong>创建管道</strong></p><p>go中所有channel节点创建都会使用make关键字，编译器会将make(chan int,10)表达式转换成OMAKE类型的节点，并在类型检查阶段，将OMAKEl类型节点转为OMAKECHAN类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func typecheck1(n *Node, top int) (res *Node) &#123;</span><br><span class="line">switch n.Op &#123;</span><br><span class="line">case OMAKE:</span><br><span class="line">...</span><br><span class="line">switch t.Etype &#123;</span><br><span class="line">case TCHAN:</span><br><span class="line">l = nil</span><br><span class="line">if i &lt; len(args) &#123; // 带缓冲区的异步 Channel</span><br><span class="line">...</span><br><span class="line">n.Left = l</span><br><span class="line">&#125; else &#123; // 不带缓冲区的同步 Channel</span><br><span class="line">n.Left = nodintconst(0)</span><br><span class="line">&#125;</span><br><span class="line">n.Op = OMAKECHAN</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一阶段会对传入 <code>make</code> 关键字的缓冲区大小进行检查，如果我们不向 <code>make</code> 传递表示缓冲区大小的参数，那么就会设置一个默认值 0，也就是当前的 Channel 不存在缓冲区。</p><ul><li>如果当前 Channel 中不存在缓冲区，那么就只会为 <a href="https://draveness.me/golang/tree/runtime.hchan"><code>runtime.hchan</code></a> 分配一段内存空间；</li><li>如果当前 Channel 中存储的类型不是指针类型，会为当前的 Channel 和底层的数组分配一块连续的内存空间；</li><li>在默认情况下会单独为 <a href="https://draveness.me/golang/tree/runtime.hchan"><code>runtime.hchan</code></a> 和缓冲区分配内存；</li></ul><p>在函数的最后会统一更新 <a href="https://draveness.me/golang/tree/runtime.hchan"><code>runtime.hchan</code></a> 的 <code>elemsize</code>、<code>elemtype</code> 和 <code>dataqsiz</code> 几个字段。</p><p><strong>发送数据</strong></p><p>当我们想要向Channel发送数据时候，就需要使用ch&lt;-i语句，编译器将会将它解析冲OSEND节点，并在xxx ,转换runtime.channelsend1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">walkexpr</span><span class="params">(n *Node, init *Nodes)</span></span> *Node &#123;</span><br><span class="line"><span class="keyword">switch</span> n.Op &#123;</span><br><span class="line"><span class="keyword">case</span> OSEND:</span><br><span class="line">n1 := n.Right</span><br><span class="line">n1 = assignconv(n1, n.Left.Type.Elem(), <span class="string">&quot;chan send&quot;</span>)</span><br><span class="line">n1 = walkexpr(n1, init)</span><br><span class="line">n1 = nod(OADDR, n1, <span class="literal">nil</span>)</span><br><span class="line">n = mkcall1(chanfn(<span class="string">&quot;chansend1&quot;</span>, <span class="number">2</span>, n.Left.Type), <span class="literal">nil</span>, init, n.Left, n1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://draveness.me/golang/tree/runtime.chansend1"><code>runtime.chansend1</code></a> 只是调用了 <a href="https://draveness.me/golang/tree/runtime.chansend"><code>runtime.chansend</code></a> 并传入 Channel 和需要发送的数据。<a href="https://draveness.me/golang/tree/runtime.chansend"><code>runtime.chansend</code></a> 是向 Channel 中发送数据时一定会调用的函数，该函数包含了发送数据的全部逻辑，如果我们在调用时将 <code>block</code> 参数设置成 <code>true</code>，那么表示当前发送操作是阻塞的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止多个线程并发修改数据。如果 Channel 已经关闭，那么向该 Channel 发送数据时会报 “send on closed channel” 错误并中止程序。</p><p>因为 <a href="https://draveness.me/golang/tree/runtime.chansend"><code>runtime.chansend</code></a> 函数的实现比较复杂，所以我们这里将该函数的执行过程分成以下的三个部分：</p><ul><li>当存在等待的接收者时，通过 <a href="https://draveness.me/golang/tree/runtime.send"><code>runtime.send</code></a> 直接将数据发送给阻塞的接收者；</li><li>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；</li><li>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li></ul><p>小结：</p><h3><span id="小结">小结 </span></h3><p>我们在这里可以简单梳理和总结一下使用 <code>ch &lt;- i</code> 表达式向 Channel 发送数据时遇到的几种情况：</p><ol><li>如果当前 Channel 的 <code>recvq</code> 上存在已经被阻塞的 Goroutine，那么会直接将数据发送给当前 Goroutine 并将其设置成下一个运行的 Goroutine；</li><li>如果 Channel 存在缓冲区并且其中还有空闲的容量，我们会直接将数据存储到缓冲区 <code>sendx</code> 所在的位置上；</li><li>如果不满足上面的两种情况，会创建一个 <a href="https://draveness.me/golang/tree/runtime.sudog"><code>runtime.sudog</code></a> 结构并将其加入 Channel 的 <code>sendq</code> 队列中，当前 Goroutine 也会陷入阻塞等待其他的协程从 Channel 接收数据；</li></ol><p>发送数据的过程中包含几个会触发 Goroutine 调度的时机：</p><ol><li>发送数据时发现 Channel 上存在等待接收数据的 Goroutine，立刻设置处理器的 <code>runnext</code> 属性，但是并不会立刻触发调度；</li><li>发送数据时并没有找到接收方并且缓冲区已经满了，这时会将自己加入 Channel 的 <code>sendq</code> 队列并调用 <a href="https://draveness.me/golang/tree/runtime.goparkunlock"><code>runtime.goparkunlock</code></a> 触发 Goroutine 的调度让出处理器的使用权；</li></ol>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>以及如何使用rpc</title>
      <link href="/blog/2020/09/19/tech/network/http/GRPC-go-php/"/>
      <url>/blog/2020/09/19/tech/network/http/GRPC-go-php/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="http://doc.oschina.net/grpc?t=57966">http://doc.oschina.net/grpc?t=57966</a></p><p>gRPC 基于 HTTP&#x2F;2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。<br>gRPC 也是基于以下理念：定义一个服务，指定其能够被远程调用的方法（包含参数和返回类型）。在服务端实现这个接口，并运行一个 gRPC 服务器来处理客户端调用。在客户端拥有一个存根能够像服务端一样的方法。</p><p>正如其他 RPC 系统，gRPC 基于如下思想：定义一个服务， 指定其可以被远程调用的方法及其参数和返回类型。gRPC 默认使用 protocol buffers 作为接口定义语言，来描述服务接口和有效载荷消息结构。如果有需要的话，可以使用其他替代方案。</p><p>使用 protocol buffers</p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-解决循环内存占用溢出-缓冲查询</title>
      <link href="/blog/2020/09/02/tech/backend/php/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/"/>
      <url>/blog/2020/09/02/tech/backend/php/PHP-%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E6%BA%A2%E5%87%BA-%E7%BC%93%E5%86%B2%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-深拷贝浅拷贝-_clone</title>
      <link href="/blog/2020/09/02/tech/backend/php/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/blog/2020/09/02/tech/backend/php/PHP-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><ul><li><p>深拷贝&#x2F;&#x2F;变量复制了一份传递给另一个变量就是深拷贝,一个值改变了,另一个值不会变（直接复制）</p></li><li><p>浅拷贝&#x2F;&#x2F;变量之间的值是地址*|&amp;传递,这就是浅拷贝.值如果改变了两个变量的值都会改变 （引用复制，可变）</p></li></ul><blockquote><p>关键次 _clone</p></blockquote><ul><li>对象赋值：浅拷贝</li><li>普通类型的变量是深拷贝</li></ul><h4><span id="php默认浅拷贝即普通赋值">php默认浅拷贝即普通赋值</span></h4><blockquote><p>例1：</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Persion</span><br><span class="line">&#123;</span><br><span class="line">public $age = 0;</span><br><span class="line">public $name = &#x27;xiapeifus&#x27;;</span><br><span class="line">public $obj = null;</span><br><span class="line">&#125;</span><br><span class="line">$persion = new Persion();</span><br><span class="line">$xiaoming = clone $persion; //使用clone关键字复制一份$a的值,进行深拷贝.拷贝之后不会改变$a之前的值</span><br><span class="line">$xiaoming-&gt;age = 1;</span><br><span class="line">var_dump($persion-&gt;age);// 0</span><br><span class="line">var_dump($xiaoming-&gt;age);// 1</span><br></pre></td></tr></table></figure><blockquote><p>&#x2F;&#x2F;例2：增加__clone对象的赋值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">class doclone&#123;</span><br><span class="line">    private $id,$name,$address;</span><br><span class="line">    public function __construct($id=0,$name=&#x27;&#x27;,$address=&#x27;&#x27;)&#123;</span><br><span class="line">        $this-&gt;name=$name;</span><br><span class="line">        $this-&gt;id=$id;</span><br><span class="line">        $this-&gt;address=$address;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_id()&#123;</span><br><span class="line">        return $this-&gt;id;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_name()&#123;</span><br><span class="line">        return $this-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">    public function get_address()&#123;</span><br><span class="line">        return $this-&gt;address;</span><br><span class="line">    &#125;</span><br><span class="line">    public function __clone()&#123;</span><br><span class="line">        $this-&gt;id=$this-&gt;id+1;</span><br><span class="line">        $this-&gt;name=&#x27;wqw&#x27;;</span><br><span class="line">        $this-&gt;address=&#x27;USA&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$A = new doclone(1,&#x27;xiapeifu&#x27;,&#x27;UK&#x27;);</span><br><span class="line">echo &#x27;克隆之前的对象:&#x27;;</span><br><span class="line">echo &#x27;id=&#x27;.$A-&gt;get_id();</span><br><span class="line">echo &#x27;name=&#x27;.$A-&gt;get_name();</span><br><span class="line">echo &#x27;address=&#x27;.$A-&gt;get_address();</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$B = clone $A;</span><br><span class="line">echo &#x27;克隆过后的对象：&#x27;;</span><br><span class="line">echo &#x27;id=&#x27;.$A-&gt;get_id();</span><br><span class="line">echo &#x27;name=&#x27;.$A-&gt;get_name();</span><br><span class="line">echo &#x27;address=&#x27;.$A-&gt;get_address();</span><br><span class="line">echo &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">echo &#x27;克隆过后的对象属性:&#x27;;</span><br><span class="line">echo &#x27;id=&#x27;.$B-&gt;get_id();</span><br><span class="line">echo &#x27;name=&#x27;.$B-&gt;get_name();</span><br><span class="line">echo &#x27;address=&#x27;.$B-&gt;get_address();</span><br><span class="line">//结果</span><br><span class="line">//克隆之前的对象:id=1name=xiapeifuaddress=UK</span><br><span class="line">//克隆过后的对象：id=1name=xiapeifuaddress=UK</span><br><span class="line">//克隆过后的对象属性:id=2name=wqwaddress=USA</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>思考：colne 关键词 当对象没__colne 方法时候类似于new 一个对象出来没区别<br>        当对象有__clone时候会在clone里面的重新赋值新的属性，类似于重新new 一个对象 ，只不过把重新new的对象进行一些默认操作，其实重新new一个对象重新赋值也一样，clone可能就是单纯炫技吧</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git-代码提交规范</title>
      <link href="/blog/2020/09/02/tech/devops/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/"/>
      <url>/blog/2020/09/02/tech/devops/Git-%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Git commit message 是Git提交的必要信息，message的信息完整度也反映了工程师对于代码提交的重视程度，不清晰的git message信息甚至会让工程师完全回忆不起自己当初做了什么调整，导致后续代码维护成本特别大。因此为了提高线上代码库的管理程度，特此制定GIT commit message规范。</p><p>一、commit message格式<br>1、Type(必须)<br>用于说明 git commit 的类别，只允许使用下面的标识。<br>feat：新功能（feature）。<br>fix&#x2F;to：修复bug，可以是QA发现的BUG，也可以是研发自己发现的BUG。<br>fix：产⽣diff并自动修复此问题。适合于一次提交直接修复问题<br>to：只产⽣diff不自动修复此问题。适合于多次提交。最终修复问题提交时使用fix<br>docs：文档（documentation）。<br>style：格式（不影响代码运行的变动）。<br>refactor：重构（即不是新增功能，也不是修改bug的代码变动）。<br>perf：优化相关，比如提升性能、体验。<br>test：增加测试。<br>chore：构建过程或辅助工具的变动。<br>revert：回滚到上一个版本。<br>merge：代码合并。<br>sync：同步主线或分⽀的Bug</p><p>2、scope(可选)<br>scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。<br>例如在Angular，可以是location，browser，compile，compile，rootScope， ngHref，ngClick，ngView等。<br>如果你的修改影响了不止一个scope，你可以使用*代替。</p><p>3、subject(必须)<br>subject是commit目的的简短描述，不超过50个字符。<br>1.建议使用中文。<br>2.结尾不加句号或其他标点符号。<br>根据以上规范 git commit message 将是如下的格式：<br>fix(DAO): 用户查询缺少username属性<br>feat(Controller): 用户查询接口开发</p><p>二、规范的好处<br>我们这样规范git commit到底有哪些好处呢？<br>1.便于程序员对提交历史进行追溯，了解发⽣了什么情况。<br>2.一旦约束了commit message，意味着我们将慎重的进行每一次提交，不能再一股脑的把各种各样的改动都放在一个git commit里面，这样一来整个代码改动的历史也将更加清晰。<br>3.格式化的commit message才可以用于自动化输出Change log。</p><p>三、标准执行监管<br>为了更好的执行标准，公司针对git提交会进行相关监管功能的研发，当工程师提了不合规的commit，会收到相关的邮件警告。</p>]]></content>
      
      
      <categories>
          
          <category> git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端-npm私有源加载平台</title>
      <link href="/blog/2020/09/01/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
      <url>/blog/2020/09/01/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="调研平台sinopiaverdaccio">调研平台：sinopia，Verdaccio</span></h3><h4><span id="verdaccio">Verdaccio</span></h4><h5><span id="官方文档">官方文档</span></h5><p><a href="https://verdaccio.org/docs/en/configuration">https://verdaccio.org/docs/en/configuration</a></p><p>搭建：</p><h5><span id="认证方式">认证方式</span></h5><p>身份验证与您正在使用的auth <a href="https://verdaccio.org/docs/en/plugins">插件相关</a>。软件包限制也由<a href="https://verdaccio.org/docs/en/packages">Package Access</a>处理。</p><p>客户端：基于npm客户端登录后会生成一个配置令牌，在.npmrc中</p><p><a href="https://docs.npmjs.com/files/npmrc">https://docs.npmjs.com/files/npmrc</a></p><p>且允许匿名发布包</p><p>包发布的时候允许阻止访问和下载</p><p>服务端关于组的验证:</p><p>​    access: $all-&gt;<br>​    publish: $all<br>​    proxy: npmjs</p><p><img src="//s2-cdn.oneitfarm.com/186bdf368bd54a57b12eb71ba2e10636.png" alt="image-20200901175328057"></p><p> 不同的包读取权限限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages</span>:</span><br><span class="line">  <span class="string">&#x27;jquery&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $all</span><br><span class="line">  <span class="string">&#x27;my-company-*&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">  <span class="string">&#x27;@my-local-scope/*&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br></pre></td></tr></table></figure><p>组 定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;company-*&#x27;:</span><br><span class="line">  access: admin internal</span><br><span class="line">  publish: admin</span><br><span class="line">  proxy: server1</span><br><span class="line">&#x27;supersecret-*&#x27;:</span><br><span class="line">  access: secret super-secret-area ultra-secret-area</span><br><span class="line">  publish: secret ultra-secret-area</span><br><span class="line">  proxy: server1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端-npm私有源加载平台</title>
      <link href="/blog/2020/09/01/tech/frontend/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/"/>
      <url>/blog/2020/09/01/tech/frontend/%E5%89%8D%E7%AB%AF-npm%E7%A7%81%E6%9C%89%E6%BA%90%E5%8A%A0%E8%BD%BD%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="调研平台sinopiaverdaccio">调研平台：sinopia，Verdaccio</span></h3><h4><span id="verdaccio">Verdaccio</span></h4><h5><span id="官方文档">官方文档</span></h5><p><a href="https://verdaccio.org/docs/en/configuration">https://verdaccio.org/docs/en/configuration</a></p><p>搭建：</p><h5><span id="认证方式">认证方式</span></h5><p>身份验证与您正在使用的auth <a href="https://verdaccio.org/docs/en/plugins">插件相关</a>。软件包限制也由<a href="https://verdaccio.org/docs/en/packages">Package Access</a>处理。</p><p>客户端：基于npm客户端登录后会生成一个配置令牌，在.npmrc中</p><p><a href="https://docs.npmjs.com/files/npmrc">https://docs.npmjs.com/files/npmrc</a></p><p>且允许匿名发布包</p><p>包发布的时候允许阻止访问和下载</p><p>服务端关于组的验证:</p><p>​    access: $all-&gt;<br>​    publish: $all<br>​    proxy: npmjs</p><p><img src="//s2-cdn.oneitfarm.com/186bdf368bd54a57b12eb71ba2e10636.png" alt="image-20200901175328057"></p><p> 不同的包读取权限限制：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">packages</span>:</span><br><span class="line">  <span class="string">&#x27;jquery&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $all</span><br><span class="line">  <span class="string">&#x27;my-company-*&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">  <span class="string">&#x27;@my-local-scope/*&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">  <span class="string">&#x27;**&#x27;</span>:</span><br><span class="line">    <span class="attr">access</span>: $all</span><br><span class="line">    <span class="attr">publish</span>: $authenticated</span><br><span class="line">    <span class="attr">proxy</span>: npmjs</span><br></pre></td></tr></table></figure><p>组 定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;company-*&#x27;:</span><br><span class="line">  access: admin internal</span><br><span class="line">  publish: admin</span><br><span class="line">  proxy: server1</span><br><span class="line">&#x27;supersecret-*&#x27;:</span><br><span class="line">  access: secret super-secret-area ultra-secret-area</span><br><span class="line">  publish: secret ultra-secret-area</span><br><span class="line">  proxy: server1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>其他-CRLF、CR、LF详解</title>
      <link href="/blog/2020/09/01/other/wiki/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2020/09/01/other/wiki/%E5%85%B6%E4%BB%96-CRLF%E3%80%81CR%E3%80%81LF%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>很长一段时间里，对于CRLF、CR、LF的理解仅限于不同操作系统下对换行符的定义。所谓知其然需知其所以然，从学习中找到乐趣，对知识的记忆才会更加深刻。</p><p>名词解释<br>CR：Carriage Return，对应ASCII中转义字符\r，表示回车<br>LF：Linefeed，对应ASCII中转义字符\n，表示换行<br>CRLF：Carriage Return &amp; Linefeed，\r\n，表示回车并换行<br>众所周知，Windows操作系统采用两个字符来进行换行，即CRLF；Unix&#x2F;Linux&#x2F;Mac OS X操作系统采用单个字符LF来进行换行；另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。</p><p>野史<br>老式机械打字机（来源：视觉中国）<br>据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。</p><p>当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。</p><p>随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。</p><p>结论<br>许多现代的文本编辑器和命令行工具都提供了可选择的换行符配置，方便用户按照自己的意愿来改变换行符的表现形式，所以我们只需要知道CRLF、CR、LF的作用即可。</p><p>参考文献<br><a href="http://en.wikipedia.org/wiki/Newline">http://en.wikipedia.org/wiki/Newline</a><br><a href="https://en.wikipedia.org/wiki/Control_character">https://en.wikipedia.org/wiki/Control_character</a><br><a href="https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types">https://stackoverflow.com/questions/1552749/difference-between-cr-lf-lf-and-cr-line-break-types</a></p><p>作者：JSoon<br>链接：<a href="https://www.jianshu.com/p/b03ad01acd69">https://www.jianshu.com/p/b03ad01acd69</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于blog更新周期</title>
      <link href="/blog/2020/08/31/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/"/>
      <url>/blog/2020/08/31/%E6%88%91%E7%9A%84%E6%97%A5%E8%AE%B0/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>每周 三篇基础知识文档编写</p><p>每两周一次总结工作情况</p><p>每月一次的软件使用教程记录</p>]]></content>
      
      
      <categories>
          
          <category> diary </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于blog更新周期</title>
      <link href="/blog/2020/08/31/personal/diary/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/"/>
      <url>/blog/2020/08/31/personal/diary/%E5%85%B3%E4%BA%8Eblog%E6%9B%B4%E6%96%B0%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>每周 三篇基础知识文档编写</p><p>每两周一次总结工作情况</p><p>每月一次的软件使用教程记录</p>]]></content>
      
      
      <categories>
          
          <category> 个人随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-辅助函数</title>
      <link href="/blog/2020/08/28/tech/backend/php/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2020/08/28/tech/backend/php/PHP-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP-匿名类匿名函数（闭包）</title>
      <link href="/blog/2020/08/28/tech/backend/php/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/"/>
      <url>/blog/2020/08/28/tech/backend/php/PHP-%E5%8C%BF%E5%90%8D%E7%B1%BB%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4><span id="1写一个匿名函数">1.写一个匿名函数</span></h4><blockquote><p>类中 的写法</p></blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">array_reduce</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], function (<span class="variable">$result</span>, <span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">array_merge</span>(<span class="variable">$result</span>, <span class="title function_ invoke__">array_values</span>(<span class="variable">$value</span>));</span><br><span class="line">        &#125;, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//第二种写法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">qq2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//将匿名函数交个一个变量</span></span><br><span class="line">        <span class="variable">$a</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$result</span>, <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">array_merge</span>(<span class="variable">$result</span>, <span class="title function_ invoke__">array_values</span>(<span class="variable">$value</span>));</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="variable">$result</span> = <span class="title function_ invoke__">array_reduce</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>], <span class="variable">$a</span>, <span class="keyword">array</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="2理解一个闭包匿名函数">2.理解一个闭包（匿名函数）</span></h4><p>目前php用到闭包的数组函数包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">array_map — 为数组的每个元素应用回调函数</span><br><span class="line">array_walk — 使用用户自定义函数对数组中的每个元素做回调处理</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">array_filter — 用回调函数过滤数组中的单元</span><br><span class="line">该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回结果数组中。数组键名保持不变。</span><br><span class="line">array_intersect_uassoc — 带索引检查计算数组的交集，用回调函数比较索引</span><br><span class="line">array_intersect_ukey — 用回调函数比较键名来计算数组的交集</span><br><span class="line">array_reduce — 用回调函数迭代地将数组简化为单一的值</span><br><span class="line">拼接成类似 (1,2,3,4,5) </span><br><span class="line"></span><br><span class="line">array_walk_recursive — 对数组中的每个成员递归地应用用户函数</span><br><span class="line">----等等</span><br><span class="line">常用的就是: array_map array_walk</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4><span id="3临时总结">3.临时总结</span></h4><p><strong>异同点</strong><br> array_filter() 重点在于过滤（而不是新增）某个元素，当你处理到一个元素时，返回过滤后的数组<br> array_map() 重点在于遍历一个数组或多个数组的元素，返回一个新的数组<br> array_walk() 重点在于遍历数组进行某种操作</p><p> array_filter() 和 array_walk()对一个数组进行操作，数组参数在前，函数参数在后<br> array_map() 可以处理多个数组，因此函数参数在前，数组参数在后，可以根据实际情况放入多个数组参数</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Closure </tag>
            
            <tag> 匿名函数 </tag>
            
            <tag> 匿名类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-运行模式cli fastcgi</title>
      <link href="/blog/2020/08/28/tech/backend/php/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/08/28/tech/backend/php/PHP-%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><strong>1.cgi全称“通用网关接口”(Common Gateway Interface)， 它可以让一个客户端，从浏览器向Web服务器上的程序请求数据，是客户端和程序之间传输数据的一种标准，另外CGI独立于任何语言，所以可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如php,perl,tcl等。CGI针对每个用户请求都要开单独的子进程去维护，执行结束处理掉这个进程。典型的fork-and-execute方式</strong></p><p>　　<strong>2.fastcgi，根据1中cgi的特性，可以知道消耗很大，如果很多用户请求，则会申请很多个子进程。。这时候出现了FastCGI。FastCGI 像是一个常驻 (long-live) 型的 CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次 (这是 CGI 最为人诟病的 fork-and-execute 模式)。这个是当下用的最多的了。。linux+nginx+php+mysql</strong></p><p>　FastCGI的工作原理是：</p><p><em>(1)、Web Server启动时载入FastCGI进程管理器【PHP的FastCGI进程管理器是PHP-FPM(php-FastCGI Process Manager)】（nginx);</em><br><em>(2)、FastCGI进程管理器自身初始化，启动多个CGI解释器进程 (在任务管理器中可见多个php-cgi.exe)并等待来自WebServer的连接。</em><br><em>(3)、当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi。</em><br><em>(4)、FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器（运行在 WebServer中）的下一个连接。在正常的CGI模式中，php-cgi或 .exe在此便退出了。</em><br><em>在CGI模式中，你可以想象 CGI通常有多慢。每一个Web请求PHP都必须重新解析php.ini、重新载入全部dll扩展并重初始化全部数据结构。使用FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接(Persistent database connection)可以工作。</em><br>　　<em>3.module形式一般用于apache，模块模式是以mod_php5模块的形式集成，此时mod_php5模块的作用是接收Apache传递过来的PHP文件请求，并处理这些请求，然后将处理后的结果返回给Apache。</em><br>　　<em>4.cli模式。命令行执行php，一般不用。我们在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式；也可以直接命令行执行php xxx.php</em></p><h4><span id="1php一共分为五大运行模式包括ducgi-fast-cgi-cli-isapi-apache-模块的-dllcgi">1.php一共分为五大运行模式：包括ducgi 、fast-cgi、cli、isapi、apache 模块的 DLLCGI</span></h4><p>  关于PHP目前比较常见的五大运行模式：</p><p>1）CGI（通用网关接口&#x2F; Common Gateway Interface）<br>2）FastCGI（常驻型CGI &#x2F; Long-Live CGI）<br>3）CLI（命令行运行 &#x2F; Command Line Interface）<br>4）LoadModule（Apache独有）：<br>在Apache配置文件httpd.conf里，通常加的LoadModule php7_module “D:&#x2F;…&#x2F;php71&#x2F;php7apache2_4.dll”起到的作用就是这个<br>5）ISAPI（Internet Server Application Program Interface）<br>IIS独有：<br>备注：在PHP5.3以后，PHP不再有ISAPI模式，安装后也不再有php5isapi.dll这个文件。要在IIS6上使用高版本PHP，必须安装FastCGI 扩展，然后使IIS6支持FastCGI。  </p><h3><span id="2-php-cli-与php-fpmfastcgi-process-manager">2、php-cli 与php-fpm（fastcgi process manager）</span></h3><p><img src="https://img-blog.csdnimg.cn/20190420173441325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lpbnFpYW45OTk=,size_16,color_FFFFFF,t_70" alt="[**CGI、FastCGI和PHP-FPM关系图解**](https://www.awaimai.com/371.html)"></p><p>cli 模式就是常见的命令使用的php命令，其实他也可以提供http请求服务，内置了http服务器<br>fpm 是一个多进程架构的FastCgi 服务，内置PHP解释器进程常驻后台，自带进程管理支持进程池配置和配置Nginx使用</p><p>cli 和fpm 是两个运行方式</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cgi </tag>
            
            <tag> fastcgi </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-理解php的Generator,yield,Iterator接口</title>
      <link href="/blog/2020/08/28/tech/backend/php/PHP-%E7%90%86%E8%A7%A3php%E7%9A%84Generator,yield,Iterator%E6%8E%A5%E5%8F%A3/"/>
      <url>/blog/2020/08/28/tech/backend/php/PHP-%E7%90%86%E8%A7%A3php%E7%9A%84Generator,yield,Iterator%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新<br>yield<br>解决读取大文</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Generator </tag>
            
            <tag> yield </tag>
            
            <tag> Iterator - 等待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他-server酱打卡网易云</title>
      <link href="/blog/2020/08/26/other/wiki/%E5%85%B6%E4%BB%96-Server%E9%85%B1%E6%89%93%E5%8D%A1%E7%BD%91%E6%98%93%E4%BA%91%20%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/blog/2020/08/26/other/wiki/%E5%85%B6%E4%BB%96-Server%E9%85%B1%E6%89%93%E5%8D%A1%E7%BD%91%E6%98%93%E4%BA%91%20%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网易云 server酱 py 云函数  待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker-info</title>
      <link href="/blog/2020/08/20/tech/devops/docker/Docker-%E5%88%B6%E4%BD%9C-1/"/>
      <url>/blog/2020/08/20/tech/devops/docker/Docker-%E5%88%B6%E4%BD%9C-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4><span id="注册登录">注册登录</span></h4><p><a href="https://hub.docker.com/">https://hub.docker.com/</a></p><h4><span id="docker快捷键">Docker快捷键</span></h4><blockquote><p>常用： start restart stop  images ps-a</p></blockquote><h5><span id="带有参数的使用">带有参数的使用</span></h5><p>docker ps -a ：查看最近使用的容器id</p><p>docker rm 容器id:删除某个容器</p><p>docker images</p><p>docker rmi 镜像id:删除某个镜像</p><p>docker run :</p><p>docker run -d -p 9200:9200 -p 5601:5601 nshou&#x2F;elasticsearch-kibana</p><blockquote><p>-d 后台运行，-p 内部端口&#x2F;宿主机端口 容器id</p></blockquote><p>docker exec -it &#x2F;bash :进入容器</p><p>docker login -u xx -p xxx：登录</p><h4><span id="配置加速源">配置加速源</span></h4><p>1.阿里云：百度如何通过阿里云加速docker拉取和推送速度</p><p>2.DaoCloud ：大公司，国内的。网站：<a href="https://www.daocloud.io/mirror">https://www.daocloud.io/mirror</a></p><blockquote><p>加速url</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux:curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io</span><br></pre></td></tr></table></figure><p>原理：编辑   &#x2F;etc&#x2F;docker&#x2F;daemon.json  这个文件夹</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;registry-mirrors&quot;: [&quot;http://f1361db2.m.daocloud.io&quot;,&quot;https://vbw6t0eb.mirror.aliyuncs.com&quot;]&#125;</span><br></pre></td></tr></table></figure><h4><span id="查看当前docker配置文件">查看当前docker配置文件</span></h4><p>docker info :可以查看是否配置成功加速 版本信息等各种信息</p><h4><span id="打包镜像源和推送到dockerio">打包镜像源和推送到docker.io</span></h4><p>1.docker pull xxx镜像:tag</p><p>2.docker images 查看镜像</p><p>3.docker run -d -p 8080:8081 xxx镜像:version</p><p>4.docker ps -a 查看是不是启动了，然后stop start restart 找找感觉</p><p>5.docker exec -it 镜像id bash :进入镜像进行修改：拉代码，查bug ,增加mysql实例等</p><p>6.docker commit -m “php71-daemon:xhprof-graphviz” -a “some” f69187b4375e “18260356308&#x2F;php71-daemon:xhprof”</p><p>​docker commit -m “提交log” -a “作者”  容器id “docker账户名&#x2F;自定义镜像名：tag” 就会制作成一个新的image了</p><p>7.执行docker push xxx镜像的id：</p><blockquote><p>tips:</p><p>前提是得登录，还有  注意一个问题,给自己镜像命名的时候格式应该是: docker注册用户名&#x2F;镜像名,比如我的docker用户名为 test123,那么我的镜像tag就为 test123&#x2F;whalesay,不然是push不上去的</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> DOCKER </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docekr images </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-xhprof-性能优化</title>
      <link href="/blog/2020/08/20/tech/backend/php/PHP-xhprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2020/08/20/tech/backend/php/PHP-xhprof-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="简介">简介</span></h3><hr><h3><span id="安装">安装</span></h3><hr><h3><span id="嵌入代码">嵌入代码</span></h3><hr><h3><span id="查看分析报告">查看分析报告</span></h3><hr><h3><span id="总结">总结</span></h3><hr><h3><span id="名词解释">名词解释</span></h3><p>Function Name：方法名称。</p><p>Calls：方法被调用的次数。</p><p>Calls%：方法调用次数在同级方法总数调用次数中所占的百分比。</p><p>Incl.Wall Time(microsec)：方法执行花费的时间，包括子方法的执行时间。（单位：微秒）</p><p>IWall%：方法执行花费的时间百分比。</p><p>Excl. Wall Time(microsec)：方法本身执行花费的时间，不包括子方法的执行时间。（单位：微秒）</p><p>EWall%：方法本身执行花费的时间百分比。</p><p>Incl. CPU(microsecs)：方法执行花费的CPU时间，包括子方法的执行时间。（单位：微秒）</p><p>ICpu%：方法执行花费的CPU时间百分比。</p><p>Excl. CPU(microsec)：方法本身执行花费的CPU时间，不包括子方法的执行时间。（单位：微秒）</p><p>ECPU%：方法本身执行花费的CPU时间百分比。</p><p>Incl.MemUse(bytes)：方法执行占用的内存，包括子方法执行占用的内存。（单位：字节）</p><p>IMemUse%：方法执行占用的内存百分比。</p><p>Excl.MemUse(bytes)：方法本身执行占用的内存，不包括子方法执行占用的内存。（单位：字节）</p><p>EMemUse%：方法本身执行占用的内存百分比。</p><p>Incl.PeakMemUse(bytes)：Incl.MemUse峰值。（单位：字节）</p><p>IPeakMemUse%：Incl.MemUse峰值百分比。</p><p>Excl.PeakMemUse(bytes)：Excl.MemUse峰值。单位：（字节）</p><p>EPeakMemUse%：Excl.MemUse峰值百分比。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xhprof docker push </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG-笔记-ArrayMapSlice</title>
      <link href="/blog/2020/06/29/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B02-ArrayMapSlice/"/>
      <url>/blog/2020/06/29/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B02-ArrayMapSlice/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h4><span id="1golang-数据类型">1.golang 数据类型</span></h4><p>1、基本数据类型：整形、浮点、布尔、字符串、字符<br>2、复合数据类型：函数与指针、数组、切片、map、list、结构体、通道</p><h4><span id="11-函数与指针">1.1 函数与指针</span></h4><p>函数：func（）<br>指针：* 代表指针 &amp; 去地址符 （引用传值）</p><p>*可以表示一个变量是指针类型 , 也可以表示一个指针变量所指向的存储单元 , 也就是这个地址所存储的值 .<br>打印 *类型数据获取的一堆2进制数据</p><p>&amp;对变量取地址 即取得某个变量的地址 , 如 ; &amp;a</p><h4><span id="12数组">1.2数组</span></h4><p>Array(数组)<br>数组是很有价值的数据结构，因为它的内存分配是连续的，内存连续意味着可是让它在 CPU 缓存中待更久，所以迭代数组和移动元素都会非常迅速。</p><ul><li>数组所有 的key 都是int 默认从0 开始，string类型的是map和list其他，不建议使用数组，一般直接上切片</li><li>var 变量名 [数组长度]数据类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var a [4]int</span><br><span class="line">println(a)</span><br><span class="line">d := [3]int&#123;1, 2, 4&#125;</span><br><span class="line">println(d)</span><br><span class="line">f := [...]int&#123;1, 2, 4, 5, 6&#125; //... 省略数组长度 自动计算</span><br><span class="line">println(f)</span><br><span class="line"></span><br><span class="line">a2 := [...]int&#123;1, 2, 4: 5, 6&#125;</span><br><span class="line">println(a2)</span><br><span class="line">for key, val := range a2 &#123;</span><br><span class="line">println(key,val)</span><br><span class="line">&#125;</span><br><span class="line"> // 二维数组赋值 </span><br><span class="line">var arrayarr = [3][4]int&#123;&#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;&#125;</span><br><span class="line">dd := [...][...]string&#123;</span><br><span class="line">&#123;&quot;3&quot;, &quot;4&quot;&#125;,</span><br><span class="line">&#123;&quot;c&quot;, &quot;2&quot;&#125;,</span><br><span class="line">&#125;</span><br><span class="line">println(dd)</span><br><span class="line">println(arrayarr)</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li>补充一个很恶心的代码<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//补充一种确定下标的数组声明及定义方式：</span><br><span class="line">func testArray04()&#123;</span><br><span class="line">//a1数组下标0的没有定义，默认为0，下标1的是2，下标2的是3，</span><br><span class="line">a1 := [...]int&#123;2:3,1:2&#125; //这边的2 是key 打印按照key来打印</span><br><span class="line">fmt.Println(a1)      //[0 2 3]</span><br><span class="line"> </span><br><span class="line">//a2数组下标4定义为5，之前下标2和3未定义，默认为0</span><br><span class="line">a2 := [...]int&#123;1,2,4:5,6&#125;</span><br><span class="line">fmt.Println(a2)      //[1 2 0 0 5 6]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4><span id="13-map集合">1.3 Map(集合)</span></h4><p>Map 是一种无序的键值对的集合。Map 最重要的一点是通过 key 来快速检索数据，key 类似于索引，指向数据的值。<br>Map 是一种集合，所以我们可以像迭代数组和切片那样迭代它。不过，Map 是无序的，我们无法决定它的返回顺序，这是因为 Map 是使用 hash 表来实现的。</p><p>声明： m :&#x3D; make(map[string]string)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ff := map[string]string&#123;</span><br><span class="line">&quot;a&quot;: &quot;c&quot;,</span><br><span class="line">&#125;</span><br><span class="line"> var keys []string</span><br><span class="line">  for k := range m &#123;</span><br><span class="line">    keys = append(keys, k) //append  直接在切片级别进行描述</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">for s, s2 := range ff &#123;</span><br><span class="line">println(s,s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ff := map[string]string&#123;</span><br><span class="line">&quot;a&quot;: &quot;c&quot;,</span><br><span class="line">&#125;</span><br><span class="line">fff:=make(map[string]int) //直接声明不加参数</span><br><span class="line">ff[&quot;cc&quot;]=&quot;cccc&quot;;//赋值</span><br><span class="line">delete(ff,&quot;cc&quot;)</span><br></pre></td></tr></table></figure><h4><span id="14切片">1.4切片</span></h4><h4><span id="15-结构体">1.5 结构体</span></h4><p>定义切片:<br>你可以声明一个未指定大小的数组来定义切片：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var identifier []type//未定义大小的数组即切片</span><br></pre></td></tr></table></figure><p>或使用 make() 函数来创建切片:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slice1 := make([]type, len)  //make([]T, length, capacity)</span><br></pre></td></tr></table></figure><p>append  和copy 浅拷贝</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var numbers []int</span><br><span class="line">numbers = append(numbers, 0)//append追加</span><br><span class="line">  /* 同时添加多个元素 */</span><br><span class="line">numbers = append(numbers, 2,3,4)</span><br><span class="line"> /* 拷贝 numbers 的内容到 numbers1 */</span><br><span class="line">copy(numbers1,numbers)</span><br></pre></td></tr></table></figure><h4><span id="16-list链表">1.6 List（链表）</span></h4><p>遍历</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 声明链表</span><br><span class="line">l := list.New()</span><br><span class="line"></span><br><span class="line">// 数据添加到尾部</span><br><span class="line">l.PushBack(4)</span><br><span class="line">l.PushBack(5)</span><br><span class="line">l.PushBack(6)</span><br><span class="line"></span><br><span class="line">// 遍历</span><br><span class="line">for e := l.Front(); e != nil; e = e.Next() &#123;</span><br><span class="line">     fmt.Printf(&quot;%v\n&quot;, e.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> l := list.New()</span><br><span class="line"> l.PushBack(4)</span><br><span class="line"> six := l.PushBack(6)</span><br><span class="line"> l.Remove(six) // 删除6这个节点</span><br></pre></td></tr></table></figure><h4><span id="16-通道">1.6 通道</span></h4><p> 其他文章会有详细讲述</p><h4><span id="2总结">2总结</span></h4><p>数组是 slice 和 map 的底层结构。<br>slice 是 Go 里面惯用的集合数据的方法，map 则是用来存储键值对。<br>内建函数 make 用来创建 slice 和 map，并且为它们指定长度和容量等等。slice 和 map 字面值也可以做同样的事。<br>slice 有容量的约束，不过可以通过内建函数 append 来增加元素。<br>map 没有容量一说，所以也没有任何增长限制。<br>内建函数 len 可以用来获得 slice 和 map 的长度。<br>内建函数 cap 只能作用在 slice 上。<br>可以通过组合方式来创建多维数组和 slice。map 的值可以是 slice 或者另一个 map。slice 不能作为 map 的键。<br>在函数之间传递 slice 和 map 是相当廉价的，因为他们不会传递底层数组的拷贝。</p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-SPL(数据结构)</title>
      <link href="/blog/2020/06/23/tech/backend/php/PHP-SPL(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/"/>
      <url>/blog/2020/06/23/tech/backend/php/PHP-SPL(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>php SPL四种常用的数据结构<br>1.栈【先进后出】</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;$stack = new SplStack();</span><br><span class="line">$stack-&gt;push(&#x27;data1&#x27;);</span><br><span class="line">$stack-&gt;push(&#x27;data2&#x27;);</span><br><span class="line">$stack-&gt;push(&#x27;data3&#x27;);</span><br><span class="line">echo $stack-&gt;pop();</span><br><span class="line"> </span><br><span class="line">//输出结果为</span><br><span class="line">//data3&lt;/span&gt;&lt;span style=&quot;font-size:24px;font-weight: bold;&quot;&gt;</span><br><span class="line">&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>2.队列【先进先出 后进后出】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;$queue = new SplQueue();</span><br><span class="line">$queue-&gt;enqueue(&quot;data1&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data2&quot;);</span><br><span class="line">$queue-&gt;enqueue(&quot;data3&quot;);</span><br><span class="line">echo $queue-&gt;dequeue();</span><br><span class="line">//输出结果为</span><br><span class="line">//data1&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>3.堆</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;$heap = new SplMinHeap();</span><br><span class="line">$heap-&gt;insert(&quot;data1&quot;);</span><br><span class="line">$heap-&gt;insert(&quot;data2&quot;);</span><br><span class="line">echo $heap-&gt;extract();</span><br><span class="line">//输出结果为</span><br><span class="line">//data1&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>4.固定尺寸数组</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;font-size:18px;&quot;&gt;$array = new SplFixedArray(5);</span><br><span class="line">$array[0]=1;</span><br><span class="line">$array[3]=3;</span><br><span class="line">$array[2]=2;</span><br><span class="line">var_dump($array);</span><br><span class="line">//输出结果为</span><br><span class="line">// object(SplFixedArray)[1]</span><br><span class="line">// public 0 =&gt; int 1</span><br><span class="line">// public 1 =&gt; null</span><br><span class="line">// public 2 =&gt; int 2</span><br><span class="line">// public 3 =&gt; int 3</span><br></pre></td></tr></table></figure><p>————————————————<br>推荐学习：<a href="http://www.imooc.com/video/4849">http://www.imooc.com/video/4849</a><br>原文链接：<a href="https://blog.csdn.net/zhengwish/article/details/51742264">https://blog.csdn.net/zhengwish/article/details/51742264</a></p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-use</title>
      <link href="/blog/2020/06/23/tech/backend/php/PHP-Use-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
      <url>/blog/2020/06/23/tech/backend/php/PHP-Use-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>php use用法</p><h4><span id="1-user-namespace">1、user namespace</span></h4><h4><span id="2-use-一个trait">2、use 一个trait</span></h4><p>针对于trait的即多继承</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">A</span></span>&#123; <span class="title function_ invoke__">eat</span>()&#125; <span class="class"><span class="keyword">trait</span> <span class="title">B</span></span>&#123; <span class="title function_ invoke__">drink</span>()&#125;  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line"><span class="keyword">use</span> <span class="title">A</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">B</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Class D&#123;</span><br><span class="line">d=<span class="keyword">new</span> <span class="title class_">Class</span> <span class="title function_ invoke__">C</span>()</span><br><span class="line">d-&gt;<span class="title function_ invoke__">eat</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 当不同的trait中，却有着同名的方法或属性，会产生冲突，可以使用insteadof或 as进行解决，insteadof 是进行替代，而as是给它取别名</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use trait1,trait2&#123;</span><br><span class="line">        trait1::eat insteadof trait2;</span><br><span class="line">        trait1::drive insteadof trait2;</span><br><span class="line">        trait2::eat as eaten;</span><br><span class="line">        trait2::drive as driven;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4><span id="3闭包-gt匿名函数">3.闭包-&gt;匿名函数</span></h4><p>好处：节省内存  适合做回调函数</p><p>匿名函数：定义时未定义函数的名称<br>闭包： 创建时封装周围状态的函数，及时周围的环境不存在了，闭包中的状态还会存在</p><p>使用法则：</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> USE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-strlen与mb_strlen</title>
      <link href="/blog/2020/06/22/tech/backend/php/PHP-strlen%E4%B8%8Emb-strlen/"/>
      <url>/blog/2020/06/22/tech/backend/php/PHP-strlen%E4%B8%8Emb-strlen/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>在PHP中，strlen与mb_strlen是求字符串长度的函数<br>PHP内置的字符串长度函数strlen无法正确处理中文字符串，它得到的只是字符串所占的字节数。对于GB2312的中文编码，strlen得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍（在 UTF-8编码下，一个汉字占3个字节）。</p><p>采用mb_strlen函数可以较好地解决这个问题。mb_strlen的用法和strlen类似，只不过它有第二个可选参数用于指定字符编码。例如得到UTF-8的字符串str长度，可以用mbstrlen(str长度，可以用mbstrlen(str,‘UTF-8’)。如果省略第二个参数，则会使用PHP的内部编码。内部编码可以通过 mb_internal_encoding()函数得到。</p><p>需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即确保“extension&#x3D;php_mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。</p><hr><p>在strlen计算中，对待一个UTF8的中文字符，处理为3个字节长度，所以为3+1+2+1+9&#x3D;16个</p><p>当mb_strlen的内码选择为UTF-8的时候，则会将中文字符当成一个字符,所以为3+1+2+1+3&#x3D;10;</p><p>当mb_strlen的内码选择为gbk的时候，一个中文字符当成1.5个字符来处理来处理,最后就是:3+1+2+1+4.5&#x3D;11.5</p><p>函数：mb_internal_encoding()会得到当前PHP使用的内部编码</p><p>strlen,得到的是字符串所占的字节数，所以在查看一个字符串的长度的时候，strlen并不能得到我们需要的真实值</p><p>mb_strlen 函数可以很好的处理这一点</p><p>注意：mb_strlen函数并不是php的核心函数，只是PHP的一个扩展函数，使用之前要判断是否加在的mbstring扩展模块，在Php.ini文件中可以查看相关配置</p><blockquote><p>strlen结果为什么是4<br>strlen在遇到第一个\0时结束，后面的字符无视。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> strlen </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>其他-科学上网</title>
      <link href="/blog/2020/06/22/other/wiki/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <url>/blog/2020/06/22/other/wiki/%E5%85%B6%E4%BB%96-%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h1><span id="解决systemreflectiontargetinvocationexception-调用的目标发生了异常">解决System.Reflection.TargetInvocationException: 调用的目标发生了异常。</span></h1><blockquote><p>windows7系统运行没有问题，但是放到Windows10 上面就出现连接不上的问题，试了很多种方法还是这种解决了。</p></blockquote><p>问题：</p><p>System.Reflection.TargetInvocationException: 调用的目标发生了异常。</p><p>—&gt; System.Reflection.TargetInvocationException: 调用的目标发生了异常。</p><p>—&gt; System.InvalidOperationException: 此实现不是 Windows 平台 FIPS 验证的加密算法的一部分</p><p>解决办法：需要修改注册表,cmd命令，输入regedit打开注册表然后找到以下路径</p><p>KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa\FipsAlgorithmPolicy</p><p>修改此路径下的Enable值为1，然后重新打开shadowsocks，大功告成！记得重启ssr</p><p>（如果1不行那就切换成0）</p><p>————————————————<br>原文链接：<a href="https://blog.csdn.net/qq_27536941/article/details/103300646">https://blog.csdn.net/qq_27536941/article/details/103300646</a></p>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP-异常类</title>
      <link href="/blog/2020/06/22/tech/backend/php/PHP-%E5%BC%82%E5%B8%B8%E7%B1%BB/"/>
      <url>/blog/2020/06/22/tech/backend/php/PHP-%E5%BC%82%E5%B8%B8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>PHP 异常与错误 —— Throwable<br>Throwable</p><p>官方文档地址： <a href="http://php.net/manual/en/class.throwable.php">http://php.net/manual/en/class.throwable.php</a></p><p>PHP 支持版本： 7</p><blockquote><p>PHP7 异常与错误处理机制 Exception, Error, Throwable<br>Throwable 是 PHP 7 中可以用作任何对象抛出声明的基本接口，包括 Expection （异常）和 Error （错误）。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Throwable &#123;</span><br><span class="line">    </span><br><span class="line">  /* 抽象方法 */</span><br><span class="line">  abstract public string getMessage ( void ) // 获取抛出的消息内容</span><br><span class="line"></span><br><span class="line">  abstract public int getCode ( void ) // 获取抛出的错误代码</span><br><span class="line"></span><br><span class="line">  abstract public string getFile ( void ) // 获取产生异常的文件名</span><br><span class="line"></span><br><span class="line">  abstract public int getLine ( void ) // 获取相关行号</span><br><span class="line"></span><br><span class="line">  abstract public array getTrace ( void ) // 获取追踪信息，返回数组形式</span><br><span class="line"></span><br><span class="line">  abstract public string getTraceAsString ( void ) // 获取追踪信息，返回字符串形式</span><br><span class="line"></span><br><span class="line">  abstract public Throwable getPrevious ( void ) // 返回上一个 Throwable</span><br><span class="line"></span><br><span class="line">  abstract public string __toString ( void ) // 抛出的对象以字符串形式返回，可以用 echo 打印相应结果</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请一定要注意，没有特殊说明：本例 PHP Version &lt; 7<br>　　说起 PHP 异常处理，大家首先会想到 try-catch，那好，我们先看一段程序吧：有一个 test.php 文件，有一段简单的 PHP 程序，内容如下，然后命令行执行：php test.php</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 $num = 0;</span><br><span class="line">3     try &#123;</span><br><span class="line">4         echo 1/$num;</span><br><span class="line">5</span><br><span class="line">6 &#125; catch (Exception $e)&#123;</span><br><span class="line">7         echo $e-&gt;getMessage();</span><br><span class="line">8 &#125;</span><br><span class="line">9 ?&gt;</span><br></pre></td></tr></table></figure><p>　　我的问题是：这段程序能正确的捕捉到除 0 的错误信息吗？<br>　　如果你回答能，那你就把这篇文章看完吧！应该能学点东西。</p><p>本文章分 5 个部分介绍我的异常处理的理解：</p><p>一、异常与错误的概述</p><p>二、ERROR 的级别</p><p>三、PHP 异常处理中的黑科技</p><p>四、巧妙的捕获错误和异常</p><p>五、自定义异常处理和异常嵌套</p><p>六、PHP7 中的异常处理</p><p>一、异常与错误的概述<br>　　 PHP 中什么是异常：<br>　　程序在运行中出现不符合预期的情况，允许发生（你也不想让他出现不正常的情况）但他是一种不正常的情况，按照我们的正常逻辑本不该出的错误，但仍然会出现的错误，属于逻辑和业务流程的错误，而不是编译或者语法上的错误。</p><p>PHP 中什么是错误：<br>　　属于 php 脚本自身的问题，大部分情况是由错误的语法，服务器环境导致，使得编译器无法通过检查，甚至无法运行的情况。warning、notice 都是错误，只是他们的级别不同而已，并且错误是不能被 try-catch 捕获的。</p><p>上面的说法是有前提条件的：<br>　　在 PHP 中，因为在其他语言中就不能这样下结论了，也就是说异常和错误的说法在不同的语言有不同的说法。在 PHP 中任何自身的错误或者是非正常的代码都会当做错误对待，并不会以异常的形式抛出，但是也有一些情况会当做异常和错误同时抛出(据说是，我没有找到合适的例子)。也就是说，你想在数据库连接失败的时候自动捕获异常是行不通的，因为这就不是异常，是错误。但是在 java 中就不一样了，他会把很多和预期不一致的行为当做异常来进行捕获。</p><p>PHP 异常处理很鸡肋？<br>　　在上面的分析中我们可以看出，PHP 并不能主动的抛出异常，但是你可以手动抛出异常，这就很无语了，如果你知道哪里会出问题，你添加 if else 解决不就行了吗，为啥还要手动抛出异常，既然能手动抛出就证明这个不是异常，而是意料之中。以我的理解，这就是 PHP 异常处理鸡肋的地方（不一定对啊）。所以 PHP 的异常机制不是那么的完美，但是使用过框架的同学都知道有这个情况：你在框架中直接写开头那段 php“自动”捕获异常的代码是可以的，这是为什么？看过源码的同学都知道框架中都会涉及三个函数：register_shutdown_function，set_error_handler，set_exception_handler 后面我会重点讲解着三个黑科技，通过这几个函数我们可以实现 PHP 假自动捕获异常和错误。</p><p>二、ERROR 的级别<br>　　只有熟悉错误级别才能对错误捕捉有更好的认识。 ERROR 有不同的错误级别，我之前的一篇文章中有写到：<a href="http://www.cnblogs.com/zyf-zhaoyafei/p/3649434.html">http://www.cnblogs.com/zyf-zhaoyafei/p/3649434.html</a><br>　　下面我再总结性的给出这几类错误级别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 Fatal Error:致命错误（脚本终止运行）</span><br><span class="line">2 E_ERROR // 致命的运行错误，错误无法恢复，暂停执行脚本</span><br><span class="line">3 E_CORE_ERROR // PHP 启动时初始化过程中的致命错误</span><br><span class="line">4 E_COMPILE_ERROR // 编译时致命性错，就像由 Zend 脚本引擎生成了一个 E_ERROR</span><br><span class="line">5 E_USER_ERROR // 自定义错误消息。像用 PHP 函数 trigger_error（错误类型设置为：E_USER_ERROR）</span><br><span class="line">6</span><br><span class="line">7 Parse Error：编译时解析错误，语法错误（脚本终止运行）</span><br><span class="line">8 E_PARSE //编译时的语法解析错误</span><br><span class="line">9</span><br><span class="line">10 Warning Error：警告错误（仅给出提示信息，脚本不终止运行）</span><br><span class="line">11 E_WARNING // 运行时警告 (非致命错误)。</span><br><span class="line">12 E_CORE_WARNING // PHP 初始化启动过程中发生的警告 (非致命错误) 。</span><br><span class="line">13 E_COMPILE_WARNING // 编译警告</span><br><span class="line">14 E_USER_WARNING // 用户产生的警告信息</span><br><span class="line">15</span><br><span class="line">16 Notice Error：通知错误（仅给出通知信息，脚本不终止运行）</span><br><span class="line">17 E_NOTICE // 运行时通知。表示脚本遇到可能会表现为错误的情况.</span><br><span class="line">18 E_USER_NOTICE // 用户产生的通知信息。</span><br></pre></td></tr></table></figure><p>　　由此可知有 5 类是产生 ERROR 级别的错误，这种错误直接导致 PHP 程序退出。<br>　　可以定义成：</p><p>1 ERROR &#x3D; E_ERROR | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR | E_PARSE<br>三、PHP 异常处理中的黑科技<br>　　前面提到框架中是可以捕获所有的错误和异常的，之所以能实现应该是使用了黑科技，哈哈！其实也不是什么黑科技，主要是三个重要的函数：</p><p>1：set_error_handler()<br>　　看到这个名字估计就知道什么意思了，这个函数用于捕获错误，设置一个用户自定义的错误处理函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 set_error_handler(&#x27;zyferror&#x27;);</span><br><span class="line">3 function zyferror($type, $message, $file, $line)</span><br><span class="line">4 &#123;</span><br><span class="line">5 　　 var_dump(&#x27;&lt;b&gt;set_error_handler: &#x27; . $type . &#x27;:&#x27; . $message . &#x27; in &#x27; . $file . &#x27; on &#x27; . $line . &#x27; line .&lt;/b&gt;&lt;br /&gt;&#x27;);</span><br><span class="line">6 &#125;</span><br><span class="line">7 ?&gt;</span><br></pre></td></tr></table></figure><p>　　当程序出现错误的时候自动调用此方法，不过需要注意一下两点：第一，如果存在该方法，相应的 error_reporting()就不能在使用了。所有的错误都会交给自定义的函数处理。第二，此方法不能处理以下级别的错误：E_ERROR、 E_PARSE、 E_CORE_ERROR、 E_CORE_WARNING、 E_COMPILE_ERROR、 E_COMPILE_WARNING，set_error_handler() 函数所在文件中产生的 E_STRICT，该函数只能捕获系统产生的一些 Warning、Notice 级别的错误。<br>　　并且他有多种调用的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 // 直接传函数名 NonClassFunction</span><br><span class="line">3 set_error_handler(&#x27;function_name&#x27;);</span><br><span class="line">4</span><br><span class="line">5 // 传 class_name &amp;&amp; function_name</span><br><span class="line">6 set_error_handler(array(&#x27;class_name&#x27;, &#x27;function_name&#x27;));</span><br><span class="line">7 ?&gt;</span><br></pre></td></tr></table></figure><p>　　 2：register_shutdown_function()<br>　　捕获 PHP 的错误：Fatal Error、Parse Error 等，这个方法是 PHP 脚本执行结束前最后一个调用的函数，比如脚本错误、die()、exit、异常、正常结束都会调用，多么牛逼的一个函数啊！通过这个函数就可以在脚本结束前判断这次执行是否有错误产生，这时就要借助于一个函数：error_get_last()；这个函数可以拿到本次执行产生的所有错误。error_get_last();返回的信息：<br>　　[type] - 错误类型<br>　　[message] - 错误消息<br>　　[file] - 发生错误所在的文件<br>　　[line] - 发生错误所在的行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 register_shutdown_function(&#x27;zyfshutdownfunc&#x27;);</span><br><span class="line">3 function zyfshutdownfunc()</span><br><span class="line">4 &#123;</span><br><span class="line">5 if ($error = error_get_last()) &#123;</span><br><span class="line">6             var_dump(&#x27;&lt;b&gt;register_shutdown_function: Type:&#x27; . $error[&#x27;type&#x27;] . &#x27; Msg: &#x27; . $error[&#x27;message&#x27;] . &#x27; in &#x27; . $error[&#x27;file&#x27;] . &#x27; on line &#x27; . \$error[&#x27;line&#x27;] . &#x27;&lt;/b&gt;&#x27;);</span><br><span class="line">7 &#125;</span><br><span class="line">8 &#125;</span><br><span class="line">9 ?&gt;</span><br></pre></td></tr></table></figure><p>　　通过这种方法就可以巧妙的打印出程序结束前所有的错误信息。但是我在测试的时候我发现并不是所有的错误终止后都会调用这个函数，可以看下面的一个测试文件，内容是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;?php</span><br><span class="line">2 register_shutdown_function(&#x27;zyfshutdownfunc&#x27;);</span><br><span class="line">3 function zyfshutdownfunc()</span><br><span class="line">4 &#123;</span><br><span class="line">5 if ($error = error_get_last()) &#123;</span><br><span class="line"> 6             var_dump(&#x27;&lt;b&gt;register_shutdown_function: Type:&#x27; . $error[&#x27;type&#x27;] . &#x27; Msg: &#x27; . $error[&#x27;message&#x27;] . &#x27; in &#x27; . $error[&#x27;file&#x27;] . &#x27; on line &#x27; . \$error[&#x27;line&#x27;] . &#x27;&lt;/b&gt;&#x27;);</span><br><span class="line">7 &#125;</span><br><span class="line">8 &#125;</span><br><span class="line">9 var_dump(23+-+); //此处语法错误</span><br><span class="line">10 ?&gt;</span><br><span class="line"></span><br><span class="line">　　自己可以试一下，你可以看到根本就不会触发 zyfshutdownfunc()函数，其实这是一个语法错误，直接报了一个：</span><br><span class="line"></span><br><span class="line">1 &lt;?php</span><br><span class="line">2 Parse error: syntax error, unexpected &#x27;)&#x27; in /www/mytest/exception/try-catch.php on line 71</span><br><span class="line">3 ?&gt;</span><br><span class="line">　　由此引出一个奇葩的问题：问什么不能触发，为什么框架中是可以的？其实原因很简单，只在 parse-time 出错时是不会调用本函数的。只有在 run-time 出错的时候，才会调用本函数，我的理解是语法检查器前没有执行 register_shutdown_function()去把需要注册的函数放到调用的堆栈中，所以就根本不会运行。那框架中为什么任何错误都能进入到 register_shutdown_function()中呢，其实在框架中一般会有统一的入口 index.php，然后每个类库文件都会通过 include \*\* 的方式加载到 index.php 中，相当与所有的程序都会在 index.php 中聚集，同样，你写的具有语法错误的文件也会被引入到入口文件中，这样的话，调用框架，执行 index.php，index.php 本身并没有语法错误，也就不会产生 parse-time 错误，而是 include 文件出错了，是 run-time 的时候出错了，所以框架执行完之后就会触发 register_shutdown_function();</span><br><span class="line">　　所以现在可是试一下这个写法，这样就会触发 zyfshutdownfunc()回调了：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 a.php 文件<br>2 <?php3 　　// 模拟语法错误4 　　 var_dump(23+-+);5 ?><br>6<br>7 b.php 文件<br>8 <?php9 register_shutdown_function('zyfshutdownfunc');10 function zyfshutdownfunc()11 {12 if ($error = error_get_last()) {13             var_dump('<b>register_shutdown_function: Type:' . $error['type'] . ' Msg: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . \$error['line'] . '');14 }15 }16 require 'a.php';17 ?></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　 3：set_exception_handler()</span><br><span class="line">　　设置默认的异常处理程序，用在没有用 try/catch 块来捕获的异常，也就是说不管你抛出的异常有没有人捕获，如果没有人捕获就会进入到该方法中，并且在回调函数调用后异常会中止。看一下用法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 set_exception_handler('zyfexception');3 function zyfexception($exception)4     {5         var_dump("<b>set_exception_handler: Exception: " . $exception->getMessage() . '');6 }7 throw new Exception("zyf exception");8 ?></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">四、巧妙的捕获错误和异常</span><br><span class="line">　　 1：把错误以异常的形式抛出(不能完全抛出)</span><br><span class="line">　　　　由上面的讲解我们知道，php 中的错误是不能以异常的像是捕获的，但是我们需要让他们抛出，已达到扩展 try-catch 的影响范围，我们前面讲到过 set_error_handler() 方法，他是干嘛用的，他是捕获错误的，所以我们就可以借助他来吧错误捕获，然后再以异常的形式抛出，ok，试试下面的写法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 set_error_handler('zyferror');3 function zyferror($type, $message, $file, $line)4 {5 throw new \Exception($message . 'zyf错误当做异常'); 6     } 7  8     $num = 0;9 try {10 echo 1/$num;11 12     } catch (Exception $e){13 echo \$e->getMessage();14 }15 ?></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">　　好了，试一下，会打印出：</span><br><span class="line"></span><br><span class="line">1 Division by zero zyf123</span><br><span class="line">　　流程：本来是除 0 错误，然后触发 set_error_handler()，在 set_error_handler()中相当与杀了个回马枪，再把错误信息以异常的形式抛出来，这样就可以实现错误以异常的形式抛出。大家要注意：这样做是有缺点的，会受到 set_error_handler()函数捕获级别的限制。</span><br><span class="line"></span><br><span class="line">     2：捕获所有的错误</span><br><span class="line">        由set_error_handler()可知，他能够捕获一部分错误，不能捕获系统级E_ERROR、E_PARSE等错误，但是这部分可以由register_shutdown_function()捕获。所以两者结合能出现很好的功能。</span><br><span class="line">        看下面的程序：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 a.php 内容：<br>2 <?3 // 模拟 Fatal error 错误4 //test();56 // 模拟用户产生 ERROR 错误7 //trigger_error('zyf-error', E_USER_ERROR);89 // 模拟语法错误10 var_dump(23+-+);1112 // 模拟 Notice 错误13 //echo \$f;1415 // 模拟 Warning 错误16 //echo '123';17 //ob_flush();18 //flush();19 //header("Content-type:text/html;charset=gb2312");20 ?></p><p>21 b.php 内容：<br>22 <?23 error_reporting(0);24 register_shutdown_function('zyfshutdownfunc');25 function zyfshutdownfunc()26 {27 if ($error = error_get_last()) {28             var_dump('<b>register_shutdown_function: Type:' . $error['type'] . ' Msg: ' . $error['message'] . ' in ' . $error['file'] . ' on line ' . $error['line'] . '');29         }30     }31 32     set_error_handler('zyferror');33     function zyferror($type, $message, $file, $line)34     {35         var_dump('<b>set_error_handler: ' . $type . ':' . $message . ' in ' . $file . ' on ' . \$line . ' line .</b><br>');36 }3738 require 'a.php';39 ?></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">　　到此就可以解释开头的那个程序了吧，test.php 如果是单文件执行是不能捕获到错误的，如果你在框架中执行就是可以的，当然你按照我上面介绍的来扩展也是可以的。</span><br><span class="line"></span><br><span class="line">五、自定义异常处理和异常嵌套</span><br><span class="line"></span><br><span class="line">1：自定义异常处理</span><br><span class="line"></span><br><span class="line">在复杂的系统中，我们往往需要自己捕获我们需要特殊处理的异常，这些异常可能是特殊情况下抛出的。所以我们就自己定义一个异常捕获类，该类必须是 exception 类的一个扩展，该类继承了 PHP 的 exception 类的所有属性，并且我们可以添加自定义的函数，使用的时候其实和之前的一样，大致写法如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 class zyfException extends Exception3 {4 public function errorzyfMessage()5 {6 return 'Error line ' . $this->getLine().' in ' . $this->getFile()7 .': <b>' . $this->getMessage() . '</b> Must in (0 - 60)'; 8         } 9     }10 11     $age = 10;12 try {13 $age = intval($age);14 if($age > 60) {15             throw new zyfException($age);16 }1718 } catch (zyfException $e) {19         echo $e->errorzyfMessage();2021 }22 ?></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　 2：异常嵌套</span><br><span class="line"></span><br><span class="line">异常嵌套是比较常见的写法，在自定义的异常处理中，try 块中可以定义多个异常捕获，然后分层传递异常，理解和冒泡差不多，看下面的实现：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 $age = 10; 3     try { 4         $age = intval($age); 5         if($age > 60) {6 throw new zyfException($age); 7         } 8  9         if ($age <= 10 0) { throw new exception($age . ' must> 0');11         }12 13     } catch (zyfException $e) {14 echo $e->errorzyfMessage();15 16     } catch(Exception $e) {17 echo \$e->getMessage();18 }19 ?></=></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">　　当然也可以在 catch 中再抛出异常给上层：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 $age = 100; 3     try { 4         try { 5             $age = intval($age); 6             if($age > 60) {7 throw new Exception($age); 8             } 9 10         } catch (Exception $e) {11 throw new zyfException($age);12 13         }14 15     } catch (zyfException $e) {16 echo \$e->errorzyfMessage();17 }18 ?></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">六、PHP7 中的异常处理</span><br><span class="line">　　现在写 PHP 必须考虑版本情况，上面的写法在 PHP7 中大部分都能实现，但是也会有不同点，在 PHP7 更新中有一条：更多的 Error 变为可捕获的 Exception，现在的 PHP7 实现了一个全局的 throwable 接口，原来老的 Exception 和其中一部分 Error 实现了这个接口(interface)，PHP7 中更多的 Error 变为可捕获的 Exception 返回给捕捉器，这样其实和前面提到的扩展 try-catch 影响范围一样，但是如果不捕获则还是按照 Error 对待，看下面两个：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1 <?php2 try {3 test();45 } catch(Throwable $e) { 6         echo $e->getMessage() . ' zyf';7 }89 try {10 test();1112 } catch(Error $e) {13         echo $e->getMessage() . ' zyf';14 }15 ?></p><pre><code>因为 PHP7 实现了 throwable 接口，那么就可以使用第一个这种方式来捕获异常。又因为部分 Error 实现了接口，并且更多的 Error 变为可捕获的 Exception，那么就可以使用第二种方式来捕获异常。下面是在网上找的 PHP7 的异常层次树：Throwable　　 Exception 异常　　　　...　　 Error 错误　　　　 ArithmeticError 算数错误　　　　　　 DivisionByZeroError 除数为 0 的错误　　　　 AssertionError 声明错误　　　　 ParseError 解析错误　　　　 TypeError 类型错误转载：http://www.cnblogs.com/zyf-zhaoyafei/p/6928149.html</code></pre>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-工厂模式</title>
      <link href="/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/06/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>等待更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 待更新 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-抽象工厂模式</title>
      <link href="/blog/2020/06/19/tech/fundamentals/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/06/19/tech/fundamentals/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="抽象工厂模式abstract-factory-pattern">抽象工厂模式（Abstract Factory Pattern）</span></h2><p>抽象工厂模式是工厂方法模式的进一步抽象和推广。它提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><h3><span id="定义">定义</span></h3><p>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。</p><h3><span id="结构">结构</span></h3><p>抽象工厂模式包含以下角色：</p><ul><li><strong>AbstractFactory（抽象工厂）</strong>：声明了一组用于创建一族产品的方法，每一个方法对应一种产品</li><li><strong>ConcreteFactory（具体工厂）</strong>：实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品</li><li><strong>AbstractProduct（抽象产品）</strong>：为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法</li><li><strong>ConcreteProduct（具体产品）</strong>：定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法</li></ul><h3><span id="示例代码">示例代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品A</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象产品B</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA1</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用产品A1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA2</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductA</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用产品A2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB1</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃产品B1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB2</span> <span class="keyword">implements</span> <span class="title class_">AbstractProductB</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃产品B2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象工厂</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span>;</span><br><span class="line">    AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory1</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB1</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteFactory2</span> <span class="keyword">implements</span> <span class="title class_">AbstractFactory</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductA <span class="title function_">createProductA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AbstractProductB <span class="title function_">createProductB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB2</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory1</span>();</span><br><span class="line">        <span class="type">AbstractProductA</span> <span class="variable">productA1</span> <span class="operator">=</span> factory1.createProductA();</span><br><span class="line">        <span class="type">AbstractProductB</span> <span class="variable">productB1</span> <span class="operator">=</span> factory1.createProductB();</span><br><span class="line">        productA1.use();</span><br><span class="line">        productB1.eat();</span><br><span class="line">        </span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">factory2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteFactory2</span>();</span><br><span class="line">        <span class="type">AbstractProductA</span> <span class="variable">productA2</span> <span class="operator">=</span> factory2.createProductA();</span><br><span class="line">        <span class="type">AbstractProductB</span> <span class="variable">productB2</span> <span class="operator">=</span> factory2.createProductB();</span><br><span class="line">        productA2.use();</span><br><span class="line">        productB2.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="优点">优点</span></h3><ol><li><strong>隔离具体类的生成</strong>：客户端不需要知道具体类名，只需要知道抽象工厂和抽象产品即可</li><li><strong>易于交换产品系列</strong>：由于具体工厂类在一个应用中只需要在初始化的时候出现一次，这使得改变一个应用的具体工厂变得非常容易</li><li><strong>保证客户端始终只使用同一个产品族中的对象</strong>：这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式</li></ol><h3><span id="缺点">缺点</span></h3><ol><li><strong>难以支持新种类的产品</strong>：难以扩展抽象工厂以生产新种类的产品</li><li><strong>开闭原则的倾斜性</strong>：增加新的工厂和产品族容易，但增加新的产品等级结构复杂</li></ol><h3><span id="适用场景">适用场景</span></h3><ol><li>一个系统要独立于它的产品的创建、组合和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li>当你要强调一系列相关的产品对象的设计以便进行联合使用时</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时</li></ol><h3><span id="与工厂方法模式的区别">与工厂方法模式的区别</span></h3><ul><li><strong>工厂方法模式</strong>：针对的是一个产品等级结构</li><li><strong>抽象工厂模式</strong>：针对的是多个产品等级结构</li></ul><h3><span id="总结">总结</span></h3><p>抽象工厂模式是工厂方法模式的进一步抽象和推广。它提供了一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。抽象工厂模式在需要创建产品族时非常有用，但同时也带来了扩展性方面的挑战。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 抽象工厂模式 </tag>
            
            <tag> 创建型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-简单工厂模式</title>
      <link href="/blog/2020/06/19/tech/fundamentals/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/blog/2020/06/19/tech/fundamentals/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h2><span id="简单工厂模式simple-factory-pattern">简单工厂模式（Simple Factory Pattern）</span></h2><p>简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。</p><h3><span id="定义">定义</span></h3><p>简单工厂模式属于创建型模式，它提供了一种创建对象的最佳方式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><h3><span id="结构">结构</span></h3><p>简单工厂模式包含以下角色：</p><ul><li><strong>Factory（工厂角色）</strong>：工厂角色负责实现创建所有实例的内部逻辑</li><li><strong>Product（抽象产品角色）</strong>：抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口</li><li><strong>ConcreteProduct（具体产品角色）</strong>：具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例</li></ul><h3><span id="示例代码">示例代码</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象产品</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductA</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用产品A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体产品B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ConcreteProductB</span> <span class="keyword">extends</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">use</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用产品B&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单工厂</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title function_">createProduct</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;A&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductA</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;B&quot;</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConcreteProductB</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Product</span> <span class="variable">productA</span> <span class="operator">=</span> SimpleFactory.createProduct(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">        productA.use();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Product</span> <span class="variable">productB</span> <span class="operator">=</span> SimpleFactory.createProduct(<span class="string">&quot;B&quot;</span>);</span><br><span class="line">        productB.use();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="优点">优点</span></h3><ol><li><strong>封装性好</strong>：客户端不需要知道具体产品类的类名，只需要知道具体产品类所对应的参数即可</li><li><strong>解耦</strong>：通过工厂类，客户端和具体产品类之间实现了松耦合</li></ol><h3><span id="缺点">缺点</span></h3><ol><li><strong>扩展性差</strong>：如果要增加新的产品，必须修改工厂类，违反了开闭原则</li><li><strong>工厂类职责过重</strong>：工厂类集中了所有产品的创建逻辑，一旦不能正常工作，整个系统都要受到影响</li></ol><h3><span id="适用场景">适用场景</span></h3><ol><li>工厂类负责创建的对象比较少</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心</li></ol><h3><span id="总结">总结</span></h3><p>简单工厂模式虽然简单，但在实际开发中应用广泛。它通过工厂类来创建对象，实现了客户端和具体产品类的解耦，但同时也带来了扩展性差的问题。在实际应用中，需要根据具体需求来权衡是否使用简单工厂模式。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建型模式 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>http与rpc区别，以及如何使用rpc</title>
      <link href="/blog/2020/06/19/tech/network/http/%E5%BE%AE%E6%9C%8D%E5%8A%A1-http%E4%B8%8Erpc%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8rpc/"/>
      <url>/blog/2020/06/19/tech/network/http/%E5%BE%AE%E6%9C%8D%E5%8A%A1-http%E4%B8%8Erpc%E5%8C%BA%E5%88%AB%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8rpc/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><blockquote><p>HTTP就是一种RPC(Remote Procedure Call) ,http是七层iso模型，转换步骤多，且基于http有更多的报文</p></blockquote><p><strong>http好比普通话，rpc好比团伙内部黑话。</strong><br>只要是远程调用都可以叫RPC()，和是不是通过http没什么关系<br>讲普通话，好处就是谁都听得懂，谁都会讲。<br>讲黑话，好处是可以更精简、更加保密、更加可定制，坏处就是要求“说”黑话的那一方（client端）也要懂，而且一旦大家都说一种黑话了，换黑话就困难了。</p><blockquote><p>首先 http 和 rpc 并不是一个并行概念。</p></blockquote><p>rpc是远端过程调用，其调用协议通常包含传输协议和序列化协议。</p><p>传输协议包含: 如著名的 [gRPC](<a href="https://link.zhihu.com/?target=http://www.grpc.io/">grpc &#x2F; grpc.io</a>) 使用的 http2 协议，也有如dubbo一类的自定义报文的tcp协议。</p><p>序列化协议包含: 如基于文本编码的 xml json，也有二进制编码的 protobuf hessian等。</p><p>因此我理解的问题应该是：<strong>为什么要使用自定义 tcp 协议的 rpc 做后端进程通信？</strong></p><p>解决这个问题就应该搞清楚 http 使用的 tcp 协议，和我们自定义的 tcp 协议在报文上的区别。</p><p>首先要否认一点 http 协议相较于自定义tcp报文协议，增加的开销在于<strong>连接的建立与断开</strong>。http协议是支持<strong>连接池复用</strong>的，也就是建立一定数量的连接不断开，并不会频繁的创建和销毁连接。要说的是http也可以使用protobuf这种二进制编码协议对内容进行编码，因此二者最大的区别还是在传输协议上。</p><p>通用定义的http1.1协议的tcp报文包含太多废信息，一个POST协议的格式大致如下：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.0</span> <span class="number">200</span> OK </span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/plain</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>137582</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Wed, 5 August 1996 15:55:28 GMT</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Apache 0.84</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">body</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>即使编码协议也就是body是使用二进制编码协议，报文元数据也就是<strong>header头的键值对却用了文本编码，非常占字节数</strong>。如上图所使用的报文中有效字节数仅仅占约 30%，<strong>也就是70%的时间用于传输元数据废编码</strong>。当然实际情况下报文内容可能会比这个长，但是报头所占的比例也是非常可观的。</p><p>那么假如我们使用自定义tcp协议的报文如下</p><p><img src="https://pic2.zhimg.com/80/v2-89c905b0806577471aa7789a25ac0d44_720w.jpg" alt="tcp"></p><p>报头占用的字节数也就只有16个byte，极大地精简了传输内容。</p><p>这也就是为什么后端进程间通常会采用自定义tcp协议的rpc来进行通信的原因</p><p>简单来说成熟的rpc库相对http容器，更多的是封装了“服务发现”，”负载均衡”，“熔断降级”一类面向服务的高级特性。可以这么理解，rpc框架是面向服务的更高级的封装。如果把一个http servlet容器上封装一层服务发现和函数代理调用，那它就已经可以做一个rpc框架了。</p><blockquote><p>那http和rpc和websocket三者有什么关系呢？</p></blockquote><p><a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Web_Service">Web Service</a> 也提出了好久了, 那么究竟什么是 <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Web_Service">Web Service</a> ?<br> 简单地说, 也就是服务器如何向客户端提供服务.<br> 常用的方法有:<br> <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> 所谓的远程过程调用 (面向方法)<br> <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Service-oriented_architecture">SOA</a> 所谓的面向服务的架构(面向消息)<br> <a href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Representational_State_Transfer">REST</a> 所谓的 <strong>Representational state transfer</strong> (面向资源)</p><p>转载整理自：<a href="https://www.zhihu.com/question/41609070/answer/191965937">https://www.zhihu.com/question/41609070/answer/191965937</a></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rpc() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOLANG笔记1-基础数据类型</title>
      <link href="/blog/2020/06/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/blog/2020/06/09/tech/backend/golang/GOLANG-%E7%AC%94%E8%AE%B01-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="int-和-uint">int  和 uint</span></h3><p>uint类型长度取决于 CPU，如果是32位CPU就是4个字节，如果是64位就是8个字节。我的电脑是64位的，而 playground 是32位的</p><blockquote><p>int是带符号的，表示范围是：-2147483648到2147483648，即-2^31到2^31次方。</p></blockquote><blockquote><p>uint则是不带符号的，表示范围是：2^32即0到4294967295。</p></blockquote><blockquote><p>uint可以使用十进制，二进制，十六进制。和long,ulong,float,double,decimal等预定义可以进行隐式转换。但是需要注意值是否在可转换的范围内，不然会出现异常。</p></blockquote><p>The Uint keyword signifies an integral type that stores calues according to the size and ranges shown in the following table.</p><blockquote><p>关键字表示一种整型类型，该类型根据下表显示的大小和范围存储值。<br>————————————————</p></blockquote><h3><span id="golang数据类型">golang数据类型：</span></h3><h4><span id="布尔类型">布尔类型</span></h4><p>true false</p><h4><span id="数字类型-整形-浮点型">数字类型 整形 浮点型</span></h4><p><strong>整形：</strong></p><p>无符号：uint 8、uint 16、uint 32、uint 64、长度（0~2次方-1）</p><p>有符号：int 8、int 16、int 32、int 64、长度:例如int 8（负的2^7~2^7-1）</p><p>有无符号：没有符号位的数字只<strong>能有0和正值</strong>,有符号位的数字可以有<strong>正零,负零和正数负数</strong>.</p><p><strong>浮点型：</strong>float（32单精度） float（64双精度）</p><table><thead><tr><th align="left">序号</th><th align="left">类型和描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>float32</strong> IEEE-754 32位浮点型数</td></tr><tr><td align="left">2</td><td align="left"><strong>float64</strong> IEEE-754 64位浮点型数</td></tr><tr><td align="left">3</td><td align="left"><strong>complex64</strong> 32 位实数和虚数</td></tr><tr><td align="left">4</td><td align="left"><strong>complex128</strong> 64 位实数和虚数</td></tr></tbody></table><h4><span id="字符串类型">字符串类型</span></h4><h4><span id="派生类型">派生类型</span></h4><p><strong>派生类型:</strong></p><ul><li>(a) 指针类型（Pointer）</li><li>(b) 数组类型</li><li>(c) 结构化类型(struct)</li><li>(d) Channel 类型</li><li>(e) 函数类型</li><li>(f) 切片类型</li><li>(g) 接口类型（interface）</li><li>(h) Map 类型</li></ul><hr><p>虚数：<a href="https://www.ruanyifeng.com/blog/2012/09/imaginary_number.html">https://www.ruanyifeng.com/blog/2012/09/imaginary_number.html</a></p><p>原文链接：<a href="https://blog.csdn.net/janny_flower/article/details/81082424">https://blog.csdn.net/janny_flower/article/details/81082424</a></p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Go并发编程总结</title>
      <link href="/blog/2020/06/09/tech/backend/golang/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2020/06/09/tech/backend/golang/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Golang :不要通过共享内存来通信，而应该****通过通信来共享内存****。这句风靡在Go社区的话,说的就是 goroutine中的 channel。他在go并发编程中充当着类型安全的管道作用。</p><h1><span id="1-通过golang中的-goroutine-与syncmutex进行-并发同步">1、通过golang中的 goroutine 与sync.Mutex进行 并发同步</span></h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">package main</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">import</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="string">&quot;fmt&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="string">&quot;sync&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="string">&quot;runtime&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">var</span> count <span class="built_in">int</span></span> = <span class="number">0</span>   <span class="comment">//全局共享变量</span></span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">counter</span>(<span class="params"><span class="keyword">lock</span> * sync.Mutex</span>)</span>&#123;  <span class="comment">//goroutinue执行函数</span></span><br><span class="line"><span class="keyword">lock</span>.Lock()</span><br><span class="line">count++</span><br><span class="line">fmt.Println(count)</span><br><span class="line"><span class="keyword">lock</span>.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">main</span>()</span>&#123;</span><br><span class="line"><span class="keyword">lock</span> := &amp;sync.Mutex&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">//传递指针是为了防止 函数内的锁和 调用锁不一致    创建10个协程对count++</span></span><br><span class="line"><span class="function">go <span class="title">counter</span>(<span class="params"><span class="keyword">lock</span></span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">for</span></span> &#123;</span><br><span class="line"><span class="keyword">lock</span>.Lock()</span><br><span class="line">c := count</span><br><span class="line"><span class="keyword">lock</span>.Unlock()</span><br><span class="line"><span class="comment"><span class="doctag">///</span>把时间片给别的goroutine  未来某个时刻运行该routine</span></span><br><span class="line">runtime.Gosched()</span><br><span class="line"><span class="keyword">if</span> c &gt;=<span class="number">10</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;goroutine end&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">//输出结果：1 2 3 4 5 6 7 8 9 10    &quot;goroutine end&quot;</span></span><br></pre></td></tr></table></figure><h1><span id="2-goroutine之间通过-channel进行通信channel是和类型相关的-可以理解为-是一种类型安全的管道">2、goroutine之间通过 channel进行通信,channel是和类型相关的 可以理解为  是一种类型安全的管道。</span></h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function">func <span class="title">Count</span>(<span class="params">ch chan <span class="built_in">int</span></span>)</span> &#123;</span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Counting&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">func <span class="title">main</span>()</span> &#123;</span><br><span class="line">chs := make([]&lt;strong&gt;chan <span class="built_in">int</span>&lt;/strong&gt;, <span class="number">10</span>)   <span class="comment">//[]chan int 表示是chan int类型的切片 和   chan []int区别  标识通道类型是[]int</span></span><br><span class="line"><span class="comment">//c := make(chan []int)</span></span><br><span class="line"><span class="comment">//t := []int&#123;1,2,3&#125;</span></span><br><span class="line"><span class="comment">//c &lt;- t</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">chs[i] = make(chan <span class="built_in">int</span>)</span><br><span class="line"><span class="function">go <span class="title">Count</span>(<span class="params">chs[i]</span>)         <span class="comment">//创建10个协程</span></span></span><br><span class="line"><span class="function">fmt.<span class="title">Println</span>(<span class="params"><span class="string">&quot;Count&quot;</span>,i</span>)</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">for</span> i, ch :</span>= range chs &#123;</span><br><span class="line">&lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;Counting&quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;       <span class="comment">//调度的顺序不同，可能goroutinue执行的顺序不一样</span></span><br></pre></td></tr></table></figure><h1><span id="3-go语言中的select是语言级内置-非堵塞">3、Go语言中的select是语言级内置  非堵塞</span></h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-chan1: <span class="comment">// 如果chan1成功读到数据，则进行该case处理语句  </span></span><br><span class="line"><span class="keyword">case</span> chan2 &lt;- <span class="number">1</span>: <span class="comment">// 如果成功向chan2写入数据，则进行该case处理语句  </span></span><br><span class="line"><span class="literal">default</span>: <span class="comment">// 如果上面都没有成功，则进入default处理流程  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，select不像switch，后面并不带判断条件，而是直接去查看case语句。每个case语句都必须是一个面向channel的操作。比如上面的例子中，第一个case试图从chan1读取一个数据并直接忽略读到的数据，而第二个case则是试图向chan2中写入一个整型数1，如果这两者都没有成功，则到达default语句。</p><h1><span id="4-channel-的带缓冲读取写入">4、channel 的带缓冲读取写入</span></h1><p>要创建一个带缓冲的channel，其实也非常容易：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>在调用make()时将缓冲区大小作为第二个参数传入即可，比如上面这个例子就创建了一个大小为1024的int类型channel，即使没有读取方，写入方也可以一直往channel里写入，在缓冲区被填完之前都不会阻塞。</p><p>从带缓冲的channel中读取数据可以使用与常规非缓冲channel完全一致的方法，但我们也可以使用range关键来实现更为简便的循环读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Received:&quot;</span>, i)</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1><span id="5-用goroutine模拟生产消费者">5、用goroutine模拟生产消费者</span></h1><p>因为程序会****优先执行主线程，主线程执行完成后，程序会立即退出****，没有多余的时间去执行子线程。如果在程序的最后让主线程休眠1秒钟，那程序就会有足够的时间去执行子线程。 通道又叫channel，顾名思义，channel的作用就是在多线程之间传递数据的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">chreadandwrite :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">chonlyread := <span class="built_in">make</span>(&lt;-<span class="keyword">chan</span> <span class="type">int</span>) <span class="comment">//创建只读channel    var read &lt;-chan int = chreadandwrite </span></span><br><span class="line">chonlywrite := <span class="built_in">make</span>(<span class="keyword">chan</span>&lt;- <span class="type">int</span>) <span class="comment">//创建只写channel   var write chan&lt;- int = chreadandwrite </span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Producer</span><span class="params">(p <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">p &lt;- i</span><br><span class="line">fmt.Println(<span class="string">&quot;send:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">v := &lt;-c</span><br><span class="line">fmt.Println(<span class="string">&quot;receive:&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">/*ch :=make(chan int)</span></span><br><span class="line"><span class="comment">ch &lt;- 1</span></span><br><span class="line"><span class="comment">这个错误的意思是说线程陷入了死锁，程序无法继续往下执行。那么造成这种错误的原因是什么呢？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;&lt;/span&gt;我们创建了一个无缓冲的channel，然后给这个channel赋值了，程序就是在赋值完成后陷入了死锁。</span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;&lt;/span&gt;因为我们的channel是无缓冲的，即同步的，赋值完成后来不及读取channel，程序就已经阻塞了。  =====    顺序执行满阻塞</span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;&lt;/span&gt;queue &lt;- 1</span></span><br><span class="line"><span class="comment">&lt;span style=&quot;white-space:pre;&quot;&gt;&lt;/span&gt;queue &lt;- 2   //满阻塞</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> Producer(queue)     <span class="comment">//开启协程执行函数单独去执行，主程序直接往下执行</span></span><br><span class="line">                       <span class="comment">//i = 0 的时候，写入阻塞      生产者和消费者是异步执行，消费者会去读取channel值。</span></span><br><span class="line"><span class="keyword">go</span> Consumer(queue)</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)        <span class="comment">//让Producer与Consumer完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为channel是没有缓冲的，所以当生产者给channel赋值后，生产者这个线程会阻塞，****直到消费者线程将channel中的数据取出****。消费者第一次将数据取出后，进行下一次循环时，消费者的线程也会阻塞，因为生产者还没有将数据存入，这时程序会去执行生产者的线程。程序就这样在消费者和生产者两个线程间不断切换，直到循环结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">(p <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">p &lt;- i</span><br><span class="line">fmt.Println(<span class="string">&quot;send:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">v := &lt;-c</span><br><span class="line">fmt.Println(<span class="string">&quot;receive:&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">10</span>)  <span class="comment">//带缓冲的例子</span></span><br><span class="line"><span class="keyword">go</span> produce(ch)</span><br><span class="line"><span class="keyword">go</span> consumer(ch)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中，缓冲区可以存储10个int类型的整数，在执行生产者线程的时候，线程就不会阻塞，一次性将10个整数存入channel，在读取的时候，也是一次性读取。读取的话，没有数据就阻塞，有的话依次进行读取操作。</p><h1><span id="6-通过make-创建通道">6、通过make 创建通道</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span>(c1 <span class="keyword">chan</span> <span class="type">int</span>)       创建的是 同步channel ...读写完全对应    先写满的话就会阻塞  顺序程序不会执行</span><br><span class="line"><span class="built_in">make</span>(c1 <span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">10</span>)   创建带缓冲的通道 上来可以写<span class="number">10</span>次        </span><br></pre></td></tr></table></figure><h1><span id="7-随机向通道中写入0或者1">7、随机向通道中写入0或者1</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="comment">///不停向channel中随机写入 0 或者1</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> ch &lt;- <span class="number">0</span>:</span><br><span class="line"><span class="keyword">case</span> ch &lt;- <span class="number">1</span>:</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从通道中取出数据</span></span><br><span class="line">i := &lt;-ch</span><br><span class="line">fmt.Println(<span class="string">&quot;Value received:&quot;</span>,i)</span><br><span class="line">time.Sleep(<span class="number">1e8</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="8-带缓冲的channel">8、带缓冲的channel</span></h1><p>之前创建的都是不带缓冲的channel，这种做法对于传递单个数据的场景可以接受，但对于需要持续传输大量数据的场景就有些不合适了。接下来我们介绍如何给channel带上缓冲，从而达到消息队列的效果。</p><p>要创建一个带缓冲的channel，其实也非常容易：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>在调用make()时将缓冲区大小作为第二个参数传入即可，比如上面这个例子就创建了一个大小为1024的int类型channel，即使没有读取方，写入方也可以一直往channel里写入，在缓冲区被填完之前都不会阻塞。</p><p>从带缓冲的channel中读取数据可以使用与常规非缓冲channel完全一致的方法，但我们也可以使用range关键来实现更为简便的循环读取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Received:&quot;</span>, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">c&lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> val:=<span class="keyword">range</span> c &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Value:&quot;</span>,val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">chs:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">//只要有通道操作一定要放到goroutine中否则会堵塞当前的主线程 并且导致程序退出</span></span><br><span class="line"><span class="comment">//对于同步通道 或者带缓冲的通道 一定要封装成函数 使用 goroutine 包装</span></span><br><span class="line"><span class="keyword">go</span> A(chs)</span><br><span class="line"><span class="keyword">go</span> B(chs)</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="9-关于创建多个goroutine具体到go语言会创建多少个线程">9、关于创建多个goroutine具体到go语言会创建多少个线程</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="comment">//&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//&quot;time&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">b:=<span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">10</span>)</span><br><span class="line">os.Stdin.Read(b) <span class="comment">// will block</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会产生21个线程：<br>runtime scheduler(src&#x2F;pkg&#x2F;runtime&#x2F;proc.c)会<em><strong>*维护一个线程池，当某个goroutine被block后，scheduler会创建一个新线程给其他ready的goroutine。*</strong></em><br>GOMAXPROCS控制的是未被阻塞的所有goroutine被multiplex到多少个线程上运行</p><h1><span id="10-在channel中也是可以传递channel的go语言的channel和map-slice等一样都是原生类型">10、在channel中也是可以传递channel的,Go语言的channel和map  slice等一样都是原生类型</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[]<span class="keyword">chan</span> <span class="type">int</span>   <span class="keyword">chan</span> <span class="type">int</span>切片    <span class="keyword">chan</span> []<span class="type">int</span> 表示的是<span class="keyword">chan</span>里面存的数据时[]<span class="type">int</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在Go语言中channel本身也是一个原生类型，与map之类的类型地位一样，因此channel本身在定义后也可以通过channel来传递。</p><p>我们可以使用这个特性来实现*nix上非常常见的管道（pipe）特性。管道也是使用非常广泛的一种设计模式，比如在处理数据时，我们可以采用管道设计，这样可以比较容易以插件的方式增加数据的处理流程。</p><p>下面我们****利用channel可被传递的特性来实现我们的管道****。 为了简化表达， 我们假设在管道中传递的数据只是一个整型数，在实际的应用场景中这通常会是一个数据块。</p><p>首先限定基本的数据结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PipeData <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">    handler <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">    next <span class="keyword">chan</span> <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们写一个常规的处理函数。我们只要定义一系列PipeData的数据结构并一起传递给 这个函数，就可以达到流式处理数据的目的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(queue <span class="keyword">chan</span> *PipeData)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> queue &#123;</span><br><span class="line">        data.next &lt;- data.handler(data.value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="11-我们默认创建的是双向通道单向通道没有意义但是我们却可以通过强制转换-将双向通道-转换成为单向通道">11、我们默认创建的是双向通道,单向通道没有意义,但是我们却可以通过强制转换 将双向通道 转换成为单向通道</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="type">int</span>  <span class="comment">// ch1是一个正常的channel，不是单向的  </span></span><br><span class="line"><span class="keyword">var</span> ch2 <span class="keyword">chan</span>&lt;- <span class="type">float64</span><span class="comment">// ch2是单向channel，只用于写float64数据</span></span><br><span class="line"><span class="keyword">var</span> ch3 &lt;-<span class="keyword">chan</span> <span class="type">int</span> <span class="comment">// ch3是单向channel，只用于读取int数据 </span></span><br></pre></td></tr></table></figure><p>channel是一个原生类型，因此不仅支持被传递，还支持类型转换。只有在介绍了单向channel的概念后，读者才会明白类型转换对于channel的意义：就是在单向channel和双向channel之间进行转换。</p><p>示例如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch4 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">ch5 := &lt;-<span class="keyword">chan</span> <span class="type">int</span>(ch4) <span class="comment">// ch5就是一个单向的读取channel</span></span><br><span class="line">ch6 := <span class="keyword">chan</span>&lt;- <span class="type">int</span>(ch4) <span class="comment">// ch6 是一个单向的写入channel</span></span><br></pre></td></tr></table></figure><p>基于ch4，我们通过类型转换初始化了两个单向channel：单向读的ch5和单向写的ch6。 </p><p>从设计的角度考虑，所有的代码应该都遵循”最小权限原则” ，从而避免没必要地使用泛滥问题， 进而导致程序失控。 写过C++程序的读者肯定就会联想起const 指针的用法。非const指针具备const指针的所有功能，将一个指针设定为const就是明确告诉 </p><p>****函数实现者不要试图对该指针进行修改。单向channel也是起到这样的一种契约作用****。下面我们来看一下单向channel的用法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> value := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Parsing value&quot;</span>, value)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非这个函数的实现者无耻地使用了类型转换，否则这个函数就不会因为各种原因而对ch 进行写，避免在ch中出现非期望的数据，从而很好地实践最小权限原则。</p><h1><span id="12-只读只写-单向-channel-代码例子-遵循权限最小化的原则">12、只读只写 单向 channel 代码例子   遵循权限最小化的原则</span></h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">//接受一个参数 是只允许读取通道  除非直接强制转换 要么你只能从channel中读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sCh</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> val:= <span class="keyword">range</span> ch &#123;</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建一个带100缓冲的通道 可以直接写入 而不会导致 主线程堵塞</span></span><br><span class="line">dch:=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">100</span>)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++&#123;</span><br><span class="line">dch&lt;- i</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传递进去 只读通道</span></span><br><span class="line"><span class="keyword">go</span> sCh(dch)</span><br><span class="line">time.Sleep(<span class="number">1e9</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1><span id="13-channel的关闭以及判断channel的关闭">13、channel的关闭,以及判断channel的关闭</span></h1><p>关闭channel非常简单，直接使用Go语言内置的close()函数即可：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">close</span>(ch)</span><br></pre></td></tr></table></figure><p>在介绍了如何关闭channel之后，我们就多了一个问题：如何判断一个channel是否已经被关闭？我们可以在读取的时候使用多重返回值的方式：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">x</span>, ok := &lt;-ch</span><br></pre></td></tr></table></figure><p>这个用法与map中的按键获取value的过程比较类似，只需要看第二个bool返回值即可，如果返回值是false则表示ch已经被关闭。</p><h1><span id="14-go的多核并行化编程-高性能并发编程-必须设置gomaxprocs-为最大核数目-这个值由runtimenumcpu获取">14、Go的多核并行化编程   高性能并发编程 必须设置GOMAXPROCS 为最大核数目 这个值由runtime.NumCPU()获取</span></h1><p>在执行一些昂贵的计算任务时， 我们希望能够尽量****利用现代服务器普遍具备的多核特性来尽量将任务并行化*<em><strong>，从而达到降低总计算时间的目的。此时我们需要了解</strong></em>*CPU核心的数量****，并针对性地分解计算任务到多个goroutine中去并行运行。</p><p>下面我们来模拟一个完全可以并行的计算任务：计算N个整型数的总和。我们可以将****所有整型数分成M份，M即CPU的个数****。让每个CPU开始计算分给它的那份计算任务，最后将每个CPU的计算结果再做一次累加，这样就可以得到所有N个整型数的总和：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">Vector</span> []float64</span></span><br><span class="line">// 分配给每个<span class="type">CPU</span>的计算任务</span><br><span class="line"><span class="title">func</span> (v <span class="type">Vector</span>) <span class="type">DoSome</span>(i, n int, u <span class="type">Vector</span>, c chan int) &#123;</span><br><span class="line"><span class="title">for</span> ; i &lt; n; i++ &#123;</span><br><span class="line">         v[i] += u.<span class="type">Op</span>(v[i])</span><br><span class="line">     &#125;</span><br><span class="line">     c &lt;- <span class="number">1</span>       </span><br><span class="line">// 发信号告诉任务管理者我已经计算完成了</span><br><span class="line">&#125;</span><br><span class="line"><span class="title">const</span> <span class="type">NCPU</span> = <span class="number">16</span>     </span><br><span class="line">// 假设总共有<span class="number">16</span>核   </span><br><span class="line"><span class="title">func</span> (v <span class="type">Vector</span>) <span class="type">DoAll</span>(u <span class="type">Vector</span>) &#123;   </span><br><span class="line">    c := make(chan int, <span class="type">NCPU</span>)  // 用于接收每个<span class="type">CPU</span>的任务完成信号   </span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="type">NCPU</span>; i++ &#123;   </span><br><span class="line">            go v.<span class="type">DoSome</span>(i*len(v)/<span class="type">NCPU</span>, (i+<span class="number">1</span>)*len(v)/<span class="type">NCPU</span>, u, c)</span><br><span class="line">    &#125; </span><br><span class="line">    // 等待所有<span class="type">CPU</span>的任务完成</span><br><span class="line">    for i := <span class="number">0</span>; i &lt; <span class="type">NCPU</span>; i++ &#123;   </span><br><span class="line">         &lt;-c    // 获取到一个数据，表示一个<span class="type">CPU</span>计算完成了</span><br><span class="line">    &#125;</span><br><span class="line">// 到这里表示所有计算已经结束</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个函数看起来设计非常合理。****DoAll()会根据CPU核心的数目对任务进行分割*<em><strong>，然后开辟多个goroutine来并行执行这些计算任务。是否可以将总的计算时间降到接近原来的1&#x2F;N呢？答案是不一定。如果掐秒表（正常点的话，应该用7.8节中介绍的Benchmark方法） ，会发现总的执行时间没有明显缩短。再去观察CPU运行状态， 你会发现</strong></em>*尽管我们有16个CPU核心， 但在计算过程中其实只有一个CPU核心处于繁忙状态****，这是会让很多Go语言初学者迷惑的问题。</p><p>官方的答案是，这是当前版本的Go编译器还不能很智能地去发现和利用多核的优势。虽然我们确实创建了多个goroutine，并且从运行状态看这些goroutine也都在并行运行，但实际上****所有这些goroutine都运行在同一个CPU核心上， 在一个goroutine得到时间片执行的时候， 其他goroutine都会处于等待状态****。从这一点可以看出，虽然goroutine简化了我们写并行代码的过程，但实际上整体运行效率并不真正高于单线程程序。</p><p>在Go语言升级到默认支持多CPU的某个版本之前，我们可以先通过设置环境变量</p><p>GOMAXPROCS的值来控制使用多少个CPU核心。具体操作方法是通过直接设置环境变量GOMAXPROCS的值，或者在代码中启动goroutine之前先调用以下这个语句以设置使用16个CPU核心：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.GOMAXPROCS(16)</span><br></pre></td></tr></table></figure><p>到底应该设置多少个CPU核心呢，其实runtime包中还提供了另外一个****函数NumCPU()来获取核心数****。可以看到，Go语言其实已经感知到所有的环境信息，下一版本中完全可以利用这些信息将goroutine调度到所有CPU核心上，从而最大化地利用服务器的多核计算能力。抛弃GOMAXPROCS只是个时间问题。</p><h1><span id="15-主动出让时间片给其他-goroutine-在未来的某一时刻再来执行当前goroutine">15、主动出让时间片给其他 goroutine 在未来的某一时刻再来执行当前goroutine</span></h1><p>我们可以在每个goroutine中控制何时主动出让时间片给其他goroutine，这可以使用****runtime包中的Gosched()函数****实现。<br>实际上，如果要比较精细地控制goroutine的行为，就必须比较深入地了解Go语言开发包中runtime包所提供的具体功能。</p><h1><span id="16-go中的同步及同步锁">16、Go中的同步及同步锁</span></h1><p>倡导用通信来共享数据，而不是通过共享数据来进行通信，但考虑到即使成功地用channel来作为通信手段，还是****避免不了多个goroutine之间共享数据的问题*<em><strong>，Go语言的设计者虽然对channel有极高的期望，但也提供了妥善的</strong></em>*资源锁方案****。</p><p>对于这两种锁类型， 任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()调用与之对应，<em><strong>*否则可能导致等待该锁的*</strong></em>****所有goroutine处于饥饿状态，甚至可能导致死锁****。锁的典型使用模式如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> l sync.<span class="type">Mutex</span>  </span><br><span class="line"><span class="keyword">func</span> <span class="title function_">foo</span>() &#123;</span><br><span class="line">l.<span class="type">Lock</span>()  </span><br><span class="line"><span class="comment">//延&lt;strong&gt;迟调用 在函数退出 并且局部资源被释放的时候 调用&lt;/strong&gt;</span></span><br><span class="line"><span class="keyword">defer</span> l.<span class="type">Unlock</span>()  </span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这里我们再一次见证了Go语言defer关键字带来的优雅。</p><h1><span id="17-全局唯一操作-synconcedo-syncatomic原子操作子包">17、全局唯一操作 sync.Once.Do() sync.atomic原子操作子包</span></h1><p>对于从全局的角度只需要运行一次的代码，比如全局初始化操作，Go语言提供了一个****Once类型来保证全局的唯一性操作****，具体代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> once sync.Once  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello, world&quot;</span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">    once.Do(setup)</span><br><span class="line">    <span class="built_in">print</span>(a)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoprint</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> doprint()</span><br><span class="line">    <span class="keyword">go</span> doprint()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果这段代码没有引入Once， setup()将会被每一个goroutine先调用一次， 这至少对于这个例子是多余的。在现实中，我们也经常会遇到这样的情况。Go语言标准库为我们引入了Once类型以解决这个问题。****once的Do()方法可以保证在全局范围内只调用指定的函数一次****（这里指setup()函数），而且所有其他goroutine在调用到此语句时，将会先被阻塞，直至全局唯一的once.Do()调用结束后才继续。</p><p>这个机制比较轻巧地解决了使用其他语言时开发者不得不自行设计和实现这种Once效果的难题，也是Go语言为并发性编程做了尽量多考虑的一种体现。</p><p>如果没有once.Do()，我们很可能只能添加一个全局的bool变量，在函数setup()的最后一行将该bool变量设置为true。在对setup()的所有调用之前，需要先判断该bool变量是否已经被设置为true，如果该值仍然是false，则调用一次setup()，否则应跳过该语句。实现代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> done <span class="type">bool</span> = <span class="literal">false</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a = <span class="string">&quot;hello, world&quot;</span> </span><br><span class="line">    done = <span class="literal">true</span></span><br><span class="line">&#125;     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doprint</span><span class="params">()</span></span> &#123; </span><br><span class="line">    <span class="keyword">if</span> !done &#123;</span><br><span class="line">        setup()</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">print</span>(a)  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这段代码初看起来比较合理， 但是细看还是会有问题， 因为****setup()并不是一个原子性操作****，这种写法可能导致setup()函数被多次调用，从而无法达到全局只执行一次的目标。这个问题的复杂性也更加体现了Once类型的价值。 &#x2F;&#x2F;还没有执行到done&#x3D;true的时候  另外调用doprint已经执行起来。</p><p>为了更好地控制并行中的原子性操作，sync包中还包含一个atomic子包，它提供了对于一些基础数据类型的原子操作函数，比如下面这个函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CompareAndSwapUint64</span><span class="params">(val *<span class="type">uint64</span>, old, <span class="built_in">new</span> <span class="type">uint64</span>)</span></span> (swapped <span class="type">bool</span>)</span><br></pre></td></tr></table></figure><p>就提供了比较和交换两个uint64类型数据的操作。这让开发者无需再为这样的操作专门添加Lock操作。</p><p>转载链接：<a href="http://lib.csdn.net/article/53/36140?knId=1441">http://lib.csdn.net/article/53/36140?knId=1441</a></p>]]></content>
      
      
      <categories>
          
          <category> GOLANG </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HEXO快捷方式</title>
      <link href="/blog/2020/06/09/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/"/>
      <url>/blog/2020/06/09/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p><a href="https://www.jianshu.com/p/1c888a6b8297?utm_source=oschina-app">https://www.jianshu.com/p/1c888a6b8297?utm_source=oschina-app</a></p><h3><span id="新编写blog">新编写BLOG</span></h3><p>hexo new [layout] <title></title></p><h3><span id="push到github">push到github：</span></h3><p>hexo deploy</p><p>hexo clean</p><p>hexo deploy</p><h3><span id="每次都要执行-hexo-clean-和-hexo-deploy不如写个新的脚本">每次都要执行 hexo clean 和 hexo deploy，不如写个新的脚本</span></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&quot;dev&quot;: &quot;hexo s&quot;,</span><br><span class="line">&quot;build&quot;: &quot;hexo clean &amp; hexo deploy&quot;</span><br></pre></td></tr></table></figure><p>npm run build</p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MYSQl索引</title>
      <link href="/blog/2020/06/09/tech/backend/database/mysql/MYSQl-%E7%B4%A2%E5%BC%95/"/>
      <url>/blog/2020/06/09/tech/backend/database/mysql/MYSQl-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>docker logs -t -f –tail 100 im4<br>处理init问题</p><p>一、查询和更新上的区别<br>这两类索引在查询能力上是没差别的，主要考虑的是对更新性能的影响。建议尽量选择普通索引。<br>1.1 MySQL 的查询操作<br>普通索引<br>查找到第一个满足条件的记录后，继续向后遍历，直到第一个不满足条件的记录。<br>唯一索引<br>由于索引定义了唯一性，查找到第一个满足条件的记录后，直接停止继续检索。<br>普通索引会多检索一次，几乎没有影响。因为 InnoDB 的数据是按照数据页为单位进行读写的，需要读取数据时，并不是直接从磁盘读取记录，而是先把数据页读到内存，再去数据页中检索。<br>一个数据页默认 16 KB，对于整型字段，一个数据页可以放近千个 key，除非要读取的数据在数据页的最后一条记录，就需要再读一个数据页，这种情况很少，对CPU的消耗基本可以忽略了。<br>因此说，在查询数据方面，普通索引和唯一索引没差别。</p><p>1.2 MySQL 的更新操作<br>更新操作并不是直接对磁盘中的数据进行更新，是先把数据页从磁盘读入内存，再更新数据页。<br>普通索引<br>将数据页从磁盘读入内存，更新数据页。<br>唯一索引<br>将数据页从磁盘读入内存，判断是否唯一，再更新数据页。<br>由于 MySQL 中有个 change buffer 的机制，会导致普通索引和唯一索引在更新上有一定的区别。<br>change buffer的作用是为了降低IO 操作，避免系统负载过高。change buffer将数据写入数据页的过程，叫做merge。<br>如果需要更新的数据页在内存中时，会直接更新数据页；如果数据不在内存中，会先将更新操作记入change buffer，当下一次读取数据页时，顺带merge到数据页中，change buffer也有定期merge策略。数据库正常关闭的过程中，也会触发merge。<br>对于唯一索引，更新前需要判断数据是否唯一（不能和表中数据重复），如果数据页在内存中，就可以直接判断并且更新，如果不在内存中，就需要去磁盘中读出来，判断一下是否唯一，是的话就更新。change buffer是用不到的。即使数据页不在内存中，还是要读出来。<br>change buffer 用的是 buffer pool 里的内存，因此不能无限增大。change buffer 的大小，可以通过参数 innodb_change_buffer_max_size 来动态设置。这个参数设置为 50 的时候，表示 change buffer 的大小最多只能占用 buffer pool 的 50%。</p><p>结论：唯一索引用不了change buffer，只有普通索引可以用。</p><p>二、change buffer 和 redo log的区别<br>2.1 change buffer 的适用场景<br>change buffer 的作用是降低更新操作的频率，缓存更新操作。这样会有一个缺点，就是更新不及时，对于读操作比较频繁的表，不建议使用 change buffer。<br>因为更新操作刚记录进change buffer中，就读取了该表，数据页被读到了内存中，数据马上就merge到数据页中了。这样不仅不会降低性能消耗，反而会增加维护change buffer的成本。<br>适用于写多读少的表。</p><p>2.2 change buffer 和 redo log 区别<br>我们举一个例子用来理解 redo log 和 change buffer。我们执行以下 SQL 语句：<br>mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</p><p>假设，(id1,k1) 在数据页 Page 1 中，(id2,k2) 在数据页 Page 2 中。并且 Page 1 在内存中，Page 2 不在内存中。<br>执行过程如下：<br>直接向 Page 1 中写入 (id1,k1)；<br>在change buffer 中记下”向 Page 2 中写入(id2,k2)”这条信息；<br>将以上两个动作记入redo log。<br>做完上面这些，事务就可以完成了。执行这条更新语句的成本很低，就是写了两处内存，然后写了一处磁盘（两次操作合在一起写了一次磁盘），而且还是顺序写的。<br>这条更新语句，涉及了四个部分：内存、redo log（ib_log_fileX）、 数据表空间（t.ibd）、系统表空间（ibdata1）。<br>如果要读数据的话，过程是怎样的？<br>mysql&gt; select * from t where k in (k1, k2);</p><p>假设读操作在更新后不久，此时内存中还有 Page 1，没有 Page 2，那么读操作就和 redo log 以及 ibdata1 无关了。<br>从内存中获取到 Page 1 上的最新数据 (id1,k1)；<br>将数据页 Page 2 读入内存，执行merge 操作，此时内存中的 Page 2 也有最新数据(id2,k2)；<br>需要注意的是：<br>redo log中的数据，可能还没有 flush 到磁盘，磁盘中的 Page 1 和 Page 2 中并没有最新数据，但我们依然可以拿到最新数据（内存中的 Page 1 就是最新的，Page 2 虽然不是最新的，但是从磁盘读到内存中后，执行了merge操作，内存中的 Page 2 就是最新的了。）<br>如果此时 MySQL 异常宕机了，比如服务器异常掉电，change buffer 中的数据会不会丢？</p><p>change buffer 中的数据分为两部分，一部分是已经merge到ibdata1中的数据，这部分数据已经持久化，不会丢失。另一部分数据，还在 change buffer 中，没有merge 到ibdata1，分 3 种情况：</p><p>（1）change buffer 写入数据到内存，redo log 也已经写入（ib-log-filex），但是未 commit，binlog中也没有fsync到磁盘，这部分数据会丢失；<br>（2）change buffer 写入数据到内存，redo log 也已经写入（ib-log-filex），但是未 commit，binlog 已写入到磁盘，这部分不会多丢失，异常重启后会先从 binlog 恢复 redo log，再从 redo log 恢复 change buffer；<br>（3）change buffer 写入数据到内存，redo log 和 binlog 都已经fsync，直接从redo log 恢复，不会丢失。<br>redo log 主要节省的是随机写磁盘的 IO 消耗（转成顺序写），而 change buffer 主要节省的则是随机读磁盘的 IO 消耗</p><p>转载自：<a href="https://www.cnblogs.com/hhhhuanzi/p/12318504.html">https://www.cnblogs.com/hhhhuanzi/p/12318504.html</a></p>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MYSQL_排序</title>
      <link href="/blog/2020/01/20/tech/backend/database/mysql/MYSQL-%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2020/01/20/tech/backend/database/mysql/MYSQL-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MSYQL </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/blog/2019/12/27/tech/backend/database/mysql/MYSQL-%E6%97%A5%E5%BF%97/"/>
      <url>/blog/2019/12/27/tech/backend/database/mysql/MYSQL-%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="mysql">MYSQL</span></h3><ul><li><p>首先分享一个查看大日志的工具，只有几百k,适合用来实时查看mysql的日志</p><p><code>BareTail </code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MYSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日志 </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO-butteryly</title>
      <link href="/blog/2019/12/18/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-butteryly/"/>
      <url>/blog/2019/12/18/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-butteryly/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="主题文档">主题·文档</span></h3><p><a href="https://jerryc.me/">https://jerryc.me/</a></p><h3><span id="评论系统">评论系统</span></h3><p>gittalk<br><a href="https://github.com/settings/applications/1190035">https://github.com/settings/applications/1190035</a><br>登录GitHub进行评论，会生成issue<br>Valine<br><a href="https://leancloud.cn/dashboard/applist.html#/apps">https://leancloud.cn/dashboard/applist.html#/apps</a><br>特点在于可以免登陆进行评论，输入验证码评论</p><p>Laibili（来必力）<br>域名到期不稳定<br>Disqus<br>暂时未测试使用到期</p><p>还是准备用valine做第一期</p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HEXO-butteryly</title>
      <link href="/blog/2019/12/18/tech/devops/site/%E5%BB%BA%E7%AB%99-HEXO-butteryly/"/>
      <url>/blog/2019/12/18/tech/devops/site/%E5%BB%BA%E7%AB%99-HEXO-butteryly/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><h3><span id="主题文档">主题·文档</span></h3><p><a href="https://jerryc.me/">https://jerryc.me/</a></p><h3><span id="评论系统">评论系统</span></h3><p>gittalk<br><a href="https://github.com/settings/applications/1190035">https://github.com/settings/applications/1190035</a><br>登录GitHub进行评论，会生成issue<br>Valine<br><a href="https://leancloud.cn/dashboard/applist.html#/apps">https://leancloud.cn/dashboard/applist.html#/apps</a><br>特点在于可以免登陆进行评论，输入验证码评论</p><p>Laibili（来必力）<br>域名到期不稳定<br>Disqus<br>暂时未测试使用到期</p><p>还是准备用valine做第一期</p>]]></content>
      
      
      <categories>
          
          <category> 运维部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HEXO </tag>
            
            <tag> 主题 </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词条</title>
      <link href="/blog/2019/12/18/other/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AF%8D%E6%9D%A1/"/>
      <url>/blog/2019/12/18/other/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E8%AF%8D%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>rss:</p><p>简易信息聚合（也叫聚合内容）是一种RSS基于XML标准，在互联网上被广泛采用的内容包装和投递协议。RSS(Really Simple Syndication)是一种描述和同步网站内容的格式，是使用最广泛的XML应用。RSS搭建了信息迅速传播的一个技术平台，使得每个人都成为潜在的信息提供者。发布一个RSS文件后，这个RSS Feed中包含的信息就能直接被其他站点调用，而且由于这些数据都是标准的XML格式，所以也能在其他的终端和服务中使用，是一种描述和同步网站内容的格式。 [1]  RSS可以是以下三个解释的其中一个： Really Simple Syndication；RDF (Resource Description Framework) Site Summary； Rich Site Summary。但其实这三个解释都是指同一种Syndication的技术。<br>RSS广泛用于网上新闻频道，blog和wiki，主要的版本有0.91, 1.0, 2.0。使用RSS订阅能更快地获取信息，网站提供RSS输出，有利于让用户获取网站内容的最新更新。网络用户可以在客户端借助于支持RSS的聚合工具软件，在不打开网站内容页面的情况下阅读支持RSS输出的网站内容。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编码</title>
      <link href="/blog/2019/12/17/other/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BC%96%E7%A0%81/"/>
      <url>/blog/2019/12/17/other/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>出现%20 或者%%的问题</p><p><a href="http://www.soupan.info/tool/utf-8.php">http://www.soupan.info/tool/utf-8.php</a><br>%20&#x2F;</p><p>编码空格字符的URL：+或%20？</p><p>当URL中的空格编码为+，什么时候编码到%20?</p><p>%7C%7C%20</p><p>||</p><p>按“转换”即可将其转换为UTF-8字符。再按“还原”即可将其还原为简体中文。</p><blockquote><p>【转】utf-8的中文是一个汉字占三个字节长度<br>英文字母和中文汉字在不同字符集编码下的字节数<br>英文字母：</p></blockquote><p>字节数 : 1;编码：GB2312</p><p>字节数 : 1;编码：GBK</p><p>字节数 : 1;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 1;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><p>中文汉字：</p><p>字节数 : 2;编码：GB2312</p><p>字节数 : 2;编码：GBK</p><p>字节数 : 2;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 3;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><p>1、美国人首先对其英文字符进行了编码，也就是最早的ascii码，用一个字节的低7位来表示英文的128个字符，高1位统一为0；</p><p>2、后来欧洲人发现尼玛你这128位哪够用，比如我高贵的法国人字母上面的还有注音符，这个怎么区分，得，把高1位编进来吧，这样欧洲普遍使用一个全字节进行编码，最多可表示256位。欧美人就是喜欢直来直去，字符少，编码用得位数少；</p><p>3、但是即使位数少，不同国家地区用不同的字符编码，虽然0–127表示的符号是一样的，但是128–255这一段的解释完全乱套了，即使2进制完全一样，表示的字符完全不一样，比如135在法语，希伯来语，俄语编码中完全是不同的符号；</p><p>4、更麻烦的是，尼玛这电脑高科技传到中国后，中国人发现我们有10万多个汉字，你们欧美这256字塞牙缝都不够。于是就发明了GB2312这些汉字编码，典型的用2个字节来表示绝大部分的常用汉字，最多可以表示65536个汉字字符，这样就不难理解有些汉字你在新华字典里查得到，但是电脑上如果不处理一下你是显示不出来的了吧。</p><p>5、这下各用各的字符集编码，这世界咋统一？俄国人发封email给中国人，两边字符集编码不同，尼玛显示都是乱码啊。为了统一，于是就发明了unicode，将世界上所有的符号都纳入其中，每一个符号都给予一个独一无二的编码，现在unicode可以容纳100多万个符号，每个符号的编码都不一样，这下可统一了，所有语言都可以互通，一个网页页面里可以同时显示各国文字。</p><p>6、然而，unicode虽然统一了全世界字符的二进制编码，但没有规定如何存储啊，亲。x86和amd体系结构的电脑小端序和大端序都分不清，别提计算机如何识别到底是unicode还是acsii了。如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，文本文件的大小会因此大出二三倍，这对于存储来说是极大的浪费。这样导致一个后果：出现了Unicode的多种存储方式。</p><p>7、互联网的兴起，网页上要显示各种字符，必须统一啊，亲。utf-8就是Unicode最重要的实现方式之一。另外还有utf-16、utf-32等。UTF-8不是固定字长编码的，而是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。这是种比较巧妙的设计，如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。</p><p>8、注意unicode的字符编码和utf-8的存储编码表示是不同的，例如”严”字的Unicode码是4E25，UTF-8编码是E4B8A5，这个7里面解释了的，UTF-8编码不仅考虑了编码，还考虑了存储，E4B8A5是在存储识别编码的基础上塞进了4E25。</p><p>9、UTF-8 使用一至四个字节为每个字符编码。128 个 ASCII 字符（Unicode 范围由 U+0000 至 U+007F）只需一个字节，带有变音符号的拉丁文、希腊文、西里尔字母、亚美尼亚语、希伯来文、阿拉伯文、叙利亚文及马尔代夫语（Unicode 范围由 U+0080 至 U+07FF）需要二个字节，其他基本多文种平面（BMP）中的字符（CJK属于此类-Qieqie注）使用三个字节，其他 Unicode 辅助平面的字符使用四字节编码。</p><p>10、最后，要回答你的问题，常规来看，中文汉字在utf-8中到底占几个字节，一般是3个字节，最常见的编码方式是1110xxxx 10xxxxxx 10xxxxxx。</p><hr><blockquote><p>知乎解答 <a href="https://www.zhihu.com/question/23374078">https://www.zhihu.com/question/23374078</a><br>Unicode 是「字符集」<br>UTF-8 是「编码规则」<br>其中：<br>字符集：为每一个「字符」分配一个唯一的 ID（学名为码位 &#x2F; 码点 &#x2F; Code Point）<br>编码规则：将「码位」转换为字节序列的规则（编码&#x2F;解码 可以理解为 加密&#x2F;解密 的过程）<br>广义的 Unicode 是一个标准，定义了一个字符集以及一系列的编码规则，即 Unicode 字符集和UTF-8、UTF-16、UTF-32 等等编码……<br>Unicode 字符集为每一个字符分配一个码位，例如「知」的码位是 30693，记作 U+77E5（30693的十六进制为 0x77E5）。</p></blockquote><p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节：</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> wiki </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-hello-world/"/>
      <url>/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-HEXO-hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图片链接</title>
      <link href="/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5/"/>
      <url>/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-%E5%9B%BE%E7%89%87%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>github头像地址链接<br> <a href="https://avatars0.githubusercontent.com/u/23631580?s=400&u=8adfff85bef758535f26ec7c91204d21da557643&v=4">https://avatars0.githubusercontent.com/u/23631580?s=400&amp;u=8adfff85bef758535f26ec7c91204d21da557643&amp;v=4</a><br> 微信头像地址<br> <a href="http://s2-cdn.oneitfarm.com/e12ece12233b4059860acf48637d830a.jpg">http://s2-cdn.oneitfarm.com/e12ece12233b4059860acf48637d830a.jpg</a><br> 动态壁纸链接：<br> <a href="https://source.unsplash.com/collection/collectionid/1600x900">https://source.unsplash.com/collection/collectionid/1600x900</a><br> <a href="https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture">https://uploadbeta.com/api/pictures/random/?key=BingEverydayWallpaperPicture</a><br> <a href="https://api.dujin.org/bing/1920.php">https://api.dujin.org/bing/1920.php</a><br> <a href="https://api.dujin.org/bing/1366.php">https://api.dujin.org/bing/1366.php</a></p><p>blog背景链接：<br>wechat:<br><a href="http://s2-cdn.oneitfarm.com/ec13d36268ae41d7aaf87d5505324b6a.png">http://s2-cdn.oneitfarm.com/ec13d36268ae41d7aaf87d5505324b6a.png</a>   (迷你版本)<br><a href="http://s2-cdn.oneitfarm.com/fc44dd8d7da4467da3831cd9e6229e19.jpg">http://s2-cdn.oneitfarm.com/fc44dd8d7da4467da3831cd9e6229e19.jpg</a><br>alipay:<br><a href="http://s2-cdn.oneitfarm.com/2eef3a681187495aa43ff8bbe1173c09.png">http://s2-cdn.oneitfarm.com/2eef3a681187495aa43ff8bbe1173c09.png</a>   (迷你版本)<br><a href="http://s2-cdn.oneitfarm.com/96c2b14feb774e49ae2d110bb500770c.jpg">http://s2-cdn.oneitfarm.com/96c2b14feb774e49ae2d110bb500770c.jpg</a></p><p>网站默认背景：<br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/top_img_index.jpg">https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/top_img_index.jpg</a></p><p>文字默认图片：<br>default_cover: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png</a></p><p>阅读背景：<br>archive_img: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/archive.jpg">https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/archive.jpg</a></p><p>tag背景：<br>tag_img: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/tag-bg.png">https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/tag-bg.png</a></p><p>目录背景：<br>category_img: <a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/category-bg">https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/category-bg</a></p><p>如果你有使用hexo-douban去生成movie界面，可配置這個<br><a href="https://cdn.jsdelivr.net/gh/jerryc127/CDN/Photo/movie.jpg">https://cdn.jsdelivr.net/gh/jerryc127/CDN/Photo/movie.jpg</a></p><p>评论背景<br><a href="http://s2-cdn.oneitfarm.com/94f489ea603c42ed854f035fe491222d.png">http://s2-cdn.oneitfarm.com/94f489ea603c42ed854f035fe491222d.png</a></p><p>404背景<br><a href="http://s2-cdn.oneitfarm.com/b09dd72b0fb94cbaab76bdfbb121c4d6.jpg">http://s2-cdn.oneitfarm.com/b09dd72b0fb94cbaab76bdfbb121c4d6.jpg</a><br>icp背景<br><a href="http://s2-cdn.oneitfarm.com/850aa332dae84b7c8f82f5d0631aa154.png">http://s2-cdn.oneitfarm.com/850aa332dae84b7c8f82f5d0631aa154.png</a></p><p>loading 的svg<br><a href="http://s2-cdn.oneitfarm.com/7ab2d4e7a3a34c81912580725f45c393.svg">http://s2-cdn.oneitfarm.com/7ab2d4e7a3a34c81912580725f45c393.svg</a></p><p>algolia的svg<br><a href="http://s2-cdn.oneitfarm.com/0339c65e9ab74f3e919624ed02755dba.svg">http://s2-cdn.oneitfarm.com/0339c65e9ab74f3e919624ed02755dba.svg</a></p><p>私有的bg<br><a href="https://s2-cdn.oneitfarm.com/92b19077218b48d8b6c1f8726d736c9f.jpg">https://s2-cdn.oneitfarm.com/92b19077218b48d8b6c1f8726d736c9f.jpg</a></p>]]></content>
      
      
      <categories>
          
          <category> 建站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> photo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PV,UV</title>
      <link href="/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-My-New-Post/"/>
      <url>/blog/2019/12/16/%E5%BB%BA%E7%AB%99/%E5%BB%BA%E7%AB%99-My-New-Post/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\blog\assets\css\APlayer.min.css"><script src="\blog\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\blog\assets\js\Meting.min.js"></script><p>PV：页面访问量，即PageView，用户每次对网站的访问均被记录，用户对同一页面的多次访问，访问量累计。 UV：独立访问用户数：即UniqueVisitor，访问网站的一台电脑客户端为一个访客。00:00-24:00内相同的客户端只被计算一次。</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
          <category> PlayStation </category>
          
          <category> Games </category>
          
          <category> Life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
